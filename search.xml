<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>对于redis你知道多少</title>
    <url>/2022/09/24/redis/</url>
    <content><![CDATA[<h2 id="1-Redis是单线程的"><a href="#1-Redis是单线程的" class="headerlink" title="1.Redis是单线程的!"></a>1.Redis是单线程的!</h2><p>明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器</p>
<p>的内存和网络带宽,既然可以使用单线程来实现，就使用单线程了! 所以就使用了单线程了 !</p>
<p>Redis是C语言写的,官方提供的数据为 100000+的QPS,完全不比同样是使用key-vale的Memecache差！</p>
<h3 id="Redis为什么单线程还怎么快"><a href="#Redis为什么单线程还怎么快" class="headerlink" title="Redis为什么单线程还怎么快?"></a>Redis为什么单线程还怎么快?</h3><ol>
<li>误区1:&#x3D;&#x3D;高性能的服务器一定是多线程的&#x3D;&#x3D;</li>
</ol>
<p>2.误区2:&#x3D;&#x3D;多线程(CPU上下文会切换!)一定比单线程效率高!&#x3D;&#x3D;</p>
<h3 id="核心-redis是将所有的数据全部放在内存中的-所以说使用单线程去操作效率就是最高的"><a href="#核心-redis是将所有的数据全部放在内存中的-所以说使用单线程去操作效率就是最高的" class="headerlink" title="核心:redis是将所有的数据全部放在内存中的,所以说使用单线程去操作效率就是最高的,"></a>核心:redis是将所有的数据全部放在内存中的,所以说使用单线程去操作效率就是最高的,</h3><h4 id="多线程-CPU上下文会切换-耗时的操作-，对于内存系统来说-如果没有上下文切换效率就是最高的-多次读写都是在"><a href="#多线程-CPU上下文会切换-耗时的操作-，对于内存系统来说-如果没有上下文切换效率就是最高的-多次读写都是在" class="headerlink" title="多线程(CPU上下文会切换:耗时的操作)，对于内存系统来说,如果没有上下文切换效率就是最高的! 多次读写都是在"></a>多线程(CPU上下文会切换:耗时的操作)，对于内存系统来说,如果没有上下文切换效率就是最高的! 多次读写都是在</h4><h4 id="一个CPU上的-在内存情况下-这个就是最佳的方案"><a href="#一个CPU上的-在内存情况下-这个就是最佳的方案" class="headerlink" title="一个CPU上的,在内存情况下,这个就是最佳的方案!"></a>一个CPU上的,在内存情况下,这个就是最佳的方案!</h4><h2 id="2-五大基本数据类型"><a href="#2-五大基本数据类型" class="headerlink" title="2.五大基本数据类型"></a>2.五大基本数据类型</h2><h3 id="1-String字符串类型详解"><a href="#1-String字符串类型详解" class="headerlink" title="1.String字符串类型详解"></a>1.String字符串类型详解</h3><ul>
<li><p>get key vlaue &#x3D;&#x3D;设置键和值&#x3D;&#x3D;</p>
</li>
<li><p>exist key &#x3D;&#x3D;查看是否有这个键&#x3D;&#x3D;</p>
</li>
<li><p>expire 键 时间 &#x3D;&#x3D;让这个键在多少时间失效  (可以设置一个定时失效功能,比如验证码或者二维码等)&#x3D;&#x3D;</p>
</li>
<li><p>setex(set with expire) &#x3D;&#x3D;设置值并设置过期时间&#x3D;&#x3D;</p>
</li>
<li><p>setnx(set with noexit) &#x3D;&#x3D;设置一个不存在的键的值&#x3D;&#x3D;</p>
</li>
<li><p>ttl 键 &#x3D;&#x3D;查看这个键还有多少失效&#x3D;&#x3D;   </p>
</li>
<li><p>keys *&#x3D;&#x3D;查看所有的键&#x3D;&#x3D;  </p>
</li>
<li><p>append 键 +值  &#x3D;&#x3D;在这个键的末尾追加值(如果这个键没有的话就会自动创建)&#x3D;&#x3D;</p>
</li>
<li><p>incr 键 &#x3D;&#x3D;让这个键的值自增(incrby  键 数目 自增多少数目)&#x3D;&#x3D;  </p>
</li>
<li><p>decr 键  &#x3D;&#x3D;让这个键的值自减&#x3D;&#x3D;</p>
</li>
<li><p>getrange 键 start and end &#x3D;&#x3D;取开始和结尾的值&#x3D;&#x3D;  </p>
</li>
<li><p>setrange 键  &#x3D;&#x3D;第几个值  要替换的结果  替换字符串&#x3D;&#x3D;</p>
</li>
<li><p>mset &#x3D;&#x3D;可以同时设置多个键和值&#x3D;&#x3D;</p>
</li>
<li><p>mget &#x3D;&#x3D;可以同时获取多的值&#x3D;&#x3D;</p>
</li>
</ul>
<h4 id="扩展-对象"><a href="#扩展-对象" class="headerlink" title="扩展:对象"></a>扩展:对象</h4><p>set user:1{name:zhangsan,age:3)  &#x3D;&#x3D;设置一个user:1 对象 值为  json字符串来保存一个对象!&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;这里的key是一个巧妙的设计&#x3D;&#x3D;: user:{id}:{filed}  ,如此设计在Redis中是完全OK的</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">mest user:<span class="hljs-number">1</span>:name zhangsan  user:<span class="hljs-number">1</span> age <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>getset &#x3D;&#x3D;先get后set&#x3D;&#x3D;</p>
<p>String类似的使用场景:value除了是我们的字符串还可以是我们的数字！</p>
<p>String字符串类型可能会用的&#x3D;&#x3D;场景&#x3D;&#x3D;:</p>
<ul>
<li>&#x3D;&#x3D;计数器&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;统计多单位的数量&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;粉丝数&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;对象缓存存储&#x3D;&#x3D;</li>
</ul>
<h3 id="2-List列表类型详讲"><a href="#2-List列表类型详讲" class="headerlink" title="2.List列表类型详讲"></a>2.List列表类型详讲</h3><ul>
<li>lpush list one &#x3D;&#x3D;(将一个值或者多个值,插入到列表头部(左))&#x3D;&#x3D;</li>
<li>rpush list right&#x3D;&#x3D;(将一个值或者多个值,插入到列表尾部(右))&#x3D;&#x3D;</li>
<li>lrange list 0 -1 &#x3D;&#x3D;获取list中的值&#x3D;&#x3D;</li>
<li>lpop &#x3D;&#x3D;移除左边的值&#x3D;&#x3D;  rpop &#x3D;&#x3D;移除右边的值&#x3D;&#x3D;</li>
<li>lindex list 下标(从0开始的)  &#x3D;&#x3D;获取索引下标对应的值&#x3D;&#x3D;</li>
<li>llen list  &#x3D;&#x3D;返回列表的长度&#x3D;&#x3D;</li>
<li>lrem list (个数)  特定的值  &#x3D;&#x3D;移除list列表中特定的值&#x3D;&#x3D;</li>
<li>ltrim list  start end &#x3D;&#x3D;截取从start到end中值(索引为小标0开始)&#x3D;&#x3D;</li>
<li>rpoplpush &#x3D;&#x3D;将list中最后一个值移除到另外一个列表中(如果这个列表不存在则会创建)&#x3D;&#x3D;</li>
<li>lset list 下标 值  &#x3D;&#x3D;将列表中指定的下标值替换为给定的值（更新操作）如果list不存在则会报错,存在的话会进行更新操作&#x3D;&#x3D;</li>
<li>linsert  lsit  list中的某个具体的值  after或者before  要插入的值   &#x3D;&#x3D;在list中的某个具体的值中向前或者向后插入要插入的值&#x3D;&#x3D;</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1.他实际上是一个链表,before Node after ,left ,right 都可以插入值<br>2.如果key不存在,创建新的链表<br>3.如果key存在,新增内容<br>4.如果移除了所有值,空链表,也代表不存在<br>5.在两边插入或者改动值,效率最高! 中间元素,相对来说效率会低一点</p>
<p>&#x3D;&#x3D;消息排队！ 消息队列(Lpush Rpop) ，栈(LPush Lpop)&#x3D;&#x3D;</p>
<h3 id="3-Set集合类型详讲"><a href="#3-Set集合类型详讲" class="headerlink" title="3.Set集合类型详讲"></a>3.Set集合类型详讲</h3><ul>
<li>sadd  set  值  &#x3D;&#x3D;添加一个值到set集合中&#x3D;&#x3D;</li>
<li>smembers set &#x3D;&#x3D;展示所有set集合中的值&#x3D;&#x3D;</li>
<li>sismember  set  值  &#x3D;&#x3D;查看set集合中是否有这个值&#x3D;&#x3D;</li>
<li>scard set   &#x3D;&#x3D;查看set集合中有多少个元素&#x3D;&#x3D;</li>
<li>srem set 值  &#x3D;&#x3D;移除指定的值&#x3D;&#x3D;</li>
<li>srandmember set[个数]   &#x3D;&#x3D;随机抽取set集合中元素[可以指定个数]&#x3D;&#x3D;</li>
<li>spop set &#x3D;&#x3D;随机删除一些set集合中的元素&#x3D;&#x3D;</li>
<li>smove set1 set2 set1中的值  &#x3D;&#x3D;将set1集合中的值移动到set2中&#x3D;&#x3D;</li>
<li>sdiff set1 set2   &#x3D;&#x3D;显示set1中有set2中没有的元素(差集)&#x3D;&#x3D;</li>
<li>sinter set1 set2 &#x3D;&#x3D;显示set1和set2中公共的部分(交集)&#x3D;&#x3D;  【&#x3D;&#x3D;可以得到b站或者其他网站的共同关注的博主(2个账号)&#x3D;&#x3D;】</li>
<li>sunion set1 set2 &#x3D;&#x3D;显示并集&#x3D;&#x3D;(&#x3D;&#x3D;虎牙直播的一个用户所关注的全部放在一个set集合中,主播的粉丝数也放在一个集合中&#x3D;&#x3D;)</li>
</ul>
<p>场景:&#x3D;&#x3D;共同关注&#x3D;&#x3D;，&#x3D;&#x3D;共同爱好&#x3D;&#x3D; ,&#x3D;&#x3D;二度好友&#x3D;&#x3D;，&#x3D;&#x3D;推荐好友!&#x3D;&#x3D;（六度分割理论） </p>
<h3 id="4-Hash（哈希）详讲（本质和String没有什么区别-这是hash是key-vlaue）"><a href="#4-Hash（哈希）详讲（本质和String没有什么区别-这是hash是key-vlaue）" class="headerlink" title="4.Hash（哈希）详讲（本质和String没有什么区别,这是hash是key-vlaue）"></a>4.Hash（哈希）详讲（本质和String没有什么区别,这是hash是key-vlaue）</h3><h4 id="相当于Map集合-key-map"><a href="#相当于Map集合-key-map" class="headerlink" title="相当于Map集合(key-map)"></a>相当于Map集合(key-map)</h4><ul>
<li>hset  hash  键 值   &#x3D;&#x3D;添加一个值&#x3D;&#x3D;</li>
<li>hget  hash  键      &#x3D;&#x3D;获取一个值&#x3D;&#x3D;</li>
<li>hmset hash 键 值  键1 值1  &#x3D;&#x3D;添加多个值&#x3D;&#x3D;</li>
<li>hmget hash  键  键1  &#x3D;&#x3D;获取多个值&#x3D;&#x3D;</li>
<li>hgetall  &#x3D;&#x3D;获取一个hash中的所有值&#x3D;&#x3D;</li>
<li>hdel  &#x3D;&#x3D;删除一个hash中的key-vlaue&#x3D;&#x3D;</li>
<li>hlen &#x3D;&#x3D;返回hash中的长度&#x3D;&#x3D;</li>
<li>hexists  hash  键   &#x3D;&#x3D;查看hash中的键是否存在&#x3D;&#x3D;</li>
<li>hkeys  hash  &#x3D;&#x3D;获取hash中所有的键&#x3D;&#x3D;</li>
<li>hvals  hash&#x3D;&#x3D;获取hash中所有的值&#x3D;&#x3D;</li>
<li>hincrby  hash   键   数值   &#x3D;&#x3D;所对应的键自增数值&#x3D;&#x3D;  </li>
<li>hdecrby hash  键   数值    &#x3D;&#x3D;所对应的键自减数值&#x3D;&#x3D;</li>
</ul>
<p>实际场景:&#x3D;&#x3D;hash变更的数据user name age,尤其是用户信息之类的,经常变动的信息！hash更适合于对象的存储,<br>String更加适合字符串存储&#x3D;&#x3D;</p>
<h3 id="5-Zset（有序集合）"><a href="#5-Zset（有序集合）" class="headerlink" title="5.Zset（有序集合）"></a>5.Zset（有序集合）</h3><ul>
<li>&#x3D;&#x3D;在set的基础上,增加了一个值&#x3D;&#x3D;,set k1 v1  zset  k1  score v1  </li>
<li>zadd    zset    1（数字）  值      &#x3D;&#x3D;添加元素&#x3D;&#x3D;</li>
<li>zrange  zset 0  -1  &#x3D;&#x3D;取全部&#x3D;&#x3D;</li>
<li>zrangebyscore  zset  -inf  +inf（withscores）   &#x3D;&#x3D;将集合中的元素全部排序好取出(从小到大)（带成绩数字）&#x3D;&#x3D;</li>
<li>zrevrange zset  0 -1&#x3D;&#x3D;将集合中的元素全部排序好取出(从大到小)&#x3D;&#x3D;</li>
<li>zrem  zset 值  &#x3D;&#x3D;移除zset中的值&#x3D;&#x3D;</li>
<li>zcard  zset &#x3D;&#x3D;查看zset集合中的个数&#x3D;&#x3D;</li>
<li>zcount zset  start end &#x3D;&#x3D;(获取start到end区间的指定数量是多少)&#x3D;&#x3D;</li>
</ul>
<p>案例思路:&#x3D;&#x3D;set排序&#x3D;&#x3D; &#x3D;&#x3D;存储班级成绩表&#x3D;&#x3D;,&#x3D;&#x3D;工作表排序!&#x3D;&#x3D;<br>普通消息, 1  重要消息  2 ,&#x3D;&#x3D;带权重进行判断&#x3D;&#x3D;<br>&#x3D;&#x3D;排行榜应用实现&#x3D;&#x3D;,&#x3D;&#x3D;取Top N测试!&#x3D;&#x3D;</p>
<h2 id="3-三种特殊数据类型"><a href="#3-三种特殊数据类型" class="headerlink" title="3.三种特殊数据类型"></a>3.三种特殊数据类型</h2><h3 id="1-geoadd-添加地理位置"><a href="#1-geoadd-添加地理位置" class="headerlink" title="1.geoadd  添加地理位置"></a>1.geoadd  添加地理位置</h3><ul>
<li>有效的经度从-180到180度</li>
<li>有效的纬度从-85到85</li>
<li>&#x3D;&#x3D;规则:两级无法直接添加,我们一般会下载城市数据,直接通过java程序一次性导入！&#x3D;&#x3D;</li>
<li>参数  key 值 (纬度.经度.名称)</li>
<li>geoadd   chain:city   116.40 39.90 beijin  </li>
<li>geopos  chain:city beijin &#x3D;&#x3D;从值中获取具体的经纬度(获取当前定位:一定是一个坐标值)&#x3D;&#x3D;</li>
<li>geodist chain:city  beijing shanghai  &#x3D;&#x3D;得出beijing到shanghai的距离(默认单位为米) 可以加单位&#x3D;&#x3D;                                                             单位：m 米  km 千米  mi 英里  ft 英尺</li>
<li>georadius &#x3D;&#x3D;以给定的经纬度为中心,找出某一半径内的元素&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;我附件的人?(获取所有附件的人的地址,定位!) 通过半径来查询&#x3D;&#x3D;</li>
<li>georadius chain:city 110 30  500km (withdist)(withcoord)(count 数字) &#x3D;&#x3D;查看经度110 纬度30 方圆500千米之内的元素(集合中的)(带距离)  （带经纬度）(查询指定的数量)&#x3D;&#x3D;</li>
<li>georadiusbymember &#x3D;&#x3D;根据元素名找出半径内的元素&#x3D;&#x3D;</li>
<li>georadiusbymember chain:city  beijing  1000 km </li>
<li>geohash命令  &#x3D;&#x3D;返回一个或者多个位置元素的geohash表示(不常用)&#x3D;&#x3D;  &#x3D;&#x3D;该命令将返回11个字符的geohash字符串&#x3D;&#x3D;</li>
<li>geohash chain:city beijing   &#x3D;&#x3D;将二维的经纬度转换为一维的字符串,如果两个字符串越接近,那么则距离越近&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;geo底层的实现原理其实就是zset 我们可以使用zset命令来操作geo(进行删除或者别的)&#x3D;&#x3D;</li>
</ul>
<h3 id="2-Hyperloglog"><a href="#2-Hyperloglog" class="headerlink" title="2.Hyperloglog"></a>2.Hyperloglog</h3><h3 id="什么是基数"><a href="#什么是基数" class="headerlink" title="什么是基数?"></a>什么是基数?</h3><p>A{1,3,5,7,8,7}<br>B{1,3,5,7,8}  &#x3D;&#x3D;基数(不重复的元素),可以接受误差&#x3D;&#x3D;</p>
<p>简介</p>
<p>Redis 2.8.9版本就更新了Hyperloglog数据结构<br>Redis Hyperloglog 基数统计的算法<br>优点:&#x3D;&#x3D;占用的内存是固定&#x3D;&#x3D;,2^64不同的元素的技术,只需要废12kb内存!如果要从内存的角度来比较的话Hyperloglog首选<br>网页的UV(&#x3D;&#x3D;一个人访问一个网站多次,但是还是算一个人&#x3D;&#x3D;)<br>传统的方式,&#x3D;&#x3D;set保存用户的id，然后就可以统计set中的元素数量作为标准判断&#x3D;&#x3D;<br>这个方式如果保存大量的用户id,就会比较麻烦,我们的&#x3D;&#x3D;目的是为了计数&#x3D;&#x3D;,而&#x3D;&#x3D;不是保存用户id&#x3D;&#x3D;<br>0.81%错误率   统计UV任务,可以忽略不计的<br>pfadd  myhyp   a b c d e f  添加元素<br>pfadd  myhyp1   a b c d e f   e  g<br>pfcount  myhyp  统计数目<br>pfmerge  myhyp2 myhyp myhyp1  &#x3D;&#x3D;合并(并集)到myhyp2 (重复的元素不算)&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;如果允许容错,那么就一定可以使用Hyperloglog&#x3D;&#x3D;<br>&#x3D;&#x3D;如果不允许容错,就使用set或者自己的数据类型即可&#x3D;&#x3D;</p>
<h3 id="3-Bitmaps"><a href="#3-Bitmaps" class="headerlink" title="3.Bitmaps"></a>3.Bitmaps</h3><h4 id="位存储"><a href="#位存储" class="headerlink" title="位存储"></a>位存储</h4><p>&#x3D;&#x3D;统计用户信息&#x3D;&#x3D;,&#x3D;&#x3D;活跃,不活跃！&#x3D;&#x3D; &#x3D;&#x3D;登录，未登入 ！&#x3D;&#x3D; &#x3D;&#x3D;打卡  两个状态&#x3D;&#x3D;  都可以使用Bitmaps！<br>Bitmaps位图,数据结构！&#x3D;&#x3D;都是操作二进制位来进行记录&#x3D;&#x3D;,就&#x3D;&#x3D;只有0和1 两个状态&#x3D;&#x3D;<br>用bitmap来&#x3D;&#x3D;记录周一到周日的打卡情况&#x3D;&#x3D;<br>setbit sgin 1 0   setbit sgin 2  1   setbit sgin 3 0  …..<br>周一:0  周二:1  周三:0 …<br>查看某一天的打卡情况  getbit sgin 2  — 1   已经打卡<br>&#x3D;&#x3D;bitcount sgin 统计打卡的天数&#x3D;&#x3D;</p>
<h2 id="4-事务"><a href="#4-事务" class="headerlink" title="4.事务"></a>4.事务</h2><p>&#x3D;&#x3D;Redis单条命令是保证原子性的&#x3D;&#x3D;,但是&#x3D;&#x3D;事务不保证原子性&#x3D;&#x3D;<br>&#x3D;&#x3D;Redis事务本质&#x3D;&#x3D;:&#x3D;&#x3D;一组命令的集合&#x3D;&#x3D;! &#x3D;&#x3D;一个事务中所有命令都会被序列化&#x3D;&#x3D;,在事务执行过程中,会依照顺序执行<br>一次性,顺序性,排他性!执行一些列的命令!<br>—队列 set set set 执行—<br>&#x3D;&#x3D;Redis事务没有隔离级别的概念!&#x3D;&#x3D;<br>所有的命令在事务中,并没有直接被执行！只有发起执行命令的时候才会执行<br>redis的事务:</p>
<ul>
<li>开始事务（multi）</li>
<li>命令入队（自动完成）</li>
<li>执行事务（exec）<br>放弃事务 discard</li>
</ul>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">multi   <span class="hljs-comment">#开启事务</span><br><span class="hljs-built_in">set</span> k1 v1 <br><span class="hljs-built_in">set</span> k2 v2 <br>get k2 <br><span class="hljs-built_in">set</span> k3 v3<br><span class="hljs-built_in">exec</span>    <span class="hljs-comment">#执行事务</span><br></code></pre></td></tr></table></figure>



<p>编译型异常(&#x3D;&#x3D;代码有问题!命令错误！&#x3D;&#x3D;),&#x3D;&#x3D;事务中所有的命令都不会被执行&#x3D;&#x3D;</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2 <br>QUEUED<br>127.0.0.1:6379&gt; getset k3   <span class="hljs-comment">#命令错误,事务中的所有的命令都不会被执行</span><br>(error) ERR wrong number of arguments <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;getset&#x27;</span> <span class="hljs-built_in">command</span>  <br>127.0.0.1:6379&gt; get k2<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; get k2<br><span class="hljs-string">&quot;v2&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>

<p>运行时异常(I&#x2F;0)，&#x3D;&#x3D;如果事务队列中存在语法性错误&#x3D;&#x3D;,那么执行命令的时候,&#x3D;&#x3D;其他命令是可以正常执行的&#x3D;&#x3D;,错误命令抛出异常</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; incr k1<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; get k2<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>1) (error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range    <span class="hljs-comment">#这里是字符串不能做为自增的对象,运行时发生了异常</span><br>2) OK<br>3) <span class="hljs-string">&quot;v2&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>



<h3 id="监控-Watch-面试常问"><a href="#监控-Watch-面试常问" class="headerlink" title="监控!Watch(面试常问)"></a>监控!Watch(面试常问)</h3><h3 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1.悲观锁:"></a>1.悲观锁:</h3><p>很悲观,认为什么时候都会出问题,无论做什么都会加锁!  </p>
<h3 id="2-乐观锁："><a href="#2-乐观锁：" class="headerlink" title="2.乐观锁："></a>2.乐观锁：</h3><p>redis大多数是基于<strong>数据版本(version)的记录</strong>机制实现的。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表添加一个version字段来实现。在读取数据时，将此版本号一同读出，之后更新时对此版本号加1。此时，将提交数据的版本号与数据库表对应记录的当前版本号进行对比，<strong>如果提交的数据版本号大于数据库当前版本号，则予以更新</strong>，否则认为是过期数据。</p>
<ul>
<li>很乐观，认为什么时候都不会出问题,无论做什么都不会加锁! 更新数据的时候去判断一下,在此期间是否有人修<br>改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<p><font color=yellow>单线程</font>修改值可以成功</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; watch money<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; decrby money 20<br>QUEUED<br>127.0.0.1:6379&gt; incrby out 20<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>1) (<span class="hljs-built_in">integer</span>) 80<br>2) (<span class="hljs-built_in">integer</span>) 20<br><span class="hljs-comment">#监视成功</span><br></code></pre></td></tr></table></figure>

<p>Redis的视:watch</p>
<p><strong>watch,监视键值对，作用时如果事务提交exec时发现监视的监视对发生变化，事务将被取消。</strong></p>
<p>&#x3D;&#x3D;测试多线程修改值,使用watch可以当做redis的乐观锁操作&#x3D;&#x3D; : 修改值会失败</p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20220927164638199.png" alt="image-20220927164638199"></p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">Redis中对乐观锁的实现： 假设有一个age的key，我们开启两个session来对age进行赋值操作。<br>session1：<br>127.0.0.1:6379&gt; get age <br><span class="hljs-string">&quot;10&quot;</span> <br>127.0.0.1:6379&gt; watch age <span class="hljs-comment">#打开对age键的监控（监控其他操作是否对age键有修改操作） </span><br>OK<br>127.0.0.1:6379&gt; multi <span class="hljs-comment">#开启事务上下文 </span><br>OK<br><br>session2： <br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> age 20 <br>OK<br>127.0.0.1:6379&gt; get age <br><span class="hljs-string">&quot;20&quot;</span><br><br>再看session1： <br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> age 30 <span class="hljs-comment">#在session2中操作age后，我们在session1中继续操作age</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span> <span class="hljs-comment">#执行事务 返回nil 事务执行不成功。 </span><br>(nil) <br>127.0.0.1:6379&gt; get age <br><span class="hljs-string">&quot;20&quot;</span><br></code></pre></td></tr></table></figure>

<p>在这里我们发现事务不能执行成功，这就是因为session1中的<strong>数据版本已经小于数据库中的数据版本</strong>。这就是Redis的乐观锁。</p>
<p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/20201115115331630.png" alt="在这里插入图片描述"></p>
<h2 id="5-Jedis"><a href="#5-Jedis" class="headerlink" title="5.Jedis"></a>5.Jedis</h2><p>&#x3D;&#x3D;我们要使用java来操作Redis&#x3D;&#x3D;<br>什么是Jedis: &#x3D;&#x3D;是Redis官方推荐的java连接开发工具! 使用java操作Redis中间件!&#x3D;&#x3D; 如果你要使用java操作Redis<br>那么一定要对Jedis十分的熟悉</p>
<p>1.测试</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>           &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br>           &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>           &lt;version&gt;<span class="hljs-number">2.9</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>       &lt;/dependency&gt;<br>       &lt;dependency&gt;<br>           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>           &lt;artifactId&gt;fastjson&lt;/artifactId&gt;<br>           &lt;version&gt;<span class="hljs-number">1.2</span><span class="hljs-number">.76</span>&lt;/version&gt;<br>       &lt;/dependency&gt;<br> <span class="hljs-comment">///导入相关依赖</span><br></code></pre></td></tr></table></figure>

<p>2.编码测试:</p>
<ul>
<li>连接数据库</li>
<li>操作命令</li>
<li>断开连接</li>
</ul>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test_ping</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">6379</span>);<br>        System.out.println(jedis.ping());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果为PONG则说明ping通了</span><br></code></pre></td></tr></table></figure>



<h2 id="6-SpringBoot整合"><a href="#6-SpringBoot整合" class="headerlink" title="6.SpringBoot整合"></a>6.SpringBoot整合</h2><p>SpringBoot操作数据:spring-data  jpa jdbc  mongodb redis<br>SpringData也是和SpringBoot齐名的项目<br>说明︰在SpringBoot2.x之后，原来使用的<strong>jedis被替换为了lettuce?</strong><br>jedis :<font color=yellow>采用的直连</font>，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池!更像 BIO 模式<br>lettuce:<font color=yellow>采用netty</font>，实例可以再多个线程中进行共享，不存在线程不安全的情况!可以减少线程数据了,更像 NIO 模式</p>
<p><strong>源码分析:</strong></p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>   <span class="hljs-meta">@ConditionalOnMissingBean(</span><br><span class="hljs-meta">       name = &#123;&quot;redisTemplate&quot;&#125;</span><br><span class="hljs-meta">   )</span> <span class="hljs-comment">//当没有配置这个才会生效</span><br>   <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>   <span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>       <span class="hljs-comment">//默认的RedisTemplate没有过多的设置,redis对象都需要序列化!</span><br>       <span class="hljs-comment">//两个泛型都是Object,Object的类型,我们后使用需要强制转换&lt;String,Object&gt;</span><br>       RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>();<br>       template.setConnectionFactory(redisConnectionFactory);<br>       <span class="hljs-keyword">return</span> template;<br>   &#125;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">//由于String是redis中最常用的类型,所以单独提取出来一个</span><br>   <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>   <span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title function_">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisTemplate</span>(redisConnectionFactory);<br>   &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>整合测试一下</p>
</blockquote>
<p>1.导入依赖</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>           &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>       &lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<p>2.配置连接</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">#配置主机<br>spring.redis.host=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>#配置端口号<br>spring.redis.port=<span class="hljs-number">6379</span>   <br></code></pre></td></tr></table></figure>

<p>3.测试</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.springboot_redis;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnection;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootRedisApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span>  RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//redisTemplate  操作不同的数据类型 api和我们的指令是一样的</span><br>        <span class="hljs-comment">//opsForValue  操作字符串 类似String</span><br>        <span class="hljs-comment">//opsForList   操作list  opsForHash</span><br>        redisTemplate.opsForList().leftPush(<span class="hljs-string">&quot;list&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>);<br>        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">&quot;*&quot;</span>));<br>        redisTemplate.opsForHyperLogLog();<br>        redisTemplate.opsForZSet();<br>        <span class="hljs-comment">//获取连接</span><br>        <span class="hljs-type">RedisConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> redisTemplate.getConnectionFactory().getConnection();<br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;张启松&quot;</span>);<br>        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可序列化</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">RedisSerializer</span> <span class="hljs-variable">keySerializer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">RedisSerializer</span> <span class="hljs-variable">valueSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">RedisSerializer</span> <span class="hljs-variable">hashKeySerializer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">RedisSerializer</span> <span class="hljs-variable">hashValueSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20220927213010562.png" alt="image-20220927213010562"></p>
<p>默认的序列化是<font color=yellow>JDK序列化</font>的,所以要想自己想要的数据要自定义序列化类</p>
<p>如果没有对java对象序列化的话,引用的话会报错</p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20220928194027161.png" alt="image-20220928194027161"></p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20220928194017202.png" alt="image-20220928194017202"></p>
<p>对对象进行序列化操作,只需要进行 <font color=yellow>implements Serializable</font>即可</p>
<h4 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h4><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Config;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br>    <span class="hljs-comment">//编写自己的redsiTemplate</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;String, Object&gt;();<br>        template.setConnectionFactory(factory);<br><br>        <span class="hljs-comment">// 序列化配置 解析任意对象</span><br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-comment">// json序列化利用ObjectMapper进行转义</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        <span class="hljs-comment">// 2.序列化String类型</span><br>        <span class="hljs-type">StringRedisSerializer</span> <span class="hljs-variable">stringRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br><br>        <span class="hljs-comment">// key采用String的序列化方式</span><br>        template.setKeySerializer(stringRedisSerializer);<br>        <span class="hljs-comment">// hash的key也采用String的序列化方式</span><br>        template.setHashKeySerializer(stringRedisSerializer);<br>        <span class="hljs-comment">// value序列化方式采用jackson</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">// hash的value序列化方式采用jackson</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        template.afterPropertiesSet();<br><br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-Redis-conf"><a href="#7-Redis-conf" class="headerlink" title="7.Redis.conf"></a>7.Redis.conf</h2><ul>
<li>INCLUDES 组合多个配置</li>
<li>GENERAL 通用配置</li>
<li>SNAPSHOTTING 快照,用于持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 <strong>.rdb .aof</strong></li>
<li>REPLICATION 主从复制</li>
<li>SECURITY  安全问题(可以设置redis的登入密码,默认是没有密码的)</li>
<li>LIMITS  限制连接客户端的最大数量以及内存上限后的处理等</li>
<li>APPEND ONLY MODE   aof配置</li>
</ul>
<blockquote>
<p>容量单位不区分大小写，G和GB有区别</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020051321485460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<blockquote>
<p>可以使用 include 组合多个配置问题</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214902552.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>网络配置</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214912813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>日志输出级别</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214923678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<blockquote>
<p>日志输出文件</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214933713.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>持久化规则</p>
</blockquote>
<p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p>
<p>持久化方式：</p>
<ul>
<li>RDB</li>
<li>AOF</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200513214944964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>RDB文件相关</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214955679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200513215006207.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>主从复制</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513215016371.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Security模块中进行密码设置</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513215026143.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>客户端连接相关</p>
</blockquote>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">maxclients 10000  最大客户端数量<br>maxmemory &lt;bytes&gt; 最大内存限制<br>maxmemory-policy noeviction <span class="hljs-comment"># 内存达到限制值的处理策略</span><br>123<br></code></pre></td></tr></table></figure>

<p>redis 中的<strong>默认</strong>的过期策略是 <strong>volatile-lru</strong> 。</p>
<p><strong>设置方式</strong></p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">config <span class="hljs-built_in">set</span> maxmemory-policy volatile-lru <br></code></pre></td></tr></table></figure>

<p><strong>maxmemory-policy 六种方式</strong></p>
<p><strong>1、volatile-lru：</strong>只对设置了过期时间的key进行LRU（默认值）</p>
<p><strong>2、allkeys-lru ：</strong> 删除lru算法的key</p>
<p><strong>3、volatile-random：</strong>随机删除即将过期key</p>
<p><strong>4、allkeys-random：</strong>随机删除</p>
<p><strong>5、volatile-ttl ：</strong> 删除即将过期的</p>
<p><strong>6、noeviction ：</strong> 永不过期，返回错误</p>
<p> <strong>APPEND ONLY 模式 aof配置</strong></p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">appendonly no	<span class="hljs-comment"># 默认不开启aof模式，默认使用rdb方式持久化，几乎在所有情况下rdb够用</span><br><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span> <span class="hljs-comment"># 持久化文件的名字</span><br><br><span class="hljs-comment"># appendfsync always	# 每次修改都会同步，消耗性能</span><br>appendfsync everysec	<span class="hljs-comment"># 每秒都同步一次 sync，可能会丢失这1s数据</span><br><span class="hljs-comment"># appendfsync no		# 不执行同步，这时候操作系统自己同步数据，速度最快</span><br></code></pre></td></tr></table></figure>

<h2 id="8-Redis持久化"><a href="#8-Redis持久化" class="headerlink" title="8.Redis持久化"></a>8.Redis持久化</h2><h4 id="RDB（Redis-Database）"><a href="#RDB（Redis-Database）" class="headerlink" title="RDB（Redis Database）"></a>RDB（Redis Database）</h4><p><img src="https://img-blog.csdnimg.cn/2020051321523151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在主从复制中，rdb就是备用的！在从机上面</p>
<p>面试和工作，持久化必须是重点</p>
<p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以redis提供了持久化功能</p>
<p>在指定时间间隔内将内存中的数据集写入磁盘，也就是Snapshot快照，它恢复时是将文件直接读到内存里</p>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将书局写入到一个临时文件中，待持久化过程都结束了。再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF更加高效，<strong>RDB的缺点是最后一次持久化后的数据可能丢失。</strong>我们默认的就是RDB，一般情况下不需要修改这个配置。</p>
<p><font color=yellow>RDB保存的文件是dump.rdb</font>都是在我们配置文件中的快照中进行配置的</p>
<p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/490e34c578bff1f061a953356ab55865.png" alt="image"></p>
<p>自己测试一次，60s内修改5次，就会触发rdb操作</p>
<p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/1b9128e01b714fbfdf56c11a5bd29699.png" alt="image"></p>
<p><strong>flushall默认产生一个dump.rdb文件</strong></p>
<h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><ul>
<li>save规则满足的情况下，会自动触发rdb规则</li>
<li>执行flushall命令也会触发rdb规则</li>
<li>退出redis，也会产生rdb</li>
</ul>
<p><strong>备份就自动生成dump.rdb</strong><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/c6c0d341d5904b5708753742517786f9.png" alt="image"></p>
<h4 id="如何恢复rdb文件"><a href="#如何恢复rdb文件" class="headerlink" title="如何恢复rdb文件"></a>如何恢复rdb文件</h4><ol>
<li><p>只需要将<strong>rdb文件放在redis的启动目录下</strong>就可以了，redis启动的时候会自动检查dump.rdb文件恢复</p>
</li>
<li><p>查看需要存在的位置</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; config get <span class="hljs-built_in">dir</span><br>1) <span class="hljs-string">&quot;dir&quot;</span><br>2) <span class="hljs-string">&quot;/usr/local/redis-6.0.6/bin&quot;</span>	<span class="hljs-comment">#如果在这个目录下存在dump.rdb文件，启动就会自动恢复其中的数据</span><br></code></pre></td></tr></table></figure>

<p>几乎他自己的默认配置就够用了，但是我们还是学习</p>
<p>有时候在生产环境，我们会将这个文件进行备份</p>
</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li>适合大规模的数据恢复！dump.rdb</li>
<li>如果对数据完整性不高！</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>需要一定的时间间隔进行操作，如果redis意外宕机了，那么最后一次修改的数据就没有了</li>
<li>fork进程的时候会占用一定的内存空间</li>
</ol>
<h4 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h4><p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/3eb0e5a9501dfa3228e646cb18d34e44.png" alt="img"></p>
<p>将我们的所有命令都记录下来，history，恢复的时候把这个文件全部再执行一遍</p>
<p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件，但是不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从签到后执行一次以完成数据的恢复工作</p>
<p><strong>AOF保存的是appendonly.aof文件</strong></p>
<p>默认是不开启的，我们需要手动进行配置，我们只需要将appendonly改为yes即可</p>
<p>重启redis就可以生效了</p>
<p><strong>如果这个aof文件有错位，这时候redis是启动不起来的</strong>，我们需要修复这个aof文件</p>
<p>redis给我们提供了<strong>redis-check-aof –fix appendonly.aof</strong>来进行appendonly.aof的修复</p>
<p>如果文件正常，重启就可以直接恢复了</p>
<p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/0d004c953c67eb5e72b536d4229866ff.png" alt="image"></p>
<h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><p><strong>优点：</strong></p>
<ol>
<li>每一次修改都同步，文件完整性更加好</li>
<li>每同步一次，可能会丢失一秒的数据</li>
<li>从不同步</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>相对于数据文件来说，aof远远大于rdb，修复速度也比rdb慢</li>
<li>AOF运行效率也要比rdb慢，redis默认的配置就是rdb持久化</li>
</ol>
<h4 id="重写规则说明"><a href="#重写规则说明" class="headerlink" title="重写规则说明"></a>重写规则说明</h4><p>如果aof文件大于64MB，太大了，！fork一个新的进程来将我们文件进行重写</p>
<p>aof默认就是文件的无限追加，文件会越来越大</p>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h4><p>Redis 提供了不同级别的持久化方式:</p>
<ul>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</li>
<li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</li>
<li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
<li>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
<li>最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始:</li>
</ul>
<h4 id="RDB的优点"><a href="#RDB的优点" class="headerlink" title="RDB的优点"></a><strong>RDB的优点</strong></h4><ul>
<li>RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集.</li>
<li>RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复.</li>
<li>RDB在保存RDB文件时<strong>父进程唯一需要做的就是fork出一个子进程</strong>,接下来的工作全部由子进程来做，<strong>父进程不需要再做其他IO操作</strong>，所以RDB持久化方式可以最大化redis的性能.</li>
<li>与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些.</li>
</ul>
<h4 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h4><ul>
<li>如果你希望在redis意外停止工作（例如电源中断）的情况下<strong>丢失的数据最少</strong>的话，那么<strong>RDB不适合</strong>你.虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据.</li>
<li>RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度.</li>
</ul>
<h4 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF 优点"></a><strong>AOF 优点</strong></h4><ul>
<li>使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),<strong>一旦出现故障，你最多丢失1秒的数据.</strong></li>
<li>AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也<strong>可使用redis-check-aof工具修复这些问题</strong>.</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li>
</ul>
<h4 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF 缺点"></a><strong>AOF 缺点</strong></h4><ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h4 id="RDB和AOF对比"><a href="#RDB和AOF对比" class="headerlink" title="RDB和AOF对比"></a><strong>RDB和AOF对比</strong></h4><table>
<thead>
<tr>
<th>比较</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
</tbody></table>
<h2 id="9-Redis发布订阅"><a href="#9-Redis发布订阅" class="headerlink" title="9.Redis发布订阅"></a>9.Redis发布订阅</h2><p><strong>消息队列</strong></p>
<p><strong>通信，通过队列实现</strong>: 发送者 订阅者</p>
<p>Redis 发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。微信，微博</p>
<p>Redis客户端可以订阅任意数量的频道</p>
<p>订阅&#x2F;发布消息图：</p>
<p>第一个：消息发送者，第二个：频道 第三个：消息订阅者！</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dd6b8ef093cf55e0aa316e0a4f94a200.png" alt="image-20201105104248223"></p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215523258.png" alt="在这里插入图片描述"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="https://img-blog.csdnimg.cn/2020051321553483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>命令：</strong></p>
<p><font color=yellow>psubcribe pattern [pattern]</font> ：订阅一个或多个符合给定模式的频道</p>
<p><font color=yellow>pubsub subcommand [argument [argument]]</font>：查看订阅与发布系统状态</p>
<p><font color=yellow>publish channel message</font>：将信息发送到指定的频道</p>
<p><font color=yellow>punsubscribe [pattern [pattern]]</font>： 退订所有给定模式的频道</p>
<p><font color=yellow>subscribe channel [channel]</font>：订阅一个或多个频道的信息</p>
<p><font color=yellow>unsubscribe [channel [channel]]</font>： 退订给定的频道</p>
<p><strong>代码实现</strong>:</p>
<h3 id="1-订阅端"><a href="#1-订阅端" class="headerlink" title="1.订阅端"></a>1.订阅端</h3><figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; SUBSCRIBE sunzhongwei 	<span class="hljs-comment"># 订阅一个sunzhongwei频道</span><br>Reading messages... (press Ctrl-C to quit)<br>1) <span class="hljs-string">&quot;subscribe&quot;</span><br>2) <span class="hljs-string">&quot;sunzhongwei&quot;</span><br>3) (<span class="hljs-built_in">integer</span>) 1<br><span class="hljs-comment"># 等待读取推送的信息</span><br>1) <span class="hljs-string">&quot;message&quot;</span>	<span class="hljs-comment">#消息</span><br>2) <span class="hljs-string">&quot;sunzhongwei&quot;</span>	<span class="hljs-comment"># 哪个频道的消息</span><br>3) <span class="hljs-string">&quot;hello,sunzhongwei&quot;</span>	<span class="hljs-comment"># 具体内容</span><br>1) <span class="hljs-string">&quot;message&quot;</span><br>2) <span class="hljs-string">&quot;sunzhongwei&quot;</span><br>3) <span class="hljs-string">&quot;hello,Redis&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="2-发送端"><a href="#2-发送端" class="headerlink" title="2.发送端"></a>2.发送端</h3><figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; PUBLISH sunzhongwei <span class="hljs-string">&quot;hello,sunzhongwei&quot;</span>	<span class="hljs-comment"># 发布者发布消息到指定的频道</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; PUBLISH sunzhongwei <span class="hljs-string">&quot;hello,Redis&quot;</span><br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure>

<h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h3><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h&#x2F;redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p>
<p><img src="https://img-blog.csdnimg.cn/2020051321554964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p>
<h3 id="4-使用场景："><a href="#4-使用场景：" class="headerlink" title="4.使用场景："></a>4.使用场景：</h3><ul>
<li><h4 id="实时消息系统"><a href="#实时消息系统" class="headerlink" title="实时消息系统"></a>实时消息系统</h4></li>
<li><h4 id="实时聊天（频道当做聊天室）"><a href="#实时聊天（频道当做聊天室）" class="headerlink" title="实时聊天（频道当做聊天室）"></a>实时聊天（频道当做聊天室）</h4></li>
<li><h4 id="订阅关注系统"><a href="#订阅关注系统" class="headerlink" title="订阅关注系统"></a>订阅关注系统</h4></li>
</ul>
<h2 id="10-Redis主从复制"><a href="#10-Redis主从复制" class="headerlink" title="10. Redis主从复制"></a>10. Redis主从复制</h2><p> <strong>概念</strong>：</p>
<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(masterleader)，后者称为从节点(slave&#x2F;follower);数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p>
<p><strong>主从复制的作用主要包括:</strong><br>1、数据冗余∶主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。<br>2、故障恢复∶当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。<br>3、负载均衡︰在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载﹔尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。<br>4、高可用（集群）基石︰除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的(宕机，最少3个），原因如下:<br>1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大;<br>2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。<br>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。对于这种场景，我们可以使如下这种架构︰</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d8f97ed2519b086a298024d5c7675343.png" alt="image-20201105111148557"></p>
<p>主从复制，读写分离！80%情况下都是在进行读操作！减缓服务器压力，架构经常使用！一主二从！</p>
<p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中，不可能单机使用redis！</p>
<h4 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置:"></a>1.环境配置:</h4><p><strong>只配置从库，不用配置主库</strong>(因为默认为主节点)</p>
<p> <strong>主从复制信息</strong></p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">info replication <span class="hljs-comment"># 查看当前库的信息</span><br><br>127.0.0.1:6379&gt; info replication<br><span class="hljs-comment"># Replication</span><br>role:master		<span class="hljs-comment">#	角色：master</span><br>connected_slaves:0	<span class="hljs-comment">#显示从机数量</span><br>master_replid:85e0dc3072e2b2d876b7ff4a0cb53f961d7fd5e6<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure>

<h4 id="2-一主二从"><a href="#2-一主二从" class="headerlink" title="2. 一主二从:"></a>2. 一主二从:</h4><p><font color=red>默认情况下，每台Redis服务器都是主节点</font>，我们一般情况下只用配置从机就好了</p>
<p>认老大，一主（79）二从（80,81）</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">slaveof host port <span class="hljs-comment"># 设置这个主机的主人</span><br><br>127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379	<span class="hljs-comment"># 认定这个主机下的6379端口为主</span><br>OK<br>127.0.0.1:6380&gt; info replication<br><span class="hljs-comment"># Replication</span><br>role:slave<br>master_host:127.0.0.1	<span class="hljs-comment"># 可以看到主机的信息</span><br>master_port:6379<br>master_link_status:up<br>master_last_io_seconds_ago:8<br>master_sync_in_progress:0<br>slave_repl_offset:14<br>slave_priority:100<br>slave_read_only:1<br>connected_slaves:0<br>master_replid:acec4d2172706ac4d75dc58669cda8a2d7a8bfbd<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:14<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:14<br><br><br><span class="hljs-comment"># 在主机中查看</span><br>[root@iZbp17e1mp4a0cgbw1358xZ bin]<span class="hljs-comment"># redis-cli -p 6379</span><br>127.0.0.1:6379&gt; info replication<br><span class="hljs-comment"># Replication</span><br>role:master<br>connected_slaves:1<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=126,lag=1<br>master_replid:acec4d2172706ac4d75dc58669cda8a2d7a8bfbd<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:126<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:126<br></code></pre></td></tr></table></figure>

<p>如果两个都配置完了，就会有两个从机的</p>
<p>真实的主从配置应该在配置文件中配置，<strong>这样的话是永久的，使用命令是暂时的</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200513215654634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="3-细节："><a href="#3-细节：" class="headerlink" title="3.细节："></a>3.细节：</h4><p><strong>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存</strong></p>
<p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，如果主机回来，从机依旧可以直接获取到主机写的信息</p>
<p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机!<strong>只要变为从机，立马就会从主机中获取值</strong></p>
<h4 id="4-使用规则："><a href="#4-使用规则：" class="headerlink" title="4.使用规则："></a>4.使用规则：</h4><ol>
<li><p>从机只能读，不能写，主机可读可写但是多用于写。</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash"> 127.0.0.1:6381&gt; <span class="hljs-built_in">set</span> name sakura <span class="hljs-comment"># 从机6381写入失败</span><br>(error) READONLY You can<span class="hljs-string">&#x27;t write against a read only replica.</span><br><span class="hljs-string"></span><br><span class="hljs-string">127.0.0.1:6380&gt; set name sakura # 从机6380写入失败</span><br><span class="hljs-string">(error) READONLY You can&#x27;</span>t write against a <span class="hljs-built_in">read</span> only replica.<br><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name sakura<br>OK<br>127.0.0.1:6379&gt; get name<br><span class="hljs-string">&quot;sakura&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p>
</li>
<li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p>
</li>
<li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p>
<ul>
<li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li>
<li>使用哨兵模式（自动选举）</li>
</ul>
</li>
</ol>
<blockquote>
<p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p>
</blockquote>
<p>如果主机断开了连接，我们可以使用<font color=yellow>SLAVEOF no one</font>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！</p>
<h4 id="5-复制原理"><a href="#5-复制原理" class="headerlink" title="5.复制原理:"></a>5.复制原理:</h4><p><strong>Slave启动成功连接到master后会发送一个sync命令(同步命令)</strong><br>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<font color=yellow>master将传送整个数据文件到slave，并完成一次完全同步。</font></p>
<p><font color=yellow>全量复制︰而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</font></p>
<p><font color=yellow>增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步。</font></p>
<p>但是只要是重新连接master，一次完全同步(全量复制）将被自动执行。我们的数据一定可以在从机中看到</p>
<h4 id="6-层层链路："><a href="#6-层层链路：" class="headerlink" title="6. 层层链路："></a>6. 层层链路：</h4><p>上一个M连接下一个S，这时候也可以完成我们的主从复制</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1d90bc1c207338cae0e414051f4bfe8e.png" alt="image-20201105122218386"></p>
<p><strong>如果没有老大，能不能选择一个老大出来呢，手动</strong></p>
<p><font color=red>谋朝篡位:</font></p>
<p><font color=yellow>salveof no one</font>,如果主机断开了连接，可以使用这个命令来让自己成为主节点，其他的结点就可以手动连接到最新的这个主节点</p>
<p>如果这个时候老大修复了，那就只能重新连接（即变为主机的从机依然还是主机）</p>
<h2 id="11-Redis哨兵模式（自动选取老大的模式）"><a href="#11-Redis哨兵模式（自动选取老大的模式）" class="headerlink" title="11.Redis哨兵模式（自动选取老大的模式）"></a>11.Redis哨兵模式（自动选取老大的模式）</h2><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务器不可用。这不是一种推荐方式，更多时候，我们优先考虑哨兵模式，<strong>Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题。</strong>**</p>
<p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将库转换为主库。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，<strong>哨兵是一个独立的进程</strong>，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong><img src="https://img-blog.csdnimg.cn/img_convert/c1ba98cbc27441ca87553f823873fac2.png" alt="image-20201105125043998"></p>
<p><strong>哨兵有两个作用</strong></p>
<ol>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让他们切换主机</li>
</ol>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。<img src="https://img-blog.csdnimg.cn/img_convert/3cad6f6728ec2c403ae6d074bbc51823.png" alt="image-20201105125638471"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>我们目前的状态是一主二从</p>
<ol>
<li>配置哨兵配置文件<font color=yellow>sentinel.conf</font>（自己新建的文件，名字必须是这个）</li>
</ol>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sentinel monitor 被监控的名称 host port 1</span><br>sentinel monitor myredis 127.0.0.1 6379 1<br><span class="hljs-comment"># 1是有多少哨兵认为挂了，master才是真的挂了</span><br></code></pre></td></tr></table></figure>

<p>后面的这个数字1代表主机挂了，slave投票看让谁来接替成为主机，票数最多的就会成为主机</p>
<ol>
<li>启动哨兵</li>
</ol>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">redis-sentinel ../etc/sentinal.conf<br><br>[root@iZbp17e1mp4a0cgbw1358xZ bin]<span class="hljs-comment"># redis-sentinel ../etc/sentinal.conf </span><br>20615:X 05 Nov 2020 13:05:15.181 <span class="hljs-comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br>20615:X 05 Nov 2020 13:05:15.181 <span class="hljs-comment"># Redis version=6.0.6, bits=64, commit=00000000, modified=0, pid=20615, just started</span><br>20615:X 05 Nov 2020 13:05:15.181 <span class="hljs-comment"># Configuration loaded</span><br>                _._                                                  <br>           _.-``__ <span class="hljs-string">&#x27;&#x27;</span>-._                                             <br>      _.-``    `.  `_.  <span class="hljs-string">&#x27;&#x27;</span>-._           Redis 6.0.6 (00000000/0) 64 bit<br>  .-`` .-```.  ```\/    _.,_ <span class="hljs-string">&#x27;&#x27;</span>-._                                   <br> (    <span class="hljs-string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span><br><span class="hljs-string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="hljs-string">&#x27;|     Port: 26379</span><br><span class="hljs-string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 20615<br>  `-._    `-._  `-./  _.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br> |`-._`-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>_.-<span class="hljs-string">&#x27;|                                  </span><br><span class="hljs-string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="hljs-string">&#x27;    |           http://redis.io        </span><br><span class="hljs-string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br> |`-._`-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>_.-<span class="hljs-string">&#x27;|                                  </span><br><span class="hljs-string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="hljs-string">&#x27;    |                                  </span><br><span class="hljs-string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br>      `-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                       <br>          `-._        _.-<span class="hljs-string">&#x27;                                           </span><br><span class="hljs-string">              `-.__.-&#x27;</span>                                               <br><br>20615:X 05 Nov 2020 13:05:15.182 <span class="hljs-comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br>20615:X 05 Nov 2020 13:05:15.185 <span class="hljs-comment"># Sentinel ID is ee900e749cf585634b3bc2860471d28dcd1ec109</span><br>20615:X 05 Nov 2020 13:05:15.185 <span class="hljs-comment"># +monitor master myredis 127.0.0.1 6379 quorum 1</span><br>20615:X 05 Nov 2020 13:05:15.186 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379<br>20615:X 05 Nov 2020 13:05:15.188 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379<br></code></pre></td></tr></table></figure>

<p>如果master结点断开了，这个时候就会从从机中随机选择一个服务器,这里面有一个<strong>投票算法</strong></p>
<p><strong>哨兵日志</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/09a06ab2d386b69dc6e093379c3dfbbe.png" alt="image-20201105130939012"></p>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式:"></a>哨兵模式:</h4><p>如果<strong>主机此时回来了，只能归并到新的主机下，当做从机</strong>，这就是哨兵模式的规则！</p>
<p><strong>优点：</strong></p>
<ol>
<li>哨兵模式，基于主从复制模式，所有主从配置的优点它都有</li>
<li>主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动，更加健壮</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置是非常麻烦的，里面有很</li>
</ol>
<h4 id="哨兵模式全部配置："><a href="#哨兵模式全部配置：" class="headerlink" title="哨兵模式全部配置："></a>哨兵模式全部配置：</h4><figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Example sentinel.conf</span><br> <br><span class="hljs-comment"># 哨兵sentinel实例运行的端口 默认26379   如果有多集群哨兵的话,就需要区分</span><br>port 26379<br> <br><span class="hljs-comment"># 哨兵sentinel的工作目录</span><br><span class="hljs-built_in">dir</span> /tmp<br> <br><span class="hljs-comment"># 哨兵sentinel监控的redis主节点的 ip port </span><br><span class="hljs-comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span><br><span class="hljs-comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span><br><span class="hljs-comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br>sentinel monitor mymaster 127.0.0.1 6379 1<br> <br><span class="hljs-comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="hljs-comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="hljs-comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<br> <br> <br><span class="hljs-comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="hljs-comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel down-after-milliseconds mymaster 30000<br> <br><span class="hljs-comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span><br>这个数字越小，完成failover所需的时间就越长，<br>但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。<br>可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。<br><span class="hljs-comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br>sentinel parallel-syncs mymaster 1<br> <br> <br><span class="hljs-comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span><br><span class="hljs-comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="hljs-comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="hljs-comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span><br><span class="hljs-comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="hljs-comment"># 默认三分钟</span><br><span class="hljs-comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel failover-timeout mymaster 180000<br> <br><span class="hljs-comment"># SCRIPTS EXECUTION</span><br> <br><span class="hljs-comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="hljs-comment">#对于脚本的运行结果有以下规则：</span><br><span class="hljs-comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="hljs-comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="hljs-comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="hljs-comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br> <br><span class="hljs-comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span><br><span class="hljs-comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span><br><span class="hljs-comment">#一个是事件的类型，</span><br><span class="hljs-comment">#一个是事件的描述。</span><br><span class="hljs-comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="hljs-comment">#通知脚本</span><br><span class="hljs-comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br>  sentinel notification-script mymaster /var/redis/notify.sh<br> <br><span class="hljs-comment"># 客户端重新配置主节点参数脚本</span><br><span class="hljs-comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="hljs-comment"># 以下参数将会在调用脚本时传给脚本:</span><br><span class="hljs-comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="hljs-comment"># 目前&lt;state&gt;总是“failover”,</span><br><span class="hljs-comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span><br><span class="hljs-comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="hljs-comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="hljs-comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh<br></code></pre></td></tr></table></figure>

<h2 id="12-Redis缓存穿透与雪崩（面试高频，工作常用）"><a href="#12-Redis缓存穿透与雪崩（面试高频，工作常用）" class="headerlink" title="12.Redis缓存穿透与雪崩（面试高频，工作常用）"></a>12.Redis缓存穿透与雪崩（面试高频，工作常用）</h2><p>服务的高可用问题</p>
<p>不会详细分析解决方案的底层（专题）</p>
<p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/0a4034ed3249cfd5dcf1b4801c603ac3.png" alt="imag"></p>
<h4 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h4><p><strong>概念：</strong><br>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀!)，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><h4 id="1-布隆过滤器"><a href="#1-布隆过滤器" class="headerlink" title="1.布隆过滤器"></a><strong>1.布隆过滤器</strong></h4><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力﹔</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/711f719d7387385ef19084f732aa266e.png" alt="image-20201105132801112"></p>
<p><img src="https://img-blog.csdnimg.cn/20200513215824722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-缓存空对象"><a href="#2-缓存空对象" class="headerlink" title="2.缓存空对象"></a><strong>2.缓存空对象</strong></h4><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源;</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/14c9e14245bae4a3e49226c416376c8c.png" alt="image-20201105132900180"></p>
<p>但是这种方法会存在两个问题:<br>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键;<br>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h4 id="缓存击穿（查的太多，量大，缓存过期）"><a href="#缓存击穿（查的太多，量大，缓存过期）" class="headerlink" title="缓存击穿（查的太多，量大，缓存过期）"></a>缓存击穿（查的太多，量大，缓存过期）</h4><p>微博服务器宕机（60 60.1 0.1）</p>
<p><strong>概述：</strong><br>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。<br>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a><strong>解决方案:</strong></h4><h4 id="1-设置热点数据永不过期"><a href="#1-设置热点数据永不过期" class="headerlink" title="1.设置热点数据永不过期"></a>1.设置热点数据永不过期</h4><p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题</p>
<h4 id="2-加互斥锁"><a href="#2-加互斥锁" class="headerlink" title="2.加互斥锁"></a>2.加互斥锁</h4><p><strong>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务</strong>，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁考验很大</p>
<p>在访问key之前，采用<strong>SETNX（set if not exists）</strong>来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p><strong>概念:</strong><br>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis宕机<br>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，<strong>这批商品的缓存就都过期了。而对这批商品的访问查询</strong>，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于<strong>是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200513215850428.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</strong></p>
<h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><h4 id="1-Redis高可用"><a href="#1-Redis高可用" class="headerlink" title="1.Redis高可用"></a>1.Redis高可用</h4><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。(异地多活）</p>
<h4 id="2-限流降级（在SpringCloud中有）"><a href="#2-限流降级（在SpringCloud中有）" class="headerlink" title="2.限流降级（在SpringCloud中有）"></a>2.限流降级（在SpringCloud中有）</h4><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<h4 id="3-数据预热"><a href="#3-数据预热" class="headerlink" title="3.数据预热"></a>3.数据预热</h4><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。机只能有唯一的服务器ID   3.每个主机可以有多个从机</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title>对于JUC你知道多少</title>
    <url>/2022/10/04/JUC/</url>
    <content><![CDATA[<h2 id="java并发问题—JUC问题"><a href="#java并发问题—JUC问题" class="headerlink" title="java并发问题—JUC问题"></a>java并发问题—JUC问题</h2><h2 id="写在前面：深入理解CAS"><a href="#写在前面：深入理解CAS" class="headerlink" title="写在前面：深入理解CAS"></a>写在前面：深入理解CAS</h2><h2 id="1-java使用CAS之前"><a href="#1-java使用CAS之前" class="headerlink" title="1.java使用CAS之前:"></a>1.java使用CAS之前:</h2><p>在JDK5之前Java语言是&#x3D;&#x3D;靠synchronized关键字保证同步的&#x3D;&#x3D;，这会导致有锁，&#x3D;&#x3D;锁机制存在以下问题&#x3D;&#x3D;：</p>
<ul>
<li><strong>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题</strong></li>
<li><strong>一个线程持有锁会导致其他所有需要此锁的线程挂起</strong></li>
<li><strong>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险</strong></li>
</ul>
<p><strong>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</strong></p>
<p><strong>独占锁是一个悲观锁，synchronized就是一种独占锁，会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一种更加有效的锁就是乐观锁，CAS就是一种乐观锁（synchronized是一种悲观锁,CAS是一种乐观锁）</strong></p>
<h2 id="2-CAS是什么"><a href="#2-CAS是什么" class="headerlink" title="2.CAS是什么:"></a>2.CAS是什么:</h2><p>CAS操作包含三个操作数—— <strong>内存位置的值（V）、预期原值（A）和新值（B）</strong>&#x3D;&#x3D;如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。&#x3D;&#x3D;CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可”</p>
<p>CAS是一种有名的<strong>无锁算法</strong>。无锁编程，即不适用锁的情况下实现多线程之间的变量同步，也就是在没有现成被阻塞的情况下实现变量的同步。</p>
<p><strong>总结如下：</strong></p>
<ul>
<li><strong>CAS（Compare And Swap）比较并替换，是线程并发运行时用到的一种技术</strong></li>
<li><strong>CAS是原子操作，保证并发安全，而不能保证并发同步</strong></li>
<li><strong>CAS是CPU的一个指令（需要JNI调用Native方法，才能调用CPU的指令）</strong></li>
<li><strong>CAS是非阻塞的、轻量级的乐观锁</strong></li>
</ul>
<h2 id="3-为什么说CAS是乐观锁"><a href="#3-为什么说CAS是乐观锁" class="headerlink" title="3.为什么说CAS是乐观锁"></a>3.为什么说CAS是乐观锁</h2><p>乐观锁，严格来说并不是锁，通过原子性来保证数据的同步，比如说数据库的乐观锁，通过版本控制来实现，所以CAS不会保证线程同步。&#x3D;&#x3D;乐观的认为在数据更新期间没有其他线程影响。&#x3D;&#x3D;</p>
<h2 id="4-CAS原理"><a href="#4-CAS原理" class="headerlink" title="4.CAS原理"></a>4.CAS原理</h2><p><strong>CAS（Compare And Swap）就是将内存值更新为需要的值，但是有个条件，内存值必须与期望值相同。举个例子，内存值V、期望值A、更新值B，当V &#x3D;&#x3D; A的时候将V更新为B。</strong></p>
<h2 id="5-CAS应用"><a href="#5-CAS应用" class="headerlink" title="5.CAS应用"></a>5.CAS应用</h2><p>由于CAS是CPU指令，我们只能通过JNI与操作系统交互，关于CAS的方法都在sun.misc包下Unsafe的类里，java.util.concurrent.atomic包下的原子类等通过CAS来实现原子操作</p>
<h2 id="6-使用乐观锁还是悲观锁"><a href="#6-使用乐观锁还是悲观锁" class="headerlink" title="6.使用乐观锁还是悲观锁"></a>6.使用乐观锁还是悲观锁</h2><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像&#x3D;&#x3D;乐观锁适用于写比较少的情况下（多读场景）&#x3D;&#x3D;，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的吞吐量。但如果是多写的情况，一般会经常发生冲突，这就会导致CAS算法会不断的进行retry，这样反倒是降低了性能，所以&#x3D;&#x3D;一般多写的场景下用悲观锁就比较合适。&#x3D;&#x3D;</p>
<h2 id="7-CAS优缺点"><a href="#7-CAS优缺点" class="headerlink" title="7.CAS优缺点"></a>7.CAS优缺点</h2><ul>
<li>&#x3D;&#x3D;优点&#x3D;&#x3D;</li>
</ul>
<blockquote>
<p><strong>非阻塞的轻量级的乐观锁，通过CPU指令实现，在资源竞争不激烈的情况下性能高，相比synchronized重量锁，synchronized会进行比较复杂的加锁、解锁和唤醒操作。</strong></p>
</blockquote>
<ul>
<li>&#x3D;&#x3D;缺点&#x3D;&#x3D;</li>
</ul>
<blockquote>
<p>ABA问题： 线程C、D；线程D将A修改为B后又修改为A，此时C线程以为A没有改变过，java的原子类AtomicStampedReference，通过<strong>控制变量值的版本号</strong>来保证CAS的正确性。具体解决思路就是在变量前追加上版本号，每次变量更新的时候把版本号加一，那么A - B - A就会变成1A - 2B - 3A</p>
</blockquote>
<blockquote>
<p><strong>自旋时间过长，消耗CPU资源，如果资源竞争激烈，多线程自旋长时间消耗资源</strong></p>
</blockquote>
<h2 id="一-创建和运行线程"><a href="#一-创建和运行线程" class="headerlink" title="一.创建和运行线程"></a>一.创建和运行线程</h2><h3 id="方法一-直接使用Thread"><a href="#方法一-直接使用Thread" class="headerlink" title="方法一:直接使用Thread"></a>方法一:直接使用Thread</h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">Thread  thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;1&quot;</span>)&#123;  <span class="hljs-comment">//创建一个线程,并且1为该线程的名字</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//线程中要执行的代码</span><br>        System.out.println(<span class="hljs-string">&quot;线程运行...&quot;</span>);<br>    &#125;<br>&#125;;<br>     System.out.println(<span class="hljs-string">&quot;main线程运行...&quot;</span>);<br>     thread.start();  <span class="hljs-comment">//让线程开始运行/启动</span><br><br></code></pre></td></tr></table></figure>

<h3 id="方法二-使用Runnable配合Thread"><a href="#方法二-使用Runnable配合Thread" class="headerlink" title="方法二:使用Runnable配合Thread"></a>方法二:使用Runnable配合Thread</h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">Runnable runnable=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnalbe</span>()&#123;  <span class="hljs-comment">//Runnable为接口类型,其中只有一个抽象类为run要实现</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;线程运行...&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//因为Runnable接口中只有一个抽象方法,故可以用lambad简化</span><br>Runnable runnable=()-&gt;System.out.println(<span class="hljs-string">&quot;线程运行&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;main线程运行&quot;</span>);<br>    Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable,<span class="hljs-string">&quot;1&quot;</span>);  <span class="hljs-comment">//运行run方法,并且线程名字为1</span><br>    thread.start();<br><span class="hljs-comment">//这样的目的是为了将创建线程和任务分离开,使得他们更加灵活</span><br></code></pre></td></tr></table></figure>

<h3 id="方法三-FutureTask配合Thread"><a href="#方法三-FutureTask配合Thread" class="headerlink" title="方法三:FutureTask配合Thread"></a>方法三:FutureTask配合Thread</h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">FutureTask&lt;Integer&gt; futureTask=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;()&#123;  <br>             <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程运行....&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>            &#125;<br>&#125;);<br>    Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>     thread.start();<br>     futureTask.get();  <span class="hljs-comment">//获取线程任务的返回值</span><br><span class="hljs-comment">//FutureTask&lt;V&gt;类实现了RunnableFuture&lt;V&gt;接口,然后这个接口类RunnableFuture&lt;V&gt;继承于Runnable, Future&lt;V&gt; </span><br></code></pre></td></tr></table></figure>

<h2 id="二-查看和杀死线程运行"><a href="#二-查看和杀死线程运行" class="headerlink" title="二.查看和杀死线程运行"></a>二.查看和杀死线程运行</h2><h3 id="Windows下："><a href="#Windows下：" class="headerlink" title="Windows下："></a>Windows下：</h3><ul>
<li>任务管理器可以查看进程和线程数,也可以杀死进行和线程</li>
<li>控制台中:tasklist &#x3D;&#x3D;查看所有进程&#x3D;&#x3D;  taskkill &#x3D;&#x3D;杀死进程&#x3D;&#x3D; (可以过滤)</li>
</ul>
<h3 id="Linux下"><a href="#Linux下" class="headerlink" title="Linux下:"></a>Linux下:</h3><ul>
<li>ps -fe 查看所有进程</li>
<li>ps -fT -p<PID>  查看某个进程(PID)的所有线程状态</li>
<li>kill   杀死进程</li>
<li>top按大写H切换是否显示线程</li>
<li>top -H -p<PID>  查看某个进程(PID)的所有线程状态</li>
</ul>
<h3 id="java下"><a href="#java下" class="headerlink" title="java下:"></a>java下:</h3><ul>
<li>jps命令查看所有java进程(控制台上)</li>
<li>jstack<PID>查看某个java进程(PID)的所有线程状态</li>
<li>jconsole来查看某个java进程中线程的运行情况(&#x3D;&#x3D;在win+R键内填入jconsole&#x3D;&#x3D;)</li>
</ul>
<h2 id="三-常用方法"><a href="#三-常用方法" class="headerlink" title="三.常用方法"></a>三.常用方法</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>功能说明</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td>启动一个新线程,在新的线程运行run方法中的代码</td>
<td>start方法只是让线程进入就绪,里面代码不一定立刻运行(CPU的时间片还没有分给它).每个线程对象的start方法只能调用一次,如果调用了多次会报错</td>
</tr>
<tr>
<td>run()</td>
<td>新线程启动会调用的方法</td>
<td>如果在构造Thread对象时传递了Runnable参数,则线程启动后会调用Runnable中的run方法,否则默认不执行任何操作,但是可以创建Thread的子类对象,来覆盖默认行为</td>
</tr>
<tr>
<td>join()</td>
<td>等待线程运行结束</td>
<td>一直等待直到线程运行结束</td>
</tr>
<tr>
<td>join(long n)</td>
<td>等待线程运行结束,最多等待n毫秒</td>
<td></td>
</tr>
<tr>
<td>getid()</td>
<td>获取线程长整型的id</td>
<td>id唯一</td>
</tr>
<tr>
<td>getName()</td>
<td>获取线程名</td>
<td></td>
</tr>
<tr>
<td>setName(String)</td>
<td>修改线程名</td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td>获取线程优先级</td>
<td></td>
</tr>
<tr>
<td>setPriority(int)</td>
<td>修改线程优先级</td>
<td>java中规定线程优先级为1-10的整数,较大的优先级能较大几率被CPU所调度</td>
</tr>
<tr>
<td>interrupt()</td>
<td>打断线程</td>
<td>如果被打断线程正在sleep,wait,join会导致打断的线程抛出异常,并清除打断标记,如果打断的正在运行的线程,则会设置打断标记,park的线程被打断,也会设置打断标记</td>
</tr>
<tr>
<td>currentThread()</td>
<td>获取当前正在执行的线程</td>
<td></td>
</tr>
<tr>
<td>isInterrupted()</td>
<td>判断是否被打断</td>
<td>不会清除打断标记</td>
</tr>
<tr>
<td>interrupted()</td>
<td>判断当前线程是否被打断</td>
<td>会清除打断标记</td>
</tr>
<tr>
<td>yield()</td>
<td>提示线程调度器让出当前线程对CPU的使用</td>
<td>主要是为了测试和调试</td>
</tr>
</tbody></table>
<h2 id="四-常见方法的使用"><a href="#四-常见方法的使用" class="headerlink" title="四.常见方法的使用"></a>四.常见方法的使用</h2><h3 id="1-run-方法和start-方法的比较"><a href="#1-run-方法和start-方法的比较" class="headerlink" title="1.run()方法和start()方法的比较"></a>1.run()方法和start()方法的比较</h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>  <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;线程运行...&quot;</span>);<br>    &#125;<br>&#125;; <br>    thread.run();   <span class="hljs-comment">//用run方法执行的线程依然是主线程(main方法)执行</span><br>    thread.getState();  <span class="hljs-comment">//在还没有调用start方法之前,线程状态为NEW</span><br>    thread.start();   <span class="hljs-comment">//start方法才可以对该创建的线程的调度(运行)</span><br>    thread.getState();   <span class="hljs-comment">//在调用之后,线程状态为Runnable(就绪态,一旦获取了CPU的调度,就立即运行)</span><br></code></pre></td></tr></table></figure>

<h3 id="2-sleep的打断"><a href="#2-sleep的打断" class="headerlink" title="2.sleep的打断"></a>2.sleep的打断</h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">  Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>               System.out.println(<span class="hljs-string">&quot;enter sleep...&quot;</span>);<br>           <span class="hljs-keyword">try</span> &#123;<br>                   Thread.sleep(<span class="hljs-number">2000</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   System.out.println(<span class="hljs-string">&quot;线程被打断了...&quot;</span>);<br>                   e.printStackTrace();<br>               &#125;<br>    &#125;<br>&#125;;<br>      thread.start();<br>      Thread.sleep(<span class="hljs-number">1000</span>);<br>      System.out.println(<span class="hljs-string">&quot;interrupt...&quot;</span>);<br>      thread.interrupt();  <span class="hljs-comment">//打断睡眠的线程</span><br><span class="hljs-comment">//使用interrupt会使正在睡眠的线程被打断(唤醒使之运行),但是会抛出异常InterruptedException</span><br><span class="hljs-comment">//可以使用TimeUite(api里面有众多时间单位)来代替sleep方法</span><br><span class="hljs-comment">//使用sleep会让当前线程从Running(运行态)进入Timed Waiting状态(阻塞态)</span><br></code></pre></td></tr></table></figure>

<h3 id="3-sleep和yield的说明"><a href="#3-sleep和yield的说明" class="headerlink" title="3.sleep和yield的说明"></a>3.sleep和yield的说明</h3><h3 id="sleep："><a href="#sleep：" class="headerlink" title="sleep："></a>sleep：</h3><ul>
<li>调用sleep会让当前线程从运行态直接变为阻塞态</li>
<li>其他线程可以用interrupt方法打断正在睡眠的线程,但是此时sleep的线程会抛出异常</li>
<li>睡眠结束后的线程未必会立即得到执行(就绪态)</li>
<li>使用TimeUite的sleep代替Thread的sleep会有更好的可读性</li>
</ul>
<h3 id="yield："><a href="#yield：" class="headerlink" title="yield："></a>yield：</h3><ul>
<li>调用yield会让当前线程从运行态进行就绪态,然后调度执行其他线程</li>
</ul>
<h3 id="4-防止CPU占用100-的案例"><a href="#4-防止CPU占用100-的案例" class="headerlink" title="4.防止CPU占用100%的案例"></a>4.防止CPU占用100%的案例</h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);  <span class="hljs-comment">//这里sleep中的值可以很小</span><br>    &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//当不加Thread.sleep(50)时,此时线程的CPU的占比接近于100%,即没有其他的线程可以调度,这是不允许出现的状况</span><br><span class="hljs-comment">//防止CPU空转,当了Thread.sleep(50)后,CPU占比将只占到3%或者4%左右</span><br><span class="hljs-comment">//可以用wait或者条件变量达到类似的效果,不同的是,这2中都需要加锁,还都需要相应的唤醒操作(一般用于进行同步场景),而sleep适用于无需锁同步的场景</span><br></code></pre></td></tr></table></figure>

<h3 id="5-join的应用-一般用于同步问题-并且CPU为单核时才可以"><a href="#5-join的应用-一般用于同步问题-并且CPU为单核时才可以" class="headerlink" title="5.join的应用(一般用于同步问题,并且CPU为单核时才可以)"></a>5.join的应用(一般用于同步问题,并且CPU为单核时才可以)</h3> <figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">   <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;                                                  <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;<br>Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;                       Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>      Thread.sleep(<span class="hljs-number">10</span>);                                        Thread.sleep(<span class="hljs-number">10</span>);<br>            r=<span class="hljs-number">10</span>;                                                 r=<span class="hljs-number">10</span>;    <br>&#125;,<span class="hljs-string">&quot;1&quot;</span>);                                                       &#125;,<span class="hljs-string">&quot;1&quot;</span>);<br> thread.start();                                          thread.start();  thread.join();<span class="hljs-comment">//让其他线程等待该线程完</span><br>System.out.println(r);                                   System.out.println(r);                                <br><span class="hljs-comment">//此时会输出r=0,因为主线程不会等待1线程运行完              输出为10</span><br></code></pre></td></tr></table></figure>

<h3 id="6-interrupt方法"><a href="#6-interrupt方法" class="headerlink" title="6.interrupt方法"></a>6.interrupt方法</h3><h3 id="情况一-当打断不正常运行的线程-比如sleep、wait和join状态-的时候-会清空打断状态-即isInterrupted-的输出值为true"><a href="#情况一-当打断不正常运行的线程-比如sleep、wait和join状态-的时候-会清空打断状态-即isInterrupted-的输出值为true" class="headerlink" title="情况一:当打断不正常运行的线程(比如sleep、wait和join状态)的时候,会清空打断状态,即isInterrupted()的输出值为true"></a>情况一:当打断不正常运行的线程(比如sleep、wait和join状态)的时候,会清空打断状态,即isInterrupted()的输出值为true</h3><h3 id="情况二-当打断正常运行的线程时-会清空打断状态-即isInterrupted-的输出值为true-而当此时正常线程没有运行然后打断-则isInterrupted-的输出值为flase"><a href="#情况二-当打断正常运行的线程时-会清空打断状态-即isInterrupted-的输出值为true-而当此时正常线程没有运行然后打断-则isInterrupted-的输出值为flase" class="headerlink" title="情况二:当打断正常运行的线程时,会清空打断状态,即isInterrupted()的输出值为true.而当此时正常线程没有运行然后打断,则isInterrupted()的输出值为flase"></a>情况二:当打断正常运行的线程时,会清空打断状态,即isInterrupted()的输出值为true.而当此时正常线程没有运行然后打断,则isInterrupted()的输出值为flase</h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">Thread thread= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    System.out.println(<span class="hljs-string">&quot;线程被打断&quot;</span>);<br>&#125;);<br>thread.start();<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>thread.interrupt();  <br><span class="hljs-comment">//此时打断线程thread后,会抛出异常InterruptedException------打断不正常运行的线程</span><br><br>Thread thread= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>             Boolean isterrupted=Thread.currentThread().isterrupt();<br>          <span class="hljs-keyword">if</span>(isterrupted)&#123;<br>                System.out.println(<span class="hljs-string">&quot;线程被打断&quot;</span>);<br>                  <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <br>    &#125;<br><br>&#125;);<br>thread.start();<br>Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//让thread线程运行</span><br>thread.interrupt();  <br><br></code></pre></td></tr></table></figure>

<h3 id="情况三-两阶段终止"><a href="#情况三-两阶段终止" class="headerlink" title="情况三:两阶段终止"></a>情况三:两阶段终止</h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span>&#123;<br>    <span class="hljs-keyword">private</span>  Thread  monitor;  <span class="hljs-comment">//监控线程 </span><br>    <span class="hljs-comment">//启动线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        monitor=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> Thread.currentThread().isInterrupted();<br>                <span class="hljs-keyword">if</span>(interrupted)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                   <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    System.out.println(<span class="hljs-string">&quot;执行监控记录...&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                     monitor.interrupt();  <span class="hljs-comment">//interrupt打断sleep会清除了打断标记,故要加上打断标记,让循环结束</span><br>            &#125;<br>        &#125;);<br> &#125;  <br>  <span class="hljs-comment">//打断线程</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>      monitor.interrupt();  <br>  &#125;                    <br>&#125;<br>             TwoPhaseTermination  t1=<span class="hljs-keyword">new</span>  <span class="hljs-title class_">TwoPhaseTermination</span>();<br>                           t1.start();<br>                           Thread.sleep(<span class="hljs-number">3.5</span>);<br>                           t1.stop();<br></code></pre></td></tr></table></figure>

<h3 id="7-打断park方法"><a href="#7-打断park方法" class="headerlink" title="7.打断park方法"></a>7.打断park方法</h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">Thread  thread=<span class="hljs-keyword">new</span>  <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>     System.out.println(<span class="hljs-string">&quot;测试park方法&quot;</span>);<br>    LockSupport.park();<br>    System.out.println(Thread.currentThread().isInterrupted());  <br>&#125;);<br> thread.start();<br> Thread.sleep(<span class="hljs-number">1</span>);<br> thread.interrupt();   <span class="hljs-comment">//调用interrupt方法会打断park()方法,并且只要打断标记为true时,park将会失效</span><br><br></code></pre></td></tr></table></figure>

<h3 id="8-守护线程"><a href="#8-守护线程" class="headerlink" title="8.守护线程"></a>8.守护线程</h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">  Thread  thread=<span class="hljs-keyword">new</span>  <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>               System.out.println(<span class="hljs-string">&quot;守护线程来了...&quot;</span>);<br>               <span class="hljs-keyword">try</span> &#123;<br>                   Thread.sleep(<span class="hljs-number">2000</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>               <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted())&#123;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>       &#125;);<br>       thread.setDaemon(<span class="hljs-literal">true</span>);  <span class="hljs-comment">//设置为守护线程</span><br>       thread.start();<br>       System.out.println(<span class="hljs-string">&quot;主线程结束了...&quot;</span>);<br><span class="hljs-comment">//守护线程:当其他线程结束时,会被强制结束</span><br><span class="hljs-comment">//几种典型的守护线程: 垃圾回收线程就是一种守护线程  </span><br>                 <span class="hljs-comment">// Tomcat中的Acceptot和Poller线程都是守护线程,所以当Tomcat收到了shutdown命令后,不会等待它们处理完当前                      请求  </span><br></code></pre></td></tr></table></figure>

<h3 id="9-java中线程的六种状态"><a href="#9-java中线程的六种状态" class="headerlink" title="9.java中线程的六种状态"></a>9.java中线程的六种状态</h3><ul>
<li><p><strong>New: 线程刚被创建,但是还有调用start方法()</strong></p>
</li>
<li><p><strong>Runnable: 当调用了start()方法之后,注意,Java API层面的Runnable状态包括了操作系统层面的就绪态,运行态和阻塞态</strong></p>
</li>
<li><p><strong>Blocked: 阻塞态(被别人’抢锁了’)</strong></p>
</li>
<li><p><strong>Waiting: 阻塞态(没有时限的等待，如thread.join()  但是thread线程为死循环)</strong></p>
</li>
<li><p><strong>Time_Waiting: 阻塞态(有时限的等待，如sleep(2000))</strong></p>
</li>
<li><p><strong>Terminated: 当线程代码运行结束</strong></p>
</li>
</ul>
<h2 id="五-共享模型之管程"><a href="#五-共享模型之管程" class="headerlink" title="五.共享模型之管程"></a>五.共享模型之管程</h2><p><strong>为了避免临界区的竞态条件发生,有多种手段可以达到目的</strong></p>
<ul>
<li><strong>阻塞式的解决方案:synchronized,Lock</strong></li>
<li><strong>非阻塞式的解决方法:原子变量</strong></li>
</ul>
<h3 id="5-1-synchronized的基本使用（面向过程）"><a href="#5-1-synchronized的基本使用（面向过程）" class="headerlink" title="5.1.synchronized的基本使用（面向过程）"></a>5.1.synchronized的基本使用（面向过程）</h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>  <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span>   Object lock=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>Thread  t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>       synchrionized(lock)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5000</span>;i++)&#123;<br>          n++;<br>         &#125;  <br>     &#125;<br>&#125;);<br>Thread  t2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>      synchrionized(lock)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5000</span>;i++)&#123;<br>          n--;<br>      &#125;<br>    &#125;<br>&#125;);<br>    t1.start();<br>    t2.start();<br>    t1.join();   <span class="hljs-comment">//两个join操作是为了保证并发的执行</span><br>    t2.join();<br>    System.out.println(n);<br><span class="hljs-comment">//synchronized锁使用的语法  被synchronized加锁的代码,只能有一个线程进入(因为加锁了),其他线程想进入会变为阻塞态,当sychronized加锁的代码执行完之后,才会将其他线程(想进入代码区的)唤醒</span><br> 语法: <span class="hljs-keyword">synchronized</span>(对象)&#123;<br>     <span class="hljs-comment">// 代码执行区</span><br>  &#125;<br><br><span class="hljs-comment">//如果想对同一临界区进行保护,用得必须是同一个对象,如以上操作是对临界区n的值进行保护的,如果用的是synchronized(obj1)和synchronized(obj2)的话,则对临界区的访问是不一样的,加synchronized锁的第一步是获取锁,如果没有获取锁则线程会处于blocked</span><br><br><span class="hljs-comment">//所以对于上述操作,如果其中一个线程没有加synchronized锁的话,也不会得到正确的结果,因为其中一个线程不会处于阻塞状态,也会影响到另外一个线程的进行(值写入寄存器)</span><br><br><span class="hljs-comment">//synchronized实际是用对象锁保证了临界区内代码的原子性</span><br></code></pre></td></tr></table></figure>

<h3 id="5-2-synchronized的改造-面向对象"><a href="#5-2-synchronized的改造-面向对象" class="headerlink" title="5.2.synchronized的改造(面向对象)"></a><strong>5.2.synchronized的改造(面向对象)</strong></h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">synchronized</span>锁_面向对象 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>;i++)&#123;<br>                room.add();<br>            &#125;<br><br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">5000</span>;i++)&#123;<br>                room.desc();;<br>            &#125;<br>        &#125;);<br>        thread.start();<br>        thread1.start();<br>        System.out.println(room.result());<br>    &#125;<br><br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//加操作</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>         <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>             count++;<br>         &#125;<br>    &#125;<br>    <span class="hljs-comment">//减操作</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">desc</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>            count--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//获取结果</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-type">int</span> <span class="hljs-title function_">result</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-3-synchronized加在方法上"><a href="#5-3-synchronized加在方法上" class="headerlink" title="5.3.synchronized加在方法上"></a><strong>5.3.synchronized加在方法上</strong></h3><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;&#125;--&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>        <br>    &#125;<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;&#125;--&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(Test.class)&#123;<br>    &#125;<br>   &#125;<br>&#125;<br><span class="hljs-comment">//当锁的对象为类对象时,这个时候创建Test t1=new Test();  Test t2=new Test()两个对象 不会影响加锁的情况(视为同一个对象)</span><br></code></pre></td></tr></table></figure>

<p><strong>用final和private修饰方法是对方法保护一种措施</strong></p>
<h3 id="5-4-常见的线程安全类"><a href="#5-4-常见的线程安全类" class="headerlink" title="5.4.常见的线程安全类"></a>5.4.常见的线程安全类</h3><ul>
<li>String（本质是不可变的,即只能读不能改,并且为final修饰,不会因为子类的问题导致String线程不安全）</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable（本质是通过synchronized来实现的）</li>
<li>java.util.concurrent包下的类</li>
</ul>
<p><strong>这里说它们是线程安全的是指,多个线程调用它们同一个实例的某个方法时,是线程安全的.也可以理解为它们的每个方法是原子的,但是当它们的方法组合来用时,可能就是线程不安全的</strong></p>
<h3 id="5-5-Monitor-操作系统提供的监控或者管程-概念"><a href="#5-5-Monitor-操作系统提供的监控或者管程-概念" class="headerlink" title="5.5.Monitor(操作系统提供的监控或者管程)概念"></a>5.5.Monitor(操作系统提供的监控或者管程)概念</h3><h3 id="5-6-对象头"><a href="#5-6-对象头" class="headerlink" title="5.6.对象头"></a>5.6.对象头</h3><table>
<thead>
<tr>
<th>普通对象</th>
<th>Objet Header(64 bit)</th>
</tr>
</thead>
<tbody><tr>
<td>Mark  Word(32 bits)</td>
<td>Klass  Word(32 bit)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>数组对象</th>
<th>Object Header(96bits)</th>
</tr>
</thead>
<tbody><tr>
<td>Mark Word(32 bit)</td>
<td>Klass Word(32bit)               array length(32 bits)</td>
</tr>
</tbody></table>
<h3 id="5-7-其中Mark-Word的结构为-（存储hashcode-分代信息-锁标记位和GC标记）"><a href="#5-7-其中Mark-Word的结构为-（存储hashcode-分代信息-锁标记位和GC标记）" class="headerlink" title="5.7.其中Mark Word的结构为:（存储hashcode,分代信息,锁标记位和GC标记）"></a>5.7.其中Mark Word的结构为:（存储hashcode,分代信息,锁标记位和GC标记）</h3><table>
<thead>
<tr>
<th>Mark Word(32bit)</th>
<th>State</th>
</tr>
</thead>
<tbody><tr>
<td>hashcode:25    | age:4 | biased_lock:0 | 01（无锁）</td>
<td>Normal</td>
</tr>
<tr>
<td>thread:23 | epoch:2 | age:4 | biased_lock:1 | 01（无锁）</td>
<td>Biased</td>
</tr>
<tr>
<td>ptr_to_lock_record:30                                  | 00（轻量级锁）</td>
<td>Lightweight  Locked</td>
</tr>
<tr>
<td>ptr_to_heavyweight_monitor:30         | 10（重量级锁）</td>
<td>Heavyweigh Locked</td>
</tr>
<tr>
<td>| 11（标记为GC清理）</td>
<td>Marked for GC</td>
</tr>
</tbody></table>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220918111058785.png" alt="image-20220918111058785"></p>
<ul>
<li>刚开始Monitor中Owner为null</li>
<li>当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2,Monitor中只能有一个Owner</li>
<li>在Thread-2上锁的过程中,如果Thread-3,Thread-4,Thread-5也来执行synchronized(obj),就会进入EntryList  执行状态为Blocked</li>
<li>Thread-2执行完同步代码块的内容,然后唤醒EntryList中等待的线程来竞争锁,竞争的时候是非公平的</li>
<li>图中WaitSet中的Thread-0,Thread-1是之前获得过锁,但是条件不满足进入了Waiting状态的线程,后面讲wait-notify时会分析</li>
</ul>
<p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220918112123384.png" alt="image-20220918112123384"></p>
<h3 id="5-8-每个obj类关联一个Monitor-上图为Monitor的执行原理"><a href="#5-8-每个obj类关联一个Monitor-上图为Monitor的执行原理" class="headerlink" title="5.8.每个obj类关联一个Monitor           上图为Monitor的执行原理"></a>5.8.每个obj类关联一个Monitor           上图为Monitor的执行原理</h3><h3 id="六-synchronized原理进阶"><a href="#六-synchronized原理进阶" class="headerlink" title="六.synchronized原理进阶"></a>六.synchronized原理进阶</h3><h3 id="6-1-轻量级锁"><a href="#6-1-轻量级锁" class="headerlink" title="6.1.轻量级锁"></a>6.1.轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程访问,但是多线程访问的时间是错开的(也就是没有竞争),那么可以使用轻量级锁来优化</p>
<p>轻量级锁对使用者是透明的,语法仍然是synchronized(即会自动使用轻量级锁,当轻量级锁不能完成时,会自动升级为重量级锁)</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object obj=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(obj)&#123;<br>        <span class="hljs-comment">//同步块A</span><br>        method2();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span>(obj)&#123;<br>        <span class="hljs-comment">//同步块B</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功.</span><br></code></pre></td></tr></table></figure>

<p><strong>1.创建&#x3D;&#x3D;锁记录（Lock Record）&#x3D;&#x3D;对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的&#x3D;&#x3D;Mark Word&#x3D;&#x3D;</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/863118/202201/863118-20220113164105192-1790195589.png" alt="img"></p>
<p><strong>2.让锁记录中&#x3D;&#x3D;Object reference&#x3D;&#x3D;指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/863118/202201/863118-20220113164118025-2005661471.png" alt="img"></p>
<p><strong>3.如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下: &#x3D;&#x3D;线程中的锁信息和锁对象中的Mark Word发生了替换&#x3D;&#x3D;</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/863118/202201/863118-20220113164211576-1108189965.png" alt="img"></p>
<p><strong>4.如果 cas 失败，有两种情况</strong></p>
<ul>
<li><strong>如果是其它线程已经持有了该 Object 的&#x3D;&#x3D;轻量级锁&#x3D;&#x3D;，这时表明有竞争，进入&#x3D;&#x3D;锁膨胀&#x3D;&#x3D;过程</strong></li>
<li><strong>如果是自己执行了 synchronized 锁重入，那么再添加一条&#x3D;&#x3D;Lock Record&#x3D;&#x3D;作为重入的计数</strong></li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/863118/202201/863118-20220113164229581-1083087842.png" alt="img"></p>
<p><strong>5.当退出 synchronized 代码块（解锁时）&#x3D;&#x3D;如果有取值为 null 的锁记录，表示有重入&#x3D;&#x3D;，这时重置锁记录，表示重入计数减一</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/863118/202201/863118-20220113164240424-1914110054.png" alt="img"></p>
<p><strong>6.当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</strong></p>
<ul>
<li>成功，则解锁成功</li>
<li>失败，说明&#x3D;&#x3D;轻量级锁&#x3D;&#x3D;进行了&#x3D;&#x3D;锁膨胀&#x3D;&#x3D;或已经升级为重量级锁，进入&#x3D;&#x3D;重量级锁&#x3D;&#x3D;解锁流程</li>
</ul>
<h3 id="6-2-锁膨胀"><a href="#6-2-锁膨胀" class="headerlink" title="6.2.锁膨胀"></a>6.2.锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行&#x3D;&#x3D;锁膨胀&#x3D;&#x3D;，将轻量级锁变为重量级锁。</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();     <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;        <br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;            <span class="hljs-comment">// 同步块</span><br>         &#125;    <br> &#125;<br></code></pre></td></tr></table></figure>



<p><strong>1.当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</strong>（<strong>即此时的地址为00</strong>）</p>
<p>![mag](C:\Users\ASUS\Pictures\Saved Pictures\足球鞋足球装备门户-偶偶足球装备网_files\863118-20220113164319232-1556253267.png)</p>
<p><strong>2.这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</strong></p>
<ul>
<li><strong>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</strong></li>
<li><strong>然后自己进入 Monitor 的 EntryList BLOCKED</strong></li>
</ul>
<p><img src="https://img2020.cnblogs.com/blog/863118/202201/863118-20220113164325633-1829234762.png" alt="img"></p>
<p><strong>3.当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入&#x3D;&#x3D;重量级解锁流程&#x3D;&#x3D;</strong></p>
<ul>
<li><strong>即按照 Monitor 地址找到 Monitor 对象，</strong></li>
<li><strong>设置 Owner 为 null，</strong></li>
<li><strong>唤醒 EntryList 中 BLOCKED 线程</strong></li>
</ul>
<h3 id="6-3-自旋优化"><a href="#6-3-自旋优化" class="headerlink" title="6.3.自旋优化"></a>6.3.自旋优化</h3><p>轻量级锁竞争的时候，还可以使用&#x3D;&#x3D;自旋&#x3D;&#x3D;来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以&#x3D;&#x3D;避免阻塞&#x3D;&#x3D;。</p>
<p><strong>概述</strong>:这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p>
<p><strong>自旋重试成功的情况</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/863118/202201/863118-20220113164336012-1176965962.png" alt="image"></p>
<p><strong>自旋重试失败的情况</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/863118/202201/863118-20220113164342354-1400175307.png" alt="image"></p>
<p><strong>注意：</strong></p>
<blockquote>
<p><strong>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</strong><br>在 Java 6 之后&#x3D;&#x3D;自旋锁&#x3D;&#x3D;是<strong>自适应的</strong>，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。<br><strong>Java 7 之后不能控制是否开启自旋功能</strong></p>
</blockquote>
<h3 id="6-4-偏向锁"><a href="#6-4-偏向锁" class="headerlink" title="6.4.偏向锁"></a>6.4.偏向锁</h3><p><strong>概述</strong>:偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，<strong>偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</strong></p>
<p><strong>偏向状态</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/863118/202201/863118-20220113164430199-1752355948.png" alt="image"></p>
<p>&#x3D;&#x3D;轻量级锁&#x3D;&#x3D;在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p>
<p>Java 6 中引入了&#x3D;&#x3D;偏向锁&#x3D;&#x3D;来做进一步优化：<br>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<p><img src="https://img2020.cnblogs.com/blog/863118/202201/863118-20220113164401874-1749287981.png" alt="image"></p>
<p><img src="https://img2020.cnblogs.com/blog/863118/202201/863118-20220113164407219-595846800.png"></p>
<p><strong>一个对象创建时：</strong></p>
<ul>
<li><strong>如果开启了偏向锁（<code>biased_lock</code> : 默认开启），那么对象创建后（即创建一个对象就有了），markword 值为 0x05 即最后 3 位为 101，这时它的thread、epoch(批量重偏向时使用)、age（分代年龄） 都为 0</strong></li>
<li><strong>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>- XX:BiasedLockingStartupDelay=0</code> 来禁用延迟,-xx:UseBisedLocking禁用偏向锁</strong></li>
<li><strong>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值,当创建对象后,调用hashcode()方式时,会将偏向状态转为无锁的普通状态,因为偏向锁状态没有hashcode的值(没有额外的存储空间)</strong></li>
</ul>
<h3 id="6-5-撤销偏向状态"><a href="#6-5-撤销偏向状态" class="headerlink" title="6.5.撤销偏向状态"></a>6.5.撤销偏向状态</h3><h4 id="1-调用对象-hashCode"><a href="#1-调用对象-hashCode" class="headerlink" title="1.调用对象 hashCode"></a>1.调用对象 hashCode</h4><p><strong>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销</strong></p>
<ul>
<li>&#x3D;&#x3D;轻量级锁会在锁记录中记录 hashCode&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;重量级锁会在 Monitor 中记录 hashCode&#x3D;&#x3D;</li>
</ul>
<h4 id="2-其它线程使用对象"><a href="#2-其它线程使用对象" class="headerlink" title="2.其它线程使用对象"></a>2.其它线程使用对象</h4><p>当有其它线程使用偏向锁对象时，会将&#x3D;&#x3D;偏向锁升级为轻量级锁&#x3D;&#x3D;</p>
<h4 id="3-调用wait-x2F-notify"><a href="#3-调用wait-x2F-notify" class="headerlink" title="3.调用wait&#x2F;notify"></a>3.调用wait&#x2F;notify</h4><h3 id="6-6-批量重偏向"><a href="#6-6-批量重偏向" class="headerlink" title="6.6.批量重偏向"></a>6.6.批量重偏向</h3><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p>
<p>当&#x3D;&#x3D;撤销偏向锁阈值超过 20 次&#x3D;&#x3D;后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p>
<h3 id="6-7-批量撤销"><a href="#6-7-批量撤销" class="headerlink" title="6.7.批量撤销"></a>6.7.批量撤销</h3><p>当&#x3D;&#x3D;撤销偏向锁阈值超过 40 次&#x3D;&#x3D;后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p>
<h3 id="6-8-锁消除"><a href="#6-8-锁消除" class="headerlink" title="6.8.锁消除"></a>6.8.锁消除</h3><p><strong>概述</strong>:消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，<strong>通过这种方式消除没有必要的锁</strong>，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消除StringBuffer同步锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBufferRemoveSync</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>        <span class="hljs-comment">//StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用</span><br>        <span class="hljs-comment">//因此sb属于不可能共享的资源,JVM会自动消除内部的锁</span><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        sb.append(str1).append(str2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBufferRemoveSync</span> <span class="hljs-variable">rmsync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBufferRemoveSync</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>            rmsync.add(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        x++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">synchronized</span> (o) &#123;<br>            x++;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>发现a方法和 b方法的运行时间没有什么区别 ， &#x3D;&#x3D;JIT（即时编译器）&#x3D;&#x3D;发现&#x3D;&#x3D;锁对象o 不会逃离临界区&#x3D;&#x3D;，就会默认消除这个锁<br>关闭锁消除优化参数： &#x3D;&#x3D;-XX:-EliminateLocks&#x3D;&#x3D;</p>
<p><strong>synchronied和voatlie的区别:synchronied即保证了原子性又保证了可见性（可见性:当数据发生改变时,会强制让其他组件或者程序知晓,从而发生一系列变化）,而voatlie只保证了可见性</strong></p>
<h3 id="七-wait-x2F-notify机制的原理"><a href="#七-wait-x2F-notify机制的原理" class="headerlink" title="七.wait&#x2F;notify机制的原理"></a>七.wait&#x2F;notify机制的原理</h3><p>7.1 <strong>wait()方法是Object 类的方法，它的作用是使当前执行wait()方法的线程等待</strong>，在wait()所在的代码行处暂停执行，&#x3D;&#x3D;并释放锁&#x3D;&#x3D;，直到接到通知或中断（&#x3D;&#x3D;wait方法是已经有锁才可以调用,否则会抛出异常&#x3D;&#x3D;）</p>
<p>7.2 notify()方法用来通知那些可能等待该锁的其他线程，如果有多个线程等待，&#x3D;&#x3D;则按照执行wait方法的顺序发出一次性通知&#x3D;&#x3D;（<strong>一次只能通知一个！</strong>），使得等待排在第一顺序的线程获得锁。需要说明的是，执行notify方法后，<strong>当前线程并不会立即释放锁，要等到程序执行完，即退出synchronized同步区域后。</strong></p>
<p>总结：wait 方法使线程暂停运行，而notify 方法通知暂停的线程继续运行。</p>
<p>要想正确使用wait&#x2F;notify，一定要注意：<br>wait&#x2F;notify在&#x3D;&#x3D;调用前一定要获得相同的锁&#x3D;&#x3D;，如果在调用前没有获得锁，程序会抛出异常，也就调用不了wait&#x2F;notify；另外，如果获得的不是同一把锁，notify不起作用。</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span>(o)&#123;<br>                System.out.println(<span class="hljs-string">&quot;线程1获取锁...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    o.wait();   <span class="hljs-comment">//让线程t1处于等待状态</span><br><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;执行其他代码1...&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span>(o)&#123;<br>                System.out.println(<span class="hljs-string">&quot;线程2获取锁...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    o.wait();      <span class="hljs-comment">//让线程t2处于等待状态</span><br>                    <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;执行其他代码2...&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>          Thread.sleep(<span class="hljs-number">2000</span>);<br>        System.out.println(<span class="hljs-string">&quot;主线程唤醒其他线程&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span>(o)&#123;<br>           o.notify();  <span class="hljs-comment">//只唤醒其中一个线程(随机唤醒一个执行,另一个还是处于等待状态)</span><br><span class="hljs-comment">//            o.notifyAll();   可以唤醒全部线程</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<p>7.3.<strong>sleep(long n)和wait(long n)的区别</strong></p>
<ul>
<li>sleep是Thread的方法,而wait是Object的方法</li>
<li>sleep不需要强制和synchronized配合使用,但wait需要和synchronized一起用</li>
<li>sleep在睡眠的同时,不会释放对象锁的,但wait在等待的时候会释放对象锁</li>
<li>当调用时,线程的状态都是TIME_WAITING</li>
</ul>
<h3 id="八-同步模式之保护性暂停"><a href="#八-同步模式之保护性暂停" class="headerlink" title="八.同步模式之保护性暂停"></a>八.同步模式之保护性暂停</h3><p>定义:即Guarded Supension,<strong>用在一个线程等待另一个线程的执行结果</strong></p>
<p>要点:</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程,让他们关联同一个GuadedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列</li>
<li>JDK中,join的实现、Future的实现,FutureTast的实现,采用的就是这个模式</li>
<li>因为要等待另一方的结果,因此归类到同步模式</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-09fbbef561d05e885ea92e48198774ca_720w.jpg" alt="img"></p>
<p>**代码实现:**1.同步之保护性暂停</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个线程等待另一个线程的执行结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> class 保护性暂停 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>();<br>        ArrayList&lt;Object&gt; objects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                  System.out.println(<span class="hljs-string">&quot;获取并等待结果&quot;</span>);<br>                      guardedObject.get();<br>            System.out.println(objects.size());<br>            <span class="hljs-keyword">if</span>(objects.size()!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;objects.size(); i++)&#123;<br>                    System.out.println(objects.get(i));<br>                &#125;<br>            &#125;<br>              &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>                       objects.add(i);<br>                   &#125;<br>                  System.out.println(<span class="hljs-string">&quot;上传结果&quot;</span>);<br>                   guardedObject.complete(objects);<br><br>              &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>    <span class="hljs-keyword">private</span> Object response;<br>    <span class="hljs-comment">//等待执行结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//如果没有拿到结果就等待</span><br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//提交结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-built_in">this</span>.response = response;<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color=red>注意:使用了同步模式的保护性暂停,在一个执行还没有执行结束时,就可以对等待结果的线程进行唤醒操作(join的局限性太大了)。</font></p>
<p>2.优化:增加了延时等待</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个线程等待另一个线程的执行结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> class 保护性暂停之增加超时 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GuardedObjectStrong</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObjectStrong</span>();<br>        ArrayList&lt;Object&gt; objects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;获取并等待结果&quot;</span>);<br>            guardedObject.get(<span class="hljs-number">1</span>);<br>            System.out.println(objects.size());<br>            <span class="hljs-keyword">if</span>(objects.size()!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;objects.size(); i++)&#123;<br>                    System.out.println(objects.get(i));<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">1000</span>; i++)&#123;<br>                objects.add(i);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;上传结果&quot;</span>);<br>            guardedObject.complete(objects);<br><br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObjectStrong</span> &#123;<br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">//等待执行结果</span><br>    <span class="hljs-comment">//增加延时功能</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> &#123;<br>        <span class="hljs-comment">//获取初始时间</span><br>        <span class="hljs-type">long</span> initTime=System.currentTimeMillis();<br>        <span class="hljs-comment">//经历时间</span><br>         <span class="hljs-type">long</span> passTime=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (passTime &gt;= timeout) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//如果没有拿到结果就等待</span><br>                        <span class="hljs-built_in">this</span>.wait(timeout-passTime);  <span class="hljs-comment">//这样可以避免了虚假唤醒</span><br>                        <span class="hljs-comment">//这不能写timeout的分析:如果等待时间小于timeout就将它唤醒,并且为虚假唤醒</span><br>                        <span class="hljs-comment">//则又要等待timeout时间</span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-comment">//求经历时间</span><br>                    passTime = System.currentTimeMillis() - initTime;<br>                &#125;<br>            &#125;<br>        &#125;<br><br><br>    <span class="hljs-comment">//提交结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-built_in">this</span>.response = response;<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="保护性暂停的应用与扩展"><a href="#保护性暂停的应用与扩展" class="headerlink" title="保护性暂停的应用与扩展"></a>保护性暂停的应用与扩展</h3><h4 id="1-join-的执行原理"><a href="#1-join-的执行原理" class="headerlink" title="1.join()的执行原理"></a><strong>1.join()的执行原理</strong></h4><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无参数的join，调用join(0)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    join(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 无参的join方法会调用join(0)，从而进入该分支</span><br>    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断线程是否还存活，存活则调用wait等待</span><br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 判断线程是否还存活</span><br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            <span class="hljs-comment">// 计算剩余时间</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis - now;<br>            <span class="hljs-comment">// &lt;=0 表示join等待已经超时，退出等待</span><br>            <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 使用带有时间的wait方法等待</span><br>            wait(delay);<br>            <span class="hljs-comment">// 计算已过去的时间</span><br>            now = System.currentTimeMillis() - base;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// native方法，它会使线程进入等待，直到通过notify唤醒或者超时</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure>

<h4 id="2-扩展-解耦等待与成产"><a href="#2-扩展-解耦等待与成产" class="headerlink" title="2.扩展-解耦等待与成产"></a><strong>2.扩展-解耦等待与成产</strong></h4><p><img src="https://myblogtuchang.oss-cn-beijing.aliyuncs.com/resources-master/202207160203902.png" alt="img"></p>
<p>这个图中 t0 t2 t4是寄信人线程，t1 t3 t5负责邮递员线程 负责送信与代写信。每个信都有自己的id与内容 id可以理解为收信人的地址，寄信人通过邮递员把新送给收信人，这里我们只研究寄信人与邮递员之间的消息传递。<font color=red>注意：一个邮递员只能寄一封信。</font><br><strong>为什么要这样设计</strong><br>这样设计的好处是<strong>解耦</strong> 也就是降低消息传递的复杂度与关联度，我们把Futures当做邮局 寄信人 把信给邮局 然后邮递员来取信送出，我们可以想象一下 如果没有这个邮局 我们会怎么样？我们需要亲自跑到邮递员家里 把信给他 这期间邮递员可能有事出门了 你就白去了 总之这样做 效率很低，这就是邮局的好处。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test20&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test20</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>().start();<br>        &#125;<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Postman</span>(id, <span class="hljs-string">&quot;内容&quot;</span> + id).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.People&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 收信</span><br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.createGuardedObject();<br>        log.debug(<span class="hljs-string">&quot;开始寄信 id:&#123;&#125;&quot;</span>, guardedObject.getId());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">mail</span> <span class="hljs-operator">=</span> guardedObject.get(<span class="hljs-number">5000</span>);<br>        log.debug(<span class="hljs-string">&quot;寄信的内容 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Postman&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String mail;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Postman</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String mail)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.mail = mail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.getGuardedObject(id);<br>        log.debug(<span class="hljs-string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);<br>        guardedObject.complete(mail);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mailboxes</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 产生唯一 id</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.remove(id);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">createGuardedObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(generateId());<br>        boxes.put(go.getId(), go);<br>        <span class="hljs-keyword">return</span> go;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.keySet();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 增加超时效果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br><br>    <span class="hljs-comment">// 标识 Guarded Object</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-comment">// timeout 表示要等待多久 2000</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 开始时间 15:00:00</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-comment">// 经历的时间</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">passedTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 这一轮循环应该等待的时间</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> timeout - passedTime;<br>                <span class="hljs-comment">// 经历的时间超过了最大等待时间时，退出循环</span><br>                <span class="hljs-keyword">if</span> (timeout - passedTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.wait(waitTime); <span class="hljs-comment">// 虚假唤醒 15:00:01</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">// 求得经历时间</span><br>                passedTime = System.currentTimeMillis() - begin; <span class="hljs-comment">// 15:00:02  1s</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 给结果成员变量赋值</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<blockquote>
<p>12:21:51.157 c.People [Thread-1] - 开始寄信 id:3<br>12:21:51.158 c.People [Thread-0] - 开始寄信 id:1<br>12:21:51.157 c.People [Thread-2] - 开始寄信 id:2<br>12:21:52.171 c.Postman [Thread-4] - 送信 id:2, 内容:内容2<br>12:21:52.171 c.Postman [Thread-5] - 送信 id:1, 内容:内容1<br>12:21:52.171 c.Postman [Thread-3] - 送信 id:3, 内容:内容3<br>12:21:52.171 c.People [Thread-0] - 寄信的内容 id:1, 内容:内容1<br>12:21:52.171 c.People [Thread-2] - 寄信的内容 id:2, 内容:内容2<br>12:21:52.171 c.People [Thread-1] - 寄信的内容 id:3, 内容:内容3</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h4><p><strong>我们首先关注到了几个类分别是：</strong><br><strong>GuardedObject</strong></p>
<blockquote>
<p><strong>GuardedObject 类</strong>是写入消息与获取消息的类，由于信是邮递员代写 所以邮递员写信就是写入消息 收信人得到信就是获取消息<br><strong>这个类有几个方法</strong>：<br><strong>getId</strong>：获取这个信的id<br><strong>get</strong>：获取这个信，有时限的等待，如果获取时间过长就放弃获取<br><strong>complete</strong>：写信</p>
</blockquote>
<p><strong>Mailboxes</strong></p>
<blockquote>
<p><strong>Mailboxes类</strong> 可以理解为邮局 负责解耦寄信人与邮递员，主要形式是通过id与信之间的一一对应实现，邮递员不需要知道寄信的是谁 他只需要关注他要寄到的地址(就是信的id)是什么。<br><strong>这个类有几个方法与成员变量</strong>：<br><strong>boxes变量</strong>：是一个Hashtable类型 因为Hashtable是线程安全的 所以不用考虑关于 用到有关Hashtable的方法的线程安全问题，Hashtable的key是id value是信，我们通过id找到信<br><strong>generateId方法</strong>：作用是生产信的id，在createGuardedObject创建信时被调用<br><strong>getGuardedObject方法</strong>：作用是邮递员通过id获取信 然后邮递员送信 因为已经送信了 所以我们需要把它的Hashtable删除，所以我们这里选择使用的方法是boxes.remove(id); 通过remove获取信 并且删除它的Hashtable<br><strong>createGuardedObject方法</strong>：作用是创建一封信 也就是一个Hashtable，可以理解为寄信人 要寄信 需要先创建一个信封并且在信封上写上地址(id)<br><strong>getIds方法</strong>：这个方法的作用是获取所有id，目的是 让邮递员选择一个id对应的信送出</p>
</blockquote>
<p><strong>Postman</strong></p>
<blockquote>
<p><strong>Postman线程类</strong> 是邮递员类，作用是送信和<strong>代写信</strong><br><strong>这个类有几个方法与成员变量</strong>：<br><strong>id变量</strong>：要送信的id<br><strong>mail变量</strong>：要送信的内容<br><strong>Postman</strong>：有参构造，参数为id mail，通过id获取到信(内容为空) 然后往其中写入内容mail<br><strong>run方法</strong>：作用为每个线程 都在run方法 中 通过id获取信 并且写入内容mail</p>
</blockquote>
<p><strong>People</strong></p>
<blockquote>
<p><strong>People线程类</strong> 是寄信人类，作用是 创建信<br><strong>这个类的方法：</strong><br><strong>run方法</strong>：作用是创建信，并 在一段时间后 获取信的内容，如果5s后仍然没有获取到则放弃获取 说明信的内容写入超时</p>
</blockquote>
</blockquote>
<h3 id="九-异步模式之生产者-x2F-消费者"><a href="#九-异步模式之生产者-x2F-消费者" class="headerlink" title="九.异步模式之生产者&#x2F;消费者"></a>九.异步模式之生产者&#x2F;消费者</h3><p><strong>要点：</strong></p>
<ul>
<li>和前面的保护性暂停中的GuardObject不同，<strong>不需要产生结果和消费结果的线程一一对应</strong></li>
<li><strong>消费队列</strong>可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li><strong>消息队列</strong>是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
<li>JDK中各种阻塞队列，采用的就是这种模式</li>
</ul>
<p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/20201211154850439.png" alt="img"></p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 创建和运行线程;<br><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息队列，Java线程之间通信</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> class 生产者消费者模型 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//测试</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                queue.makeMessage(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(id, <span class="hljs-string">&quot;值&quot;</span> + id));<br>            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();<br>    &#125;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    queue.getMessage();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;消费者&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">MessageQueue</span> &#123;<br>    <span class="hljs-comment">//消息队列,用于方法数据</span><br> LinkedList&lt;Message&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Message&gt;();<br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>  capacity;  <span class="hljs-comment">//记录队列的容量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br>    <span class="hljs-comment">//获取数据</span><br>    <span class="hljs-keyword">public</span>  Message <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>            <span class="hljs-keyword">while</span>(queue.isEmpty())&#123;  <span class="hljs-comment">//有while循环避免了虚假唤醒</span><br>                <span class="hljs-comment">//队列为空时,只能等待放入数据</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                    System.out.println(<span class="hljs-string">&quot;队列为空,消费者只能等待&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> queue.removeFirst();<span class="hljs-comment">//从队列获取头部信息并返回</span><br>            System.out.println(<span class="hljs-string">&quot;获取的信息为:&quot;</span>+message);<br>            queue.notifyAll();  <span class="hljs-comment">//如果线程中有生产者等待则唤醒</span><br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//存入数据</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">makeMessage</span><span class="hljs-params">(Message message)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(queue)&#123;<br>            <span class="hljs-keyword">while</span> (queue.size()==capacity)&#123; <span class="hljs-comment">//队列为满时</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;队列已满，生产者线程等待&quot;</span>);<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>                queue.addLast(message);<br>                System.out.println(<span class="hljs-string">&quot;已生产消息： &quot;</span> + message);<br>                queue.notifyAll();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Message</span>&#123;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> Object value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(<span class="hljs-type">int</span> id, Object value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, value=&quot;</span> + value +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="十-park和unpark（LockSupport下的方法）"><a href="#十-park和unpark（LockSupport下的方法）" class="headerlink" title="十.park和unpark（LockSupport下的方法）"></a>十.park和unpark（LockSupport下的方法）</h3><p>执行代码:</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">park_unpark</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       Thread t1= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                System.out.println(<span class="hljs-string">&quot;执行线程....&quot;</span>);<br>                LockSupport.park();<br>                System.out.println(<span class="hljs-string">&quot;测试park...&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>       t1.start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;主线程&quot;</span>);<br>        LockSupport.unpark(t1);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>特点:</strong></p>
<p>与Object的wait和notify相比</p>
<ul>
<li>wait，notify和notifyAll必须配合Object Monitor(即synchronized)一起使用,而park与unpark不必事先获取锁</li>
<li>park&amp;unpark是以线程为单位来<font color=yellow>阻塞</font>和<font color=yellow>唤醒</font>线程,而notify只能随机的唤醒一个等待的线程</li>
<li>park&amp;unpark可以先unpark,而wait&amp;notify不能先notify</li>
</ul>
<h4 id="park和unpark的原理分析："><a href="#park和unpark的原理分析：" class="headerlink" title="park和unpark的原理分析："></a>park和unpark的原理分析：</h4><p><strong>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter， _cond和 _mutex</strong></p>
<ul>
<li>_mutex 互斥锁。</li>
<li>条件变量 _ cond就好比等待队列。</li>
<li>_counter （0 为停止线程，1 为继续执行)。</li>
</ul>
<ol>
<li>调用 park 就是要看需不需要停止。<ol>
<li>如果 _counter 为 0 ，那么 进入 _ cond 队列。</li>
<li>如果_counter 为 1 ，那么不需停止，继续前进。</li>
</ol>
</li>
<li>调用 unpark，_counter 变为 1。<ol>
<li>如果这时线程还在 _ cond 队列，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次<strong>他调用 park 时，仅是_counter 变为 0，不需停留继续前进</strong></li>
</ol>
</li>
</ol>
<p><strong>先调用park再调用upark的过程</strong></p>
<p>1.先调用park</p>
<ol>
<li>当前线程调用 Unsafe.park() 方法</li>
<li>检查 _counter ，本情况为 0，这时，<font  color=yellow>获得 _mutex 互斥锁(mutex对象有个等待队列 _cond)</font></li>
<li>线程进入 _cond 条件变量阻塞</li>
<li>设置 _counter &#x3D; 0</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210404202355450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>2.调用upark</p>
<ol>
<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>
<li>唤醒 _cond 条件变量中的 Thread_0</li>
<li>Thread_0 恢复运行</li>
<li>设置 _counter 为 0*0<br><img src="https://img-blog.csdnimg.cn/20210404202313342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8LbjuJ9Y-1617538754063)(photo/1594532057205.png)]"></li>
</ol>
<h4 id="先调用upark再调用park的过程"><a href="#先调用upark再调用park的过程" class="headerlink" title="先调用upark再调用park的过程"></a><strong>先调用upark再调用park的过程</strong></h4><ol>
<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>
<li>当前线程调用 Unsafe.park() 方法</li>
<li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li>
<li>设置 _counter 为 0</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210404202245137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA3NTEzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="十一-重新理解线程之间的转换"><a href="#十一-重新理解线程之间的转换" class="headerlink" title="十一.重新理解线程之间的转换"></a>十一.重新理解线程之间的转换</h3><p><img src="https://img-blog.csdnimg.cn/17051fa85ede48788787b9c27aa207dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5rex6JOd6ZyN5YWL,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="情况-1-NEW-–-gt-RUNNABLE"><a href="#情况-1-NEW-–-gt-RUNNABLE" class="headerlink" title="情况 1 NEW –&gt; RUNNABLE"></a>情况 1 NEW –&gt; RUNNABLE</h4><h4 id="情况-2-RUNNABLE-lt-–-gt-WAITING"><a href="#情况-2-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况 2 RUNNABLE &lt;–&gt; WAITING"></a>情况 2 RUNNABLE &lt;–&gt; WAITING</h4><h4 id="情况-3-RUNNABLE-lt-–-gt-WAITING"><a href="#情况-3-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况 3 RUNNABLE &lt;–&gt; WAITING"></a>情况 3 RUNNABLE &lt;–&gt; WAITING</h4><h4 id="情况-4-RUNNABLE-lt-–-gt-WAITING"><a href="#情况-4-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况 4 RUNNABLE &lt;–&gt; WAITING"></a>情况 4 RUNNABLE &lt;–&gt; WAITING</h4><h4 id="情况-5-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况-5-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况 5 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况 5 RUNNABLE &lt;–&gt; TIMED_WAITING</h4><h4 id="情况-6-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况-6-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况 6 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况 6 RUNNABLE &lt;–&gt; TIMED_WAITING</h4><h4 id="情况-7-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况-7-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况 7 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况 7 RUNNABLE &lt;–&gt; TIMED_WAITING</h4><h4 id="情况-8-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况-8-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况 8 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况 8 RUNNABLE &lt;–&gt; TIMED_WAITING</h4><h4 id="情况-9-RUNNABLE-lt-–-gt-BLOCKED6"><a href="#情况-9-RUNNABLE-lt-–-gt-BLOCKED6" class="headerlink" title="情况 9 RUNNABLE &lt;–&gt; BLOCKED6"></a>情况 9 RUNNABLE &lt;–&gt; BLOCKED6</h4><h4 id="情况-10-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况-10-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况 10 RUNNABLE &lt;–&gt; TERMINATED"></a>情况 10 RUNNABLE &lt;–&gt; TERMINATED</h4><p><strong>情况 1 NEW –&gt; RUNNABLE：</strong></p>
<ul>
<li>当调用 t.start() 方法时，由 NEW –&gt; RUNNABLE</li>
</ul>
<p> <strong>情况 2 RUNNABLE &lt;–&gt; WAITING：</strong></p>
<p>t 线程用 synchronized(obj) 获取了对象锁后</p>
<ul>
<li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时</li>
</ul>
<p>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE<br>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestWaitNotify</span> &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>          情况 <span class="hljs-number">3</span> RUNNABLE &lt;--&gt; WAITING<br>          当前线程调用 t.join() 方法时，当前线程从 RUNNABLE --&gt; WAITING<br>          注意是当前线程在t 线程对象的监视器上等待<br>          t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING --&gt; RUNNABLE<br>          情况 <span class="hljs-number">4</span> RUNNABLE &lt;--&gt; WAITING<br>          当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE --&gt; WAITING<br>          调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING --&gt;<br>                  RUNNABLE<br>          情况 <span class="hljs-number">5</span> RUNNABLE &lt;--&gt; TIMED_WAITING<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>              <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                  log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      obj.wait();<br>                  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                      e.printStackTrace();<br>                  &#125;<br>                  log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>); <span class="hljs-comment">// 断点</span><br>              &#125;<br>          &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>              <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>                  log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      obj.wait();<br>                  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                      e.printStackTrace();<br>                  &#125;<br>                  log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>); <span class="hljs-comment">// 断点</span><br>              &#125;<br>          &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>          sleep(<span class="hljs-number">0.5</span>);<br>          log.debug(<span class="hljs-string">&quot;唤醒 obj 上其它线程&quot;</span>);<br>          <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>              obj.notifyAll(); <span class="hljs-comment">// 唤醒obj上所有等待线程 断点</span><br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>



<p> <strong>情况 3 RUNNABLE &lt;–&gt; WAITING：</strong></p>
<ul>
<li>当前线程调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING 注意是当前线程在t 线程对象的监视器上等待</li>
<li>t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</li>
</ul>
<p> <strong>情况 4 RUNNABLE &lt;–&gt; WAITING：</strong></p>
<ul>
<li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li>
</ul>
<p><strong>情况 5 RUNNABLE &lt;–&gt; TIMED_WAITING：</strong></p>
<p>t 线程用 synchronized(obj) 获取了对象锁后</p>
<ul>
<li>调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<br>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE<br>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li>
</ul>
<p> <strong>情况 6 RUNNABLE &lt;–&gt; TIMED_WAITING：</strong></p>
<ul>
<li>当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING<br>注意是当前线程在t 线程对象的监视器上等待</li>
<li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从<br>TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
<p> <strong>情况 7 RUNNABLE &lt;–&gt; TIMED_WAITING：</strong></p>
<ul>
<li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li>
</ul>
<p> <strong>情况 8 RUNNABLE &lt;–&gt; TIMED_WAITING：</strong></p>
<ul>
<li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long<br>millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从<br>TIMED_WAITING–&gt; RUNNABLE</li>
</ul>
<p> <strong>情况 9 RUNNABLE &lt;–&gt; BLOCKED：</strong></p>
<ul>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –&gt; BLOCKED</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争<br>成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</li>
</ul>
<p><strong>情况 10 RUNNABLE &lt;–&gt; TERMINATED：</strong></p>
<p><strong>当前线程所有代码运行完毕，进入 TERMINATED</strong></p>
<h3 id="十二-多把锁"><a href="#十二-多把锁" class="headerlink" title="十二.多把锁"></a>十二.多把锁</h3><p>一间大屋子有两个功能：睡觉、学习，互不相干。</p>
<p>如果只用一把锁，那么并发度很低，解决办法是准备多个房间<strong>（多个对象锁）</strong></p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>	<span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>		System.out.println(<span class="hljs-string">&quot;sleeping 2 hour&quot;</span>);<br>		Thread.sleep(<span class="hljs-number">2000</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>	<span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>		System.out.println(<span class="hljs-string">&quot;sleeping 1 hour&quot;</span>);<br>		Thread.sleep(<span class="hljs-number">1000</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>改进</strong></p>
<p>private final Object studyRoom &#x3D; new Object();</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bedRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>        System.out.println(<span class="hljs-string">&quot;sleeping 2 hour&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>        System.out.println(<span class="hljs-string">&quot;sleeping 1 hour&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>将锁的粒度细分</strong></p>
<ul>
<li>好处，是可以增强并发度</li>
<li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li>
</ul>
<h4 id="锁的活跃性-死锁，活锁和饥饿"><a href="#锁的活跃性-死锁，活锁和饥饿" class="headerlink" title="锁的活跃性:死锁，活锁和饥饿"></a>锁的活跃性:死锁，活锁和饥饿</h4><p><strong>1.死锁问题:哲学家问题</strong></p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 创建和运行线程;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">public</span> class 哲学家就餐问题 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopsticks</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopsticks</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-type">Chopsticks</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopsticks</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>        <span class="hljs-type">Chopsticks</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopsticks</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-type">Chopsticks</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopsticks</span>(<span class="hljs-string">&quot;4&quot;</span>);<br>        <span class="hljs-type">Chopsticks</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopsticks</span>(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Chopsticks left;<br>    <span class="hljs-keyword">private</span> Chopsticks right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name,Chopsticks left, Chopsticks right)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.left=left;<br>        <span class="hljs-built_in">this</span>.right=right;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;吃饭...&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//获取左筷子</span><br>            <span class="hljs-keyword">synchronized</span>(left)&#123;<br>                <span class="hljs-comment">//获取右筷子</span><br>                <span class="hljs-keyword">synchronized</span>(right)&#123;<br>                    <span class="hljs-comment">//开始吃饭</span><br>                    eat();<br><br>                &#125;<br>                <span class="hljs-comment">//放下右筷子</span><br>            &#125;<br>            <span class="hljs-comment">//放下左筷子</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//筷子类</span><br><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Chopsticks</span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopsticks</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;chopsticks&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>2.活锁:出现在两个线程互相改变对方的结束条件，最后谁也无法结束</strong></p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLiveLock</span> &#123;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>			<span class="hljs-comment">// 期望减到 0 退出循环</span><br>			<span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>				sleep(<span class="hljs-number">0.2</span>);<br>				count--;<br>				log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>			<span class="hljs-comment">// 期望超过 20 退出循环</span><br>			<span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>				sleep(<span class="hljs-number">0.2</span>);<br>				count++;<br>				log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>			&#125;<br>		&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>饥饿</strong><br>很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题<br>下面我讲一下我遇到的一个线程饥饿的例子，先来看看使用<font  color=yellow>顺序加锁的方式</font>解决之前的死锁问题</p>
<p><img src="https://img-blog.csdnimg.cn/ffde64cd90414997b28ea958dd5f6bc0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>顺序加锁的解决方案</strong></p>
<p><img src="https://img-blog.csdnimg.cn/dfa5b75f90b94b47a3c5747c2b2ecdba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="十三-ReentrantLock"><a href="#十三-ReentrantLock" class="headerlink" title="十三.ReentrantLock"></a>十三.ReentrantLock</h3><p>相对于 synchronized 它具备如下特点</p>
<blockquote>
<p>可中断<br>可以设置超时时间<br>可以设置为公平锁<br>支持多个条件变量</p>
</blockquote>
<p>与 synchronized 一样，都支持可重入</p>
<p>基本语法:</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	<span class="hljs-comment">// 释放锁</span><br>	reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-可重入"><a href="#1-可重入" class="headerlink" title="1.可重入"></a><strong>1.可重入</strong></h4><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁<br>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	method1();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>	lock.lock();<br>	<span class="hljs-keyword">try</span> &#123;<br>		log.debug(<span class="hljs-string">&quot;execute method1&quot;</span>);<br>		method2();<br>	&#125; <span class="hljs-keyword">finally</span> &#123;<br>		lock.unlock();<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>	lock.lock();<br>	<span class="hljs-keyword">try</span> &#123;<br>		log.debug(<span class="hljs-string">&quot;execute method2&quot;</span>);<br>		method3();<br>	&#125; <span class="hljs-keyword">finally</span> &#123;<br>		lock.unlock();<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;<br>	lock.lock();<br>	<span class="hljs-keyword">try</span> &#123;<br>		log.debug(<span class="hljs-string">&quot;execute method3&quot;</span>);<br>	&#125; <span class="hljs-keyword">finally</span> &#123;<br>		lock.unlock();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.862</span> [main] c.TestReentrant - execute method1<br><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.865</span> [main] c.TestReentrant - execute method2<br><span class="hljs-number">17</span>:<span class="hljs-number">59</span>:<span class="hljs-number">11.865</span> [main] c.TestReentrant - execute method3<br></code></pre></td></tr></table></figure>

<h4 id="2-可打断"><a href="#2-可打断" class="headerlink" title="2.可打断"></a><strong>2.可打断</strong></h4><p>示例</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>	log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br>	<span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">//如果没有线程竞争那么此方法就会获取lock对象锁</span><br>     <span class="hljs-comment">//如果有线程竞争就进入阻塞队列,可以被其他线程用interrupt方法打断（如果没有打断会死等）</span><br>        <span class="hljs-comment">//加入可打断机制,防止了死锁</span><br>		lock.lockInterruptibly();<br>	&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>		e.printStackTrace();<br>		log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">try</span> &#123;<br>		log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>	&#125; <span class="hljs-keyword">finally</span> &#123;<br>		lock.unlock();<br>	&#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><span class="hljs-keyword">try</span> &#123;<br>	sleep(<span class="hljs-number">1</span>);<br>	t1.interrupt();<br>	log.debug(<span class="hljs-string">&quot;执行打断&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</strong></p>
<hr>
<h4 id="3-锁超时"><a href="#3-锁超时" class="headerlink" title="3.锁超时"></a><strong>3.锁超时</strong></h4><p>立刻失败</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>	log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br>	<span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;<br>		log.debug(<span class="hljs-string">&quot;获取立刻失败，返回&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">try</span> &#123;<br>		log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>	&#125; <span class="hljs-keyword">finally</span> &#123;<br>		lock.unlock();<br>	&#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><span class="hljs-keyword">try</span> &#123;<br>	sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>超时失败</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>	log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br>	<span class="hljs-keyword">try</span> &#123;<br>		<span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;  <span class="hljs-comment">//设置超时</span><br>			log.debug(<span class="hljs-string">&quot;获取等待 1s 后失败，返回&quot;</span>);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>	&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>		e.printStackTrace();<br>	&#125;<br>	<span class="hljs-keyword">try</span> &#123;<br>		log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>	&#125; <span class="hljs-keyword">finally</span> &#123;<br>		lock.unlock();<br>	&#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><span class="hljs-keyword">try</span> &#123;<br>	sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用 tryLock 解决哲学家就餐问题</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;<br>	String name;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(String name)</span> &#123;<br>		<span class="hljs-built_in">this</span>.name = name;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>	Chopstick left;<br>	Chopstick right;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> &#123;<br>		<span class="hljs-built_in">super</span>(name);<br>		<span class="hljs-built_in">this</span>.left = left;<br>		<span class="hljs-built_in">this</span>.right = right;<br>	&#125;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>			<span class="hljs-comment">// 尝试获得左手筷子</span><br>			<span class="hljs-keyword">if</span> (left.tryLock()) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					<span class="hljs-comment">// 尝试获得右手筷子</span><br>					<span class="hljs-keyword">if</span> (right.tryLock()) &#123;<br>						<span class="hljs-keyword">try</span> &#123;<br>							eat();<br>						&#125; <span class="hljs-keyword">finally</span> &#123;<br>							right.unlock();<br>						&#125;<br>					&#125;<br>				&#125; <span class="hljs-keyword">finally</span> &#123;<br>					left.unlock();<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>		log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>		Sleeper.sleep(<span class="hljs-number">1</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="4-条件变量"><a href="#4-条件变量" class="headerlink" title="4.条件变量"></a><strong>4.条件变量</strong></h4><blockquote>
<p> synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待<br> ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比synchronized 是那些不满足条件的线程都在一间休息室等消息<br> 而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</p>
</blockquote>
<p><strong>使用要点：</strong></p>
<blockquote>
<p>await 前需要获得锁<br>await 执行后，会释放锁，进入 conditionObject 等待<br>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁<br>竞争 lock 锁成功后，从 await 后继续执行</p>
</blockquote>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ReetrantLock锁;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock</span>多条件 &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitCigaretteQueue</span> <span class="hljs-operator">=</span> lock.newCondition(); <span class="hljs-comment">//等烟的休息室</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitbreakfastQueue</span> <span class="hljs-operator">=</span> lock.newCondition(); <span class="hljs-comment">//等早餐的休息室</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigrette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//查看是否有烟</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasBreakfast</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//查看是否有早餐</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    lock.lock();<br>                    <span class="hljs-keyword">while</span> (!hasCigrette) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            waitCigaretteQueue.await();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;等到了它的烟&quot;</span>);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;).start();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    lock.lock();<br>                    <span class="hljs-keyword">while</span> (!hasBreakfast) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            waitbreakfastQueue.await();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;等到了它的早餐&quot;</span>);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;).start();<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            sendBreakfast();<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            sendCigarette();<br>        &#125;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendCigarette</span><span class="hljs-params">()</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;送烟来了&quot;</span>);<br>                hasCigrette = <span class="hljs-literal">true</span>;<br>                waitCigaretteQueue.signal();  <span class="hljs-comment">//唤醒烟中休息室的线程</span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendBreakfast</span><span class="hljs-params">()</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;送早餐来了&quot;</span>);<br>                hasBreakfast = <span class="hljs-literal">true</span>;<br>                waitbreakfastQueue.signal();<span class="hljs-comment">//唤醒早餐中休息室的线程</span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>18:52:27.680 [main] c.TestCondition - 送早餐来了<br>18:52:27.682 [Thread-1] c.TestCondition - 等到了它的早餐<br>18:52:28.683 [main] c.TestCondition - 送烟来了<br>18:52:28.683 [Thread-0] c.TestCondition - 等到</p>
</blockquote>
<h4 id="5-公平锁"><a href="#5-公平锁" class="headerlink" title="5.公平锁"></a><strong>5.公平锁</strong></h4><p><code>ReentrantLock</code> 默认是不公平的</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">false</span>);  <span class="hljs-comment">//在创建对象时传入参数,可以控制是否公平</span><br>lock.lock();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;<br>	<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>		lock.lock();<br>		<span class="hljs-keyword">try</span> &#123;<br>			System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			lock.unlock();<br>		&#125;<br>	&#125;, <span class="hljs-string">&quot;t&quot;</span> + i).start();<br>&#125;<br><span class="hljs-comment">// 1s 之后去争抢锁</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>	System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; start...&quot;</span>);<br>	lock.lock();<br>	<span class="hljs-keyword">try</span> &#123;<br>		System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>	&#125; <span class="hljs-keyword">finally</span> &#123;<br>		lock.unlock();<br>	&#125;<br>&#125;, <span class="hljs-string">&quot;强行插入&quot;</span>).start();<br>lock.unlock();<br></code></pre></td></tr></table></figure>

<p>改为公平锁后</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-number">1</span><br>t465 running...<br>t464 running...<br>t477 running...<br>t442 running...<br>t468 running...<br>t493 running...<br>t482 running...<br>t485 running...<br>t481 running...<br>强行插入 running...<br><span class="hljs-number">12345678910</span><br></code></pre></td></tr></table></figure>

<p>公平锁一般没有必要，会降低并发度，后面分析原理时会讲解</p>
<h3 id="十四-模式设计"><a href="#十四-模式设计" class="headerlink" title="十四.模式设计"></a>十四.模式设计</h3><h4 id="1-固定运行顺序wait"><a href="#1-固定运行顺序wait" class="headerlink" title="1.固定运行顺序wait"></a>1.固定运行顺序wait</h4><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ReetrantLock锁;<br><span class="hljs-keyword">public</span> class 同步执行wait &#123;<br>    <span class="hljs-keyword">static</span>   Boolean isT2Running=<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Object lock= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>                <span class="hljs-keyword">while</span>(!isT2Running)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;T1运行&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">synchronized</span>(lock)&#123;<br>                System.out.println(<span class="hljs-string">&quot;T2运行&quot;</span>);<br>                isT2Running=<span class="hljs-literal">true</span>;<br>                lock.notify();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-固定运行顺序park"><a href="#2-固定运行顺序park" class="headerlink" title="2.固定运行顺序park"></a>2.固定运行顺序park</h4><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ReetrantLock锁;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">public</span> class 同步执行park &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Thread  t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>              LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;T1运行&quot;</span>);<br>        &#125;);<br>        t1.start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                System.out.println(<span class="hljs-string">&quot;T2运行&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                LockSupport.unpark(t1);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-交替运行wait"><a href="#3-交替运行wait" class="headerlink" title="3.交替运行wait"></a>3.交替运行wait</h4><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ReetrantLock锁;<br><span class="hljs-keyword">public</span> class 交替输出wait &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">waitNotify</span> <span class="hljs-variable">waitNotify</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">waitNotify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出结果 a    等待标记 1   下一个标记 2</span><br><span class="hljs-comment">   输出结果 b    等待标记 2   下一个标记 3</span><br><span class="hljs-comment">   输出结果 c    等待标记 3   下一个标记 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">waitNotify</span>&#123;<br>    <span class="hljs-keyword">private</span>   <span class="hljs-type">int</span> flag;<span class="hljs-comment">//等待标记</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>  loopNumber; <span class="hljs-comment">//下一个标记</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">waitNotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">print</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> waitFlag, <span class="hljs-type">int</span> nextFlag)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;loopNumber;i++)&#123;<br>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>                <span class="hljs-keyword">while</span>(waitFlag!=flag)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.println(str);<br>                flag=nextFlag;<br>                <span class="hljs-built_in">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-交替运行await"><a href="#4-交替运行await" class="headerlink" title="4.交替运行await"></a>4.交替运行await</h4><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ReetrantLock锁;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><span class="hljs-keyword">public</span> class 交替输出await &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">AwaitSign</span> <span class="hljs-variable">awaitSign</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwaitSign</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">ACondition</span> <span class="hljs-operator">=</span> awaitSign.newCondition();  <span class="hljs-comment">//A的休息室</span><br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">BCondition</span> <span class="hljs-operator">=</span> awaitSign.newCondition();  <span class="hljs-comment">//B的休息室</span><br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">CCondition</span> <span class="hljs-operator">=</span> awaitSign.newCondition();  <span class="hljs-comment">//C的休息室</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            awaitSign.print(<span class="hljs-string">&quot;a&quot;</span>,ACondition,BCondition);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>              awaitSign.print(<span class="hljs-string">&quot;b&quot;</span>,BCondition,CCondition);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           awaitSign.print(<span class="hljs-string">&quot;c&quot;</span>,CCondition,ACondition);<br>        &#125;).start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;开始&quot;</span>);<br>            awaitSign.lock();<br>            ACondition.signal();<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>          awaitSign.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span>&#123;<br>    <span class="hljs-keyword">private</span>  loopNumber; <span class="hljs-comment">//循环的次数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AwaitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span>&#123;<br>        <span class="hljs-built_in">this</span> loopNumber=loopNumber;<br>    &#125;<br>     <span class="hljs-comment">//输出结果  进入当前休息室  进入下一个休息室</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str,Condition current,Condition next)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;loopNumber;i++)&#123;<br>            lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                current.await();<br>                System.out.println(str);<br>                next.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">finally</span>&#123;<br>                unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="5-犹豫模式"><a href="#5-犹豫模式" class="headerlink" title="5.犹豫模式"></a>5.犹豫模式</h4><h5 id="引子：两阶段终止设计模式"><a href="#引子：两阶段终止设计模式" class="headerlink" title="引子：两阶段终止设计模式"></a>引子：两阶段终止设计模式</h5><h5 id="两阶段终止设计模式"><a href="#两阶段终止设计模式" class="headerlink" title="两阶段终止设计模式"></a>两阶段终止设计模式</h5><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test_TwoModelStop</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        ShareClass shareClass1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ShareClass</span>()<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            shareClass1.startmonitorthread();<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">10</span>);<br>        shareClass1.stopmonitorthread();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShareClass</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> stopflag=<span class="hljs-literal">false</span>; <span class="hljs-comment">//判断是否让线程停止运行</span><br>    <span class="hljs-keyword">private</span> Thread montiorthread;  <span class="hljs-comment">//监控线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startmonitorthread</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//监控线程</span><br>        montiorthread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span> (stopflag)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;montiorthread&quot;</span>);<br>        montiorthread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stopmonitorthread</span><span class="hljs-params">()</span>&#123;<br>        stopflag=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="犹豫模式"><a href="#犹豫模式" class="headerlink" title="犹豫模式"></a>犹豫模式</h5><p><strong>犹豫模式</strong>是通过一个标记来表示某段代码是否被执行过？如果希望只被执行一次那么判断标记就可以知道是否被执行过，这就是犹豫模式。<br>例如两阶段终止模式在主线程中多次调用start那么就会多次创建监控线程，如果不想多次创建此时就需要犹豫模式来对代码进行优化！<br>假如主线程多次调用start，但我们想只需要创建一次监控线程就行！</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        ShareClass shareClass1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ShareClass</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            shareClass1.startmonitorthread();<br>        &#125;).start();<br>        shareClass1.startmonitorthread();<br>        shareClass1.startmonitorthread();<br>        shareClass1.startmonitorthread();<br>        Thread.sleep(<span class="hljs-number">10</span>);<br>        shareClass1.stopmonitorthread();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>犹豫模式设计</li>
</ul>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startmonitorthread</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>           <span class="hljs-keyword">if</span> (balking)&#123;<br>               <span class="hljs-keyword">return</span>;<br>           &#125;<br>           balking=<span class="hljs-literal">true</span>;<br>       &#125;<br>       montiorthread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>               <br>           &#125;<br>       &#125;,<span class="hljs-string">&quot;montiorthread&quot;</span>);<br>       montiorthread.start();<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>主要的改动就是加了这里</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">if</span> (balking)&#123;<span class="hljs-comment">//判断犹豫标记</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            balking=<span class="hljs-literal">true</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p><strong>先判断犹豫的标记是否为真（为真则是下面这块代码已经运行过了），为假则是没运行过（当然要之后要设置为false）。当我们停止监控线程时在吧犹豫标记改回来！</strong></p>
<h5 id="犹豫模式的应用（单列模式）"><a href="#犹豫模式的应用（单列模式）" class="headerlink" title="犹豫模式的应用（单列模式）"></a>犹豫模式的应用（单列模式）</h5><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> calss Singleton<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE=<span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">genInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(INSTANCE!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>    INSTANCE=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-有序性"><a href="#6-有序性" class="headerlink" title="6.有序性"></a>6.有序性</h4><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> j;<br><span class="hljs-comment">// 在某个线程内执行如下赋值操作</span><br>i = ...;<br>j = ...;<br></code></pre></td></tr></table></figure>

<p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">i = ...;<br>j = ...;<br></code></pre></td></tr></table></figure>

<p>也可以是</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java">j = ...;<br>i = ...;<br></code></pre></td></tr></table></figure>

<p>这种特性称之为<font color=yellow>指令重排</font>，多线程下<font color=yellow>指令重排</font>会影响正确性。为什么要有重排指令这项优化呢？从 CPU执行指令的原理来理解一下吧</p>
<p>诡异的结果:</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>	<span class="hljs-keyword">if</span>(ready) &#123;<br>		r.r1 = num + num;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		r.r1 = <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>	num = <span class="hljs-number">2</span>;<br>	ready = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种特性称之为<font color=yellow>指令重排</font>，<strong>多线程下</strong><code>指令重排</code>会影响正确性。为什么要有重排指令这项优化呢？从 CPU执行指令的原理来理解一下吧</p>
<p>诡异的结果:</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>	<span class="hljs-keyword">if</span>(ready) &#123;<br>		r.r1 = num + num;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		r.r1 = <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>	num = <span class="hljs-number">2</span>;<br>	ready = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-number">123456789101112131415</span><br></code></pre></td></tr></table></figure>

<p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？<br>有同学这么分析</p>
<blockquote>
<p>情况1：线程1 先执行，这时 ready &#x3D; false，所以进入 else 分支结果为 1<br>情况2：线程2 先执行 num &#x3D; 2，但没来得及执行 ready &#x3D; true，线程1 执行，还是进入 else 分支，结果为1<br>情况3：线程2 执行到 ready &#x3D; true，线程1 执行，这回进入 if 分支，结果为 4(因为 num 已经执行过了）</p>
</blockquote>
<p>但我告诉你，结果还有可能是 0 ，信不信吧！<br>这种情况下是：线程2 执行 ready &#x3D; true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num &#x3D; 2<br>相信很多人已经晕了</p>
<p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化。这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现指令级并行(不改变程序的结果前提下)</p>
<p><strong>解决方法：</strong><br><font color=red>volatile&#96;修饰的变量，可以禁用指令重排</font></p>
<h4 id="7-volatile原理"><a href="#7-volatile原理" class="headerlink" title="7.volatile原理"></a>7.volatile原理</h4><p>volatile的底层实现原理是内存屏障,Memory Barrier</p>
<ul>
<li>对volatile变量的写指令后会加入写屏障</li>
<li>对volatile变量的读指令前会加入读屏障</li>
</ul>
<h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><ul>
<li><p>写屏障保证在该屏障之前的,对共享变量的改动,都同步到主存当中</p>
</li>
<li><p>&#96;&#96;&#96;java<br>public void actor(I_Result r){<br>nmu&#x3D;2;<br>ready&#x3D;true;  &#x2F;&#x2F;ready是volatile赋值带写屏障<br>&#x2F;&#x2F;写屏障<br>}</p>
<figure class="highlight arduino"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs arduino"><br>* 而读屏障保证在该屏障之后,对共享变量的读取,加载的是主存中最新数据<br><br>* ```<span class="hljs-function">java</span><br><span class="hljs-function">  <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span></span>&#123;<br>      <span class="hljs-comment">//读屏障</span><br>      <span class="hljs-comment">//ready是volatile读取值带读屏障</span><br>      <span class="hljs-keyword">if</span>(ready)&#123;<br>          r.r1=num+num;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          r.r1=<span class="hljs-number">1</span>;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h5><ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
<p>但是不能解决指令交错:</p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到最新的结果,但不能保证读跑到它前面去</li>
<li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li>
</ul>
<h4 id="8-双重检查锁定（Double-Checked-Locking）单列模式为例"><a href="#8-双重检查锁定（Double-Checked-Locking）单列模式为例" class="headerlink" title="8.双重检查锁定（Double-Checked Locking）单列模式为例"></a>8.双重检查锁定（Double-Checked Locking）单列模式为例</h4><h5 id="一-什么是双重检查锁定"><a href="#一-什么是双重检查锁定" class="headerlink" title="一.什么是双重检查锁定"></a>一.什么是双重检查锁定</h5><p>为了提高性能，会延迟初始化某些类，在第一次使用的时候做类的初始化。为了保证多线程下的线程安全，一般会做安全同步。简单的方式就是如下：</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对方法添加 <font  color=yellow>synchronized</font>关键词，每次访问时，就可以同步处理，安全。但是如果 <font color=yellow>getInstance()</font> 方法调用频繁，每次都要做同步，性能开销会比较大。所以有人提出使用 “ 双重检查锁定（Double-Checked Locking） ”。如下：</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-keyword">public</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">//首次访问会同步,而之后的使用没有synchronized</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样看似完美解决了问题，但是存在问题。</p>
<h5 id="二-双重检查锁定的问题"><a href="#二-双重检查锁定的问题" class="headerlink" title="二.双重检查锁定的问题"></a>二.双重检查锁定的问题</h5><p>假设有两个线程A、B，当线程A 执行到 <code>instance = new Singleton();</code> 时，线程B执行到 <code>if (instance == null)</code>。这里如果正常，那就是 Singleton被新建，并赋值给 instance ，线程B 拿到instance时不为null，同时开始使用 instance。</p>
<p>但是 <code>instance = new Singleton();</code>的执行过程可能被重排序。</p>
<p>正常过程如下：</p>
<ol>
<li>分配内存空间</li>
<li>初始化Singleton实例</li>
<li>赋值 instance 实例引用</li>
</ol>
<p>但是被重排序以后可能会出现：</p>
<ol>
<li>分配内存空间</li>
<li>赋值 instance 实例引用</li>
<li>初始化Singleton实例</li>
</ol>
<p>这样重排序并不影响单线程的执行结果，JVM是允许的。但是在多线程中就会出问题。</p>
<p>当重排序以后，线程B 拿到了不为null 的instance实例引用，但是并没有被初始化，然后线程B使用了一个没有被初始化的对象引用，就出问题了。</p>
<h5 id="解决方案一：不允许重排"><a href="#解决方案一：不允许重排" class="headerlink" title="解决方案一：不允许重排"></a>解决方案一：不允许重排</h5><blockquote>
<p>添加 <strong>volatile</strong> 关键词防止重排序。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 添加关键词</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">public</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="解决方案二：基于类初始化"><a href="#解决方案二：基于类初始化" class="headerlink" title="解决方案二：基于类初始化"></a>解决方案二：基于类初始化</h5><p>代码如下：</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceHolder</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> InstanceHolder.instance;<br>    &#125;<br><br>&#125;<span class="hljs-number">12345678910</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>内部类是延迟加载的，只有在第一次使用的时候才被加载。</p>
</blockquote>
<blockquote>
<p>对于每一个接口和类，在初始化时都有一个唯一的初始化锁LC与之对应。</p>
</blockquote>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><h5 id="方案一，除了可以实现对静态字段的延迟初始化外，还可以实现对实例字段的延迟初始化。"><a href="#方案一，除了可以实现对静态字段的延迟初始化外，还可以实现对实例字段的延迟初始化。" class="headerlink" title="方案一，除了可以实现对静态字段的延迟初始化外，还可以实现对实例字段的延迟初始化。"></a>方案一，除了可以实现对静态字段的延迟初始化外，还可以实现对实例字段的延迟初始化。</h5><h5 id="方案二，实现代码更简洁。"><a href="#方案二，实现代码更简洁。" class="headerlink" title="方案二，实现代码更简洁。"></a>方案二，实现代码更简洁。</h5><blockquote>
<p>字段延迟初始化降低了初始化类或创建实例的开销，但是增加了访问被延迟初始化的字段的开销。</p>
</blockquote>
<ul>
<li>在大多数时候，<strong>正常的初始化</strong>要优于<strong>延迟初始化</strong>。</li>
<li>如果确实需要对<strong>实例</strong>字段使用线程安全的延迟初始化，请使用<strong>方案一</strong>；</li>
<li>如果确实需要对<strong>静态</strong>字段使用线程安全的延迟初始化，请使用<strong>方案二</strong>。</li>
</ul>
<h3 id="十五-共享模式之无锁"><a href="#十五-共享模式之无锁" class="headerlink" title="十五.共享模式之无锁"></a>十五.共享模式之无锁</h3><h4 id="1-CAS与volatile"><a href="#1-CAS与volatile" class="headerlink" title="1.CAS与volatile"></a>1.CAS与volatile</h4><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 无锁实现线程安全;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> class 问题的提出 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Account.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountUnsafe</span>(<span class="hljs-number">10000</span>));<br>        Account.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountSafe</span>(<span class="hljs-number">10000</span>));<br>    &#125;<br> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountSafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br>        <span class="hljs-keyword">private</span> AtomicInteger balance;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountSafe</span><span class="hljs-params">(Integer balance)</span> &#123;<br>            <span class="hljs-built_in">this</span>.balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(balance);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> balance.get();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">//获取当前值</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>                <span class="hljs-comment">//如果当前值被其他线程修改</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>               	<span class="hljs-comment">/*</span><br><span class="hljs-comment">			compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值</span><br><span class="hljs-comment">			- 不一致了，next 作废，返回 false 表示失败</span><br><span class="hljs-comment">			比如，别的线程已经做了减法，当前值已经被减成了 990</span><br><span class="hljs-comment">			那么本线程的这次 990 就作废了，进入 while 下次循环重试</span><br><span class="hljs-comment">			- 一致，以 next 设置为新值，返回 true 表示成功</span><br><span class="hljs-comment">				*/</span><br>                <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 可以简化为下面的方法</span><br>            <span class="hljs-comment">// balance.addAndGet(-1 * amount);</span><br>        &#125;<br>    &#125;<br>   <br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br>        <span class="hljs-keyword">private</span> Integer balance;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> &#123;<br>            <span class="hljs-built_in">this</span>.balance = balance;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> balance;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>            balance -= amount;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Account</span> &#123;<br>        <span class="hljs-comment">// 获取余额</span><br>        Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span>;<br>        <span class="hljs-comment">// 取款</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">         * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(Account account)</span> &#123;<br>            List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                    account.withdraw(<span class="hljs-number">10</span>);<br>                &#125;));<br>            &#125;<br>            ts.forEach(Thread::start);<br>            ts.forEach(t -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.join();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            System.out.println(account.getBalance()<br>                    + <span class="hljs-string">&quot; cost: &quot;</span> + (end-start)/<span class="hljs-number">1000_000</span> + <span class="hljs-string">&quot; ms&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值 ：</p>
<p><strong>不一致了</strong>，next 作废，返回 false 表示失败 ,比如，别的线程已经做了减法，当前值已经被减成了 990 		</p>
<p>那么本线程的这次 990 就作废了，进入 while 下次循环重试 ：</p>
<p><strong>一致</strong>，以 next 设置为新值，返回 true 表示成功 	</p>
<p>关键的步骤为 <font color=yellow>compareAndSet</font>，它的简称就是 CAS （也有 <code>Compare And Swap</code> 的说法），它必须是<font color=yellow>原子操作</font>。</p>
<p><img src="https://img-blog.csdnimg.cn/fbcebad20deb4db4a5da5c29ef8cf4c4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>注意</p>
<blockquote>
<p>其实 CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证<strong>比较-交换</strong>的原子性。<br>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的</p>
</blockquote>
<p><strong>volatile</strong><br>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 <strong>volatile</strong> 变量都是直接操作主存。即一个线程对 <strong>volatile</strong> 变量的修改，对另一个线程可见。<br>注意</p>
<blockquote>
<p>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p>
</blockquote>
<p>CAS 必须借助 <strong>volatile</strong>才能读取到共享变量的最新值来实现<code>比较并交换</code>的效果</p>
<p><strong>为什么无锁效率高</strong></p>
<blockquote>
<p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而<code>synchronized</code> 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大<br>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/57b7e6eb61fa458eb257443e64713e8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95aSn6ZSF,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>CAS 的特点</strong><br>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。<br><strong>CAS 是基于乐观锁的思想：</strong>最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。<br><strong>synchronized 是基于悲观锁的思想：</strong>最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。<br>CAS 体现的是<font color=yellow>无锁并发、无阻塞并发</font>，请仔细体会这两句话的意思</p>
<blockquote>
<p>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一<br>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</p>
</blockquote>
<h4 id="2-原子整数"><a href="#2-原子整数" class="headerlink" title="2.原子整数"></a>2.原子整数</h4><p>J.U.C 并发包提供了：</p>
<blockquote>
<p>AtomicBoolean<br>AtomicInteger<br>AtomicLong</p>
</blockquote>
<p>以 <strong>AtomicInteger</strong>为例</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span><br>System.out.println(i.getAndIncrement());<br><span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>System.out.println(i.incrementAndGet());<br><span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>System.out.println(i.decrementAndGet());<br><span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>System.out.println(i.getAndDecrement());<br><span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span><br>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span><br>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br><span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br><span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br><span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span><br><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span><br>System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br><span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br></code></pre></td></tr></table></figure>

<h4 id="3-原子引用"><a href="#3-原子引用" class="headerlink" title="3.原子引用"></a>3.原子引用</h4><p><img src="https://upload-images.jianshu.io/upload_images/9575037-f1fb9543b66e35c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>AtomicReference是作用是对”对象”进行原子操作。<br>提供了一种读和写都是原子性的对象引用变量。原子意味着多个线程试图改变同一个AtomicReference(例如比较和交换操作)将不会使得AtomicReference处于不一致的状态。</p>
<p>AtomicReference和AtomicInteger非常类似，不同之处就在于AtomicInteger是对整数的封装，底层采用的是compareAndSwapInt实现CAS，比较的是数值是否相等，而AtomicReference则对应普通的对象引用，底层使用的是compareAndSwapObject实现CAS，比较的是两个对象的地址是否相等。也就是它可以保证你在修改对象引用时的线程安全性。</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 教师名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 学生投票数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> ticketNum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Teacher</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> ticketNum)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.ticketNum = ticketNum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTicketNum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ticketNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="AtomicReference-案例演示"><a href="#AtomicReference-案例演示" class="headerlink" title="AtomicReference 案例演示"></a>AtomicReference 案例演示</h3><p>这是一个天理不容的场景，小春哥一直兢兢业业工作，获得无数学生的芳心，临近期末通过学生投票评选一年一度的优秀教师，懵懂少年一直嫉妒我，拿到我的信息，解锁了最佳优秀的教师信箱，并自己的票数修改了，然后将信息放入信箱。代码演示如下：</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicExample6</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 引用类型 AtomicReference</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicReference&lt;Teacher&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BinaryOperator&lt;Teacher&gt; binaryOperator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryOperator</span>&lt;Teacher&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">apply</span><span class="hljs-params">(Teacher teacher, Teacher teacher2)</span> &#123;<br>            <span class="hljs-comment">// 返回新值</span><br>            <span class="hljs-keyword">return</span> teacher2;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;小春哥&quot;</span>, <span class="hljs-number">200</span>);<br>        <span class="hljs-comment">// 将当前对象设置到引用对象 AtomicReference 中</span><br>        atomicReference.set(teacher);<br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">updateTeacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;懵懂少年&quot;</span>, <span class="hljs-number">180</span>);<br>        <span class="hljs-comment">// teacher 和 引用类型AtomicReference 保存的对象一致 则能修改成功 </span><br>        atomicReference.compareAndSet(teacher, updateTeacher);<br>        System.out.println(atomicReference.get().getNamne());<br>        System.out.println(atomicReference.get().getTicketNum());<br>         <span class="hljs-type">Teacher</span> <span class="hljs-variable">accumulateTeacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;懵懂少年&quot;</span>, <span class="hljs-number">210</span>);<br>        <span class="hljs-comment">// 原子性地更新指定对象，并且返回AtomicReference更新后的值</span><br>        atomicReference.accumulateAndGet(accumulateTeacher, binaryOperator);<br>        System.out.println(atomicReference.get().getName());<br>        System.out.println(atomicReference.get().getTicketNum());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>被成功修改的结果如下：</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">懵懂少年<br>180<br>懵懂少年<br>210<br></code></pre></td></tr></table></figure>

<p><strong>AtomicReference</strong> 除了引用对象的使用，对于基本类型也是可以进行操作的。</p>
<p><strong>ABA 问题及解决</strong></p>
<p>ABA 问题</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>	log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>	<span class="hljs-comment">// 获取值 A</span><br>	<span class="hljs-comment">// 这个共享变量被它线程修改过？</span><br>	<span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.get();<br>	other();<br>	sleep(<span class="hljs-number">1</span>);<br>	<span class="hljs-comment">// 尝试改为 C</span><br>	log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>));<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>		log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;B&quot;</span>));<br>	&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>	sleep(<span class="hljs-number">0.5</span>);<br>	<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>		log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="hljs-string">&quot;A&quot;</span>));<br>	&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">11:29:52.325 c.Test36 [main] - main start...<br>11:29:52.379 c.Test36 [t1] - change A-&gt;B <span class="hljs-literal">true</span><br>11:29:52.879 c.Test36 [t2] - change B-&gt;A <span class="hljs-literal">true</span><br>11:29:53.880 c.Test36 [main] - change A-&gt;C <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：<br>只要有其它线程动过了共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>	log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>	<span class="hljs-comment">// 获取值 A</span><br>	<span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>	<span class="hljs-comment">// 获取版本号</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>	log.debug(<span class="hljs-string">&quot;版本 &#123;&#125;&quot;</span>, stamp);<br>	<span class="hljs-comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span><br>	other();<br>	sleep(<span class="hljs-number">1</span>);<br>	<span class="hljs-comment">// 尝试改为 C</span><br>	log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>		log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>,<br>		ref.getStamp(), ref.getStamp() + <span class="hljs-number">1</span>));<br>		log.debug(<span class="hljs-string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>sleep(<span class="hljs-number">0.5</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>	log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>,ref.getStamp(), ref.getStamp() + <span class="hljs-number">1</span>));<br>	log.debug(<span class="hljs-string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs bash">15:41:34.891 c.Test36 [main] - main start...<br>15:41:34.894 c.Test36 [main] - 版本 0<br>15:41:34.956 c.Test36 [t1] - change A-&gt;B <span class="hljs-literal">true</span><br>15:41:34.956 c.Test36 [t1] - 更新版本为 1<br>15:41:35.457 c.Test36 [t2] - change B-&gt;A <span class="hljs-literal">true</span><br>15:41:35.457 c.Test36 [t2] - 更新版本为 2<br>15:41:36.457 c.Test36 [main] - change A-&gt;C <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>java并发</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>对于MySQL你知道多少</title>
    <url>/2022/09/19/Mysql/</url>
    <content><![CDATA[<h2 id="关于数据库的那些事情"><a href="#关于数据库的那些事情" class="headerlink" title="关于数据库的那些事情"></a>关于数据库的那些事情</h2><h2 id="1-关于索引的事情"><a href="#1-关于索引的事情" class="headerlink" title="1.关于索引的事情"></a>1.关于索引的事情</h2><h3 id="1-索引的创建"><a href="#1-索引的创建" class="headerlink" title="@1.索引的创建"></a>@1.索引的创建</h3><h3 id="第一种-在create-table-的时候加上约束（隐式创建）"><a href="#第一种-在create-table-的时候加上约束（隐式创建）" class="headerlink" title="第一种:在create table 的时候加上约束（隐式创建）"></a>第一种:在create table 的时候加上约束（隐式创建）</h3><p><strong>隐式的方式创建索引.在声明有主键约束、唯一性约束、外键约束的字段上,会自动的添加相关的索引</strong> </p>
<ul>
<li><p><strong>约束</strong>：全称完整性约束，它是关系数据库中的对象，用来存放插入到一个表中一列数据的规则，用来确保数据的准确性和一致性。</p>
</li>
<li><p><strong>索引</strong>：数据库中用的最频繁的操作是数据查询，索引就是为了加速表中数据行的检索而创建的一种分散的数据结构。可以把索引类比成书的目录，有目录的肯定比没有目录的书，更方便查找。</p>
</li>
</ul>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_movie(<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    movie_rate <span class="hljs-keyword">unique</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>),   <br>    movie_name <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>), <br>    movie_url <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>),<br>) engine<span class="hljs-operator">=</span>Innodb charset utf8;<br></code></pre></td></tr></table></figure>



<h3 id="第二种-在creat-table的时候直接加上索引-显示创建"><a href="#第二种-在creat-table的时候直接加上索引-显示创建" class="headerlink" title="第二种:在creat table的时候直接加上索引(显示创建)"></a>第二种:在creat table的时候直接加上索引(显示创建)</h3><p><font color=Tan>语法:  索引类型 索引名(字段名)</font></p>
<p><font color=red>注意:  1.字段名中可以有多个,即组成联合索引。     2. 在声明了唯一性索引的字段,可以添加Null值</font></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span>  <span class="hljs-keyword">table</span> book(<br>book_id  <span class="hljs-type">int</span> auto_increment,<br>book_name  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>info  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>price  <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><span class="hljs-keyword">primary</span> key key_index(book id);<br>index  idx_name(book_name,price),<br><span class="hljs-keyword">unique</span> index  info(info)  <br>);<br></code></pre></td></tr></table></figure>



<h3 id="第三种-改变表的结构-索引从无到有的结构"><a href="#第三种-改变表的结构-索引从无到有的结构" class="headerlink" title="第三种:改变表的结构(索引从无到有的结构)"></a>第三种:改变表的结构(索引从无到有的结构)</h3><p><font color=Gold>方式1</font>： <font color=Tan>alter table  表名  drop  索引类型  索引名</font> </p>
<p><strong>索引的分类:</strong></p>
<ul>
<li>普通索引    index</li>
<li>唯一索引    uniqe</li>
<li>主键索引    primary </li>
<li>组合索引</li>
<li>全文索引</li>
<li>空间索引</li>
</ul>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span>  book <span class="hljs-keyword">add</span>  index book_index(book_id);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> book <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span> index book_uniqueIndex(info);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> book <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key  book_key(price);<br></code></pre></td></tr></table></figure>

<p><font color=Gold>方式2</font>： <font color=Tan>create  index 索引名  on 表名(字段名)</font></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test(<br>book_id  <span class="hljs-type">int</span>,<br>book_name  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>info  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>price  <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br><span class="hljs-keyword">create</span>  index  book_index  <span class="hljs-keyword">on</span> test(book_name);<br></code></pre></td></tr></table></figure>





<h3 id="2-查看索引的命令行"><a href="#2-查看索引的命令行" class="headerlink" title="@2.查看索引的命令行"></a>@2.查看索引的命令行</h3><p><font color=Gold>方式一:</font></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> book;<br></code></pre></td></tr></table></figure>

<p><font color=Gold>方式二:</font></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> book;<br></code></pre></td></tr></table></figure>



<h3 id="3-删除主键索引"><a href="#3-删除主键索引" class="headerlink" title="@3.删除主键索引"></a>@3.删除主键索引</h3><p><font color=Gold>方式一</font>：<font color=Tan>语法: alter table  表名  drop  索引类型  索引名</font> </p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span> book <span class="hljs-keyword">drop</span> index book_index;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> book <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;<br></code></pre></td></tr></table></figure>

<p><font color=red>注意:  删除索引  添加了auto_increment约束字段的唯一索引不能删除</font></p>
<p><font color=Gold>方式二</font> :  <font color=Tan>语法: drop 索引类型  索引名 on  表名</font></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">drop</span> index book_uniqueIndex <span class="hljs-keyword">on</span> book;<br></code></pre></td></tr></table></figure>

<p><font color=red>注意:  删除表中列时,如果要删除的列为索引的组成部分,<br>则该列也会从索引中删除.如果组成索引的所有列都被删除,则整个索引将被删除</font></p>
<h3 id="4-Mysql8-0新特性"><a href="#4-Mysql8-0新特性" class="headerlink" title="@4.Mysql8.0新特性"></a>@4.Mysql8.0新特性</h3><h4 id="1-支持降序索引-在8-0版本之前创建的仍然是升序索引-使用时进行反向扫描-这大大降低了数据库的效率"><a href="#1-支持降序索引-在8-0版本之前创建的仍然是升序索引-使用时进行反向扫描-这大大降低了数据库的效率" class="headerlink" title="1.支持降序索引  (在8.0版本之前创建的仍然是升序索引,使用时进行反向扫描,这大大降低了数据库的效率)"></a>1.支持降序索引  (在8.0版本之前创建的仍然是升序索引,使用时进行反向扫描,这大大降低了数据库的效率)</h4><p>支持了降序索引,无论是升序还是降序都不会对性能影响太大</p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span>  test1(<br>a <span class="hljs-type">int</span>,<br>b <span class="hljs-type">int</span>,<br>index  test_index(a  <span class="hljs-keyword">asc</span>,b <span class="hljs-keyword">desc</span>)<br>);<br></code></pre></td></tr></table></figure>

<h4 id="2-支持隐藏索引-通过先将索引设置为隐藏索引-再考虑要不要删除索引的方式就是软删除-还可以用于验证某个索引-删除之后的查询性能影响-就可以暂时先隐藏该索引"><a href="#2-支持隐藏索引-通过先将索引设置为隐藏索引-再考虑要不要删除索引的方式就是软删除-还可以用于验证某个索引-删除之后的查询性能影响-就可以暂时先隐藏该索引" class="headerlink" title="2.支持隐藏索引  通过先将索引设置为隐藏索引,再考虑要不要删除索引的方式就是软删除,还可以用于验证某个索引 删除之后的查询性能影响,就可以暂时先隐藏该索引"></a>2.支持隐藏索引  通过先将索引设置为隐藏索引,再考虑要不要删除索引的方式就是软删除,还可以用于验证某个索引 删除之后的查询性能影响,就可以暂时先隐藏该索引</h4><p><font color=Red>注意: 主键不能被设置为隐藏索引.当表中没有显式主键时,表中第一个唯一非空索引会成为隐式主键,也不能设为隐藏索引。当索引被隐藏后它的内容仍然是和正常索引一样实时更新的(即也是会影响DML的)</font></p>
<p><font color=IndianRed>那怎么创建隐式索引呢?</font></p>
<p><font color=Gold>方式一</font>：<strong>如果想要设置为隐藏索引,只要在创建的时候在索引后面加一个invisible即可</strong></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test(<br>book_id  <span class="hljs-type">int</span>,<br>book_name  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>info  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>price  <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>index   book_index(book_id)  invisible <br>); <br></code></pre></td></tr></table></figure>

<p><font color=Gold>方式二</font>：<strong>如果想要修改索引的可见性,可以对表的结构进行修改</strong></p>
<p><font color=Tan>语法: alter table  表名  alter index 索引名  invislble[不可见]&#x2F;visible[可见]</font> </p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1  <span class="hljs-keyword">alter</span> index  test_index  invisible; <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 <span class="hljs-keyword">alter</span> index  test_index visible;<br></code></pre></td></tr></table></figure>

<p><font color=red>注意:  当索引被隐藏时,它的内容仍然是和正常索引一样实时更新的.如果一个索引需要长期被隐藏,那么可以将其删除,因为索引的存在会影响插入、更新和删除的性能</font></p>
<h3 id="5-哪些情况适合创建索引"><a href="#5-哪些情况适合创建索引" class="headerlink" title="@5.哪些情况适合创建索引"></a>@5.哪些情况适合创建索引</h3><ul>
<li>字段的数值有唯一性的限制</li>
<li>业务上具有唯一特性的字段,即使是组合字段,也必须建成唯一索引</li>
<li>频繁作为where查询条件的字段</li>
<li>经常用group by和order by的列</li>
<li>update、delete的where条件列</li>
<li>distinct字段需要创建索引</li>
</ul>
<p><strong>在以上情况创建索引的同时要注意的事项:</strong></p>
<p>1.多表join连接操作时,创建索引注意事项: 连接表的数量尽量不要超过<font color=red>3张</font>,每增加一张表就相当于增加了一次嵌套的循环,数量级增长会非常快.对用于连接的字段创建索引,并且该字段在多表中类型要一致。</p>
<p>2.不要以为唯一索引影响了insert速度,这个速度损耗可以忽略,但是提高查找速度是明显的。</p>
<p>3.对数据按照某个条件进行查询后再进行update或者delete的操作,如果对where字段创建了索引,就能大幅提高效率.原理是因为我们需要先根据where条件列检索出来这条记录,然后再对它进行更新或者删除.如果进行更新的时候,更新的字段是非索引字段,提升的效率会更加明显,这是因为非索引字段更新不需要对索引进行维护</p>
<p>4.使用列的类型小(该类型表示的数据范围的大小)的创建索引</p>
<ul>
<li>数据类型小,在查询时进行的比较操作越快</li>
<li>数据类型小,索引占用的存储空间就越少,在一个数据页内就可以放下更多的记录,从而减少磁盘I&#x2F;O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul>
<p> 5.使用字符串前缀创建索引,字符串越长,索引占用的存储空间越大.取前缀这样既节约了空间,又减少了字符串的比较时间</p>
<p> 6.区分度高(散列性高)的列适合作为索引：</p>
<p>列的基数指的是某一列中不重复数据的个数,比方说某个列包含值2,5,8,2,5,8  基数为3,也就是说,在记录数一定的情况下,列的基数越大,该列中值越分散,列的基数越小,该列的值就越集中,可以使用公式select count(distinct left(列名,索引长度))&#x2F;count(*) from 表名计算区分度,越接近1越好,一般超过33%就算是比较高效的索引了,<font color=red>扩展:联合索引把区分度高(散列性高)的列放在前面</font></p>
<p>#怎么计算不同的长度的选择性呢?<br>select count(distinct left(address,10))&#x2F;count(<em>);  #截取前10个字符的选择度<br>#即根据select count(distinct left(列名,索引长度))&#x2F;count(</em>)的区分度来确定;</p>
<p>#10.使用最频繁的列放在联合索引的最左侧<br>#11.在多个字段都要创建索引的情况下,联合索引优于单值索引<br>#限制索引的数目<br>#索引的数目不是越多越好,建议单张表索引数目不超过6个,原因是:<br>#1.每个索引都需要占用磁盘块空间,索引越多,需要的磁盘空间就越大<br>#2.索引会影响insert、delete、update等语句的性能,因为表中的数据更改的同时,索引也会进行调整和更新,会造成负担<br>#3.会增加mysql优化器生成执行计划时间,降低查询性能</p>
<p>#哪些情况不适合创建索引<br>#1.在where中使用不到的字段,不要设置索引<br>#2.数据量小的表最好不要使用索引<br>#3.有大量重复数据的列上不要建立索引<br>#结论:当数据重复度大,高于10%的时候,也就不需要对这个字段使用索引<br>#4.避免对经常更新的表创建过多的索引<br>#5.不建议用无序的值作为索引<br>#如身份证、UUID(在索引比较时需要转为ASCLL,并且插入的时候可能会造成页分裂)、MD5、HASH、无序字符串等<br>#6.删除不再使用或者很少使用的索引<br>#7.不要定义冗余或者重复的索引</p>
<p>#哪些情况会使索引失效<br>#1.以%开头的Like查询<br>#2.创建了组合索引,没有满足‘最左匹配原则’<br>#3.查询条件中使用了or,并且or的前后条件中有一个列没有索引<br>#4.在索引列上的操作,如函数upper()、or、！&#x3D; (&lt; &gt;),not in,is no null,计算和类型转型(自动或手动)等<br>#创建的联合索引中,务必把范围涉及到的字段写在最后<br>#如  select  * from  user  where name&#x3D;123;(name类型为varchar)<br>#select  * from  user  where  id+1&#x3D;90001;<br>#select * from  where subsring(name,1,3)&#x3D;’abc’;</p>
<p>#查看系统参数<br>#show [global|session] status like ‘参数’;<br>#一些常用的性能参数如下:<br>#Connections:连接MySQL服务器的次数<br>#Uptime: MySQL服务器的上线时间<br>#Slow_queries:慢查询的次数<br>#innodb_rows_%:查看进行了增删改查的对应的行数<br>#Innodb_rows_read: select查询返回的行数<br>#Innodb_rows_inserted:执行INSERT操作插入的行数.<br>#Innodb_rows_updated:执行UPDATE操作更新的行数.<br>#Innodb_rows_deleted:执行DELETE操作删除的行数.<br>#Com_select:查询操作的次数。<br>#Com_insert:插入操作的次数。对于批量插入的INSERT操作，只累加一次<br>#Com_update:更新操作的次数。<br>#Com_delete:删除操作的次数。<br>#如查看mysql服务器连接的次数<br>show status like ‘Connections’;<br>show status like  ‘Innodb_rows_inserted’;<br>show status like ‘uptime’;<br>show status like ‘slow_queries’;<br>show status like ‘innodb_rows_%’;<br>show status like ‘com_select’;</p>
<p>#统计SQL的查询成本:last_query_cost  通常是我们评价一个查询的执行效率的一个常用指标,查询得到的值为数据来自多少个数据页<br>#sql查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论:<br>#1.位置决定效率.如果页就在数据库缓冲池中,那么效率是最高的,否则还需要从内存或者磁盘中进行读取,当然针对单个页的读取来说,如果页存在于内存中,会比在磁盘中读取效率高很多.<br>#2.批量决定效率.如果我们从磁盘中对单一页进行随机读.那么效率是很低的(差不多10ms)，而采用顺序读取的方式，批量对页进行读取,平均一页的读取效率就会提升很多,甚至要快于单个页面在内存中的随机读取。<br>#所以说,遇到I&#x2F;o并不用担心,方法找对了,效率还是很高的.我们首先要考虑数据存放的位置,如果是经常使用的数据就要尽量放到缓冲池中,其次我们可以充分利用磁盘的吞吐能力,一次性批量读取数据,这样单个页的读取效率也就得到了提升.</p>
<p>#定位执行慢的SQL:慢查询日志<br>#MySQL的慢查询日志,用来记录在MySQL中响应时间超过阈值的语句,具体运行时间超过long_query_time值的SQL,则会被记录到慢查询日志中,long_query_time的默认值为10s<br>#默认情况下数据库没有开启慢查询日志,需要我们手动来设置.如果不是调优需要的话,一般不建议启动该参数,因为开启了会对性能多多少少带了一定的影响<br>#查看慢查询日志参数<br>show variables like ‘%slow_query_log’;<br>#开启慢查询日志参数<br>set  global slow_query_log&#x3D;on;<br>#关闭慢查询日志参数<br>set global slow_query_log&#x3D;off;<br>#可以用来查询慢查询日志文件的位置<br>show variables like ‘%slow_query_log%’;<br>#查看慢查询long_query_time的阈值<br>show variables like  ‘%long_query_time%’;<br>#对long_query_time进行修改  注意long_query_time既为全局 又为会话的变量 所以2个都要改<br>set long_query_time&#x3D;1;<br>set global long_query_time&#x3D;1;<br>#补充说明:控制慢查询日志的还有一个系统变量:min_examined_row_limit 意思为扫描过的最少记录数(默认为0) 这个变量和查询执行时间,共同组成了判别了一个查询是否是慢查询的条件.如果查询扫描过的记录数大于等于这个变量的值,并且查询执行时间超过long_query_time 那么这个查询就被记录到慢查询日志中<br>show variables like ‘profiling’;<br>use ism;<br>select * from  user where id&#x3D;2;<br>show profiles;<br>show profile;</p>
<p>#explain讲解<br>#1.id值小结:<br>#id如果相同,可以认为是一组,从上往下顺序执行<br>#在所有组中,id值越大,优先级越高,越先执行<br>#关注点:id号每个号码,表示一趟独立的查询,一个sql的查询趟数越少越好<br>#2.select_type:select关键字对应的那个查询的类型,确定小查询在整个大查询中的角色<br>#查询语句中不包含’union’或者子查询的查询都算是’simple’类型<br>#对于包含’union’或者’union_all’或者子查询的大查询来说,它是由几个小查询组成的,其中最左边的查询的select_type值为’primary’<br>#对于包含’union’或者’union_all’或者子查询的大查询来说,它是由几个小查询组成的,其中除了最左边的查询,其他的查询为’union’<br>#mysql选择使用临时表来完成’union’查询的去重工作,针对该临时表的查询为’union result’<br>#3.type:代表某个表的执行查询时的访问方法,是一个较为重要的一个指标<br>#4.key_len:实际使用到的索引长度(即:字节数),帮你检测是否充分利用上了索引,’值越大越好’,针对的主要是联合索引</p>
<p>#关联查询优化<br>#结论:对于内连接来说,查询优化器可以决定谁作为驱动表,谁作为被驱动表出现的.如果表的连接条件中只能有一个字段有索引,则有索引的字段所在的表会被作为被驱动表.在两个表的连接条件都存在索引的情况下,会选择小表作为驱动表,’小表驱动大表’,本质就是减少外层循环的数据数量</p>
<p>#子查询优化<br>#子查询可以进行select语句的嵌套查询,即一个select查询的结果作为另一个select语句的条件.子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作.但是子查询的执行效率不高,原因:1.执行子查询时,mysql需要为内层查询语句的查询结果建立一个临时表,然后外层查询语句从临时表中查询记录.查询完毕后,再撤销这些临时表.这样会消耗过多的CPU和IO资源,产生大量的慢查询。2.子查询的结果集存储的临时表,不论是内存临时表还是磁盘临时表都不会存在索引,所以查询性能会受到一定的影响。3.对于返回结果集比较大的子查询,其对查询性能的影响也就越大<br>#在MySQL中,可以使用连接(JOIN)查询来替代子查询.连接查询不需要建立临时表,其速度比子查询要快,如果查询中使用到了索引的话,性能就会更好</p>
<p>#排序优化<br>问题:在WHERE条件字段上加字段上加索引,但是为什么在ORDER BY字段上还要加索引呢?<br>回答:在MySQL中,支持两种排序方式,分别是FileSort和Index排序<br>#1.index排序中,索引可以保证数据的有序性,不需要再进行排序,效率更高<br>#2.FileSort排序则一般在内存中进行排序,占用CPU较多.如果待排序结果较大,会产生临时文件I&#x2F;O到磁盘进行排序的情况,效率较低<br>优化建议:<br>#1.SQL中,可以在WHERE子句和ORDER By子句中使用索引,目的是在WHERE子句中避免全表扫描,在ORDER BY子句避免使用FileSort排序<br>#2.尽量使用Index完成ORDER BY排序.如果WHERE和ORDER By后面是相同的列就使用单索引列;如果不同就使用联合索引<br>#3.无法使用Index时,需要对FlieSort方式进行调优<br>#WHERE和ORDER BY是可以进行联合索引的,具体要看优化器的选择</p>
<p>#使用ORDER BY排序时,字段的升序和降序要一致,否则用不了索引!<br>#结论:当[范围条件]和[group by或者order by]的字段出现二选一时,优先观察条件字段的过滤数量,如果过滤的数据足够多,而需要排序的数据并不多时,优先把索引放在范围字段上.反之,一样.</p>
<p>#filesort算法:双路排序和单路排序<br>#排序的字段如果不在索引列上,则filesort会有两种算法:双路排序(慢,mysql4.1之前)和单路排序(快,mysql4.1之后)<br>#对filesort进行调优:查询的字段字节尽量小一点,太大了会超过默认的1024字节,会使用双路算法,否则会使用单路算法 </p>
<p>#GROUP BY优化<br>#1.group by使用索引的原则几乎跟order by一致,group by即使没有过滤条件用到索引,也可以直接使用索引<br>#2.group by先排序再分组,遵循索引键的最佳左前缀法则<br>#3.当无法使用索引列,增大max_length_for_sort_data和sort_buffer_size参数的设置<br>#4.where效率高于having,能使用where就不要用having了<br>#5.减少使用order by、group by、distict这些语句比较耗费CPU</p>
<p>#分页查询优化<br>问题:select * from student limit 2000000,10;  怎么进行优化处理?<br>优化思路一:在索引上完成排序分页操作,最后根据主键关联回原表查询所需要的其他列内容<br>select * from student t,(select id from student order by id limit 2000000,10) a where t.id&#x3D;a.id;<br>先将学生的id值进行排序(这里指的主键是不递增的,乱序的),然后查询<br>优化思路二: 该方案适合用于主键自增的表,可以把limit查询转换为某个位置的查询<br>select * from student where id&gt;2000000 limit 10;</p>
<p>#优先考虑覆盖索引<br>#什么是覆盖索引?<br>#1.一个索引包含了满足查询结果的数据就叫做覆盖索引<br>#2.索引列+主键  包含select到from之间查询的列</p>
<p>#覆盖索引的利弊<br>#好处:<br>#1.避免InnoDB表进行索引的二次查询(回表) 避免了对主键的二次查询,减少了IO操作<br>#2.可以把随时IO变成顺序IO加快查询效率  把随机读取的IO变为顺序IO<br>#由于覆盖索引可以减少树的搜索次数,显著提升查询性能,所以使用覆盖索引是一个常用的性能优化手段<br>#弊端:<br>#索引字段的维护  </p>
<p>#索引条件下推(ICP)<br>#常用于联合索引中,如第一个索引可以正常使用,第二个索引会失效,此时会索引条件下推,先过滤都两个索引的数据再回表操作 如:<br>create index  max_index on student(name,fist,send);<br>select * from student  whrer name&#x3D;’孙中伟’ and fist&#x3D;’%张’ and s&#x3D;’我’;<br>#此时就会用到ICP<br>#ICP的使用条件:<br>#1.ICP可以用于InnoDB和MyISAM表,包括分区表InnoDB和MyISAM表<br>#2.对于InnoDB表,ICP仅用于二级声音<br>#3.当使用覆盖索引时,不支持ICP<br>#4.相关子查询的条件不能使用ICP</p>
<p>#其他的优化策略<br>#EXISTS和IN的区分<br>select * from  A where cc in(select cc from B);<br>select * from A where exists(select cc from B where B.cc&#x3D;A.cc)<br>#基于小表驱动大表,A表小就用exists,B表小就用in<br>#COUNT(<em>)与COUNT(具体字段)效率<br>问题:在mysql中统计数据表的行数,可以用三种方式:SELECT COUNT(</em>)、SELECT COUNT(1)和SELECT COUNT(具体字段),使用这三者之间的查询效率是怎样的?<br>#环节1:COUNT(<em>)和COUNT(1)都是对所有结果进行COUNT,COUNT(</em>)和COUNT(1)本质没有区别(可能执行时间可能略有差别,不过你还是可以把它俩的执行效率看成是相等的)<br>#环节2:如果是MyISAM存储引擎,统计数据表的行数只需要O(1)的复杂度  </p>
<h1 id="如果是InnoDB-则是O-n-的复杂度"><a href="#如果是InnoDB-则是O-n-的复杂度" class="headerlink" title="如果是InnoDB,则是O(n)的复杂度"></a>如果是InnoDB,则是O(n)的复杂度</h1><p>#环节3:在InnoDB引擎中,如果采用COUNT(具体字段)来统计数据行数,要尽量采用二级索引.因为聚簇索引包含的信息多</p>
<p>#关于SELECT(<em>)<br>#在表查询中,建议明确字段.原因是:<br>#1.MySQL在解析的过程中,会通过查询数据字典将</em>按序转换为所有列名,这会大大的耗费资源和时间<br>#2.无法使用覆盖索引</p>
<p>#LIMIT 1 对优化的影响<br>#1.针对的是会扫描全表的SQL语句,如果你可以确定结果集只有一条,那么加上LIMIT 1的时候,当找到一条结果的时候就不会继续扫描,这样会加快查询速度<br>#2.如果数据表已经对字段建立了唯一索引,那么可以通过索引进行查询,不会全表扫描的话,就不需要加上LIMIT 1了</p>
<p>select UUID() from dual;</p>
<p>#第一范式:字段具有原子性<br>#第二范式:不具有部分依赖,都为完全依赖<br>#第三范式:非主属性字段之间不能存在依赖关系</p>
<p>#反范式化:遵循业务优先的原则,首先满足业务需求,再尽量减少冗余<br>#BCNF范式(巴斯范式):在3NF的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</p>
<p>#ER模型(实体关系模型)<br>#ER模型中有三要素,分别是实体、属性和关系</p>
<p>#优化数据库结构<br>#1.拆分表:将一张表拆分为几张小表,冷热数据分离(热数据为操作频繁的数据,冷数据为操作频率低的数据)<br>#2.增加中间表:对于需要经常联合查询的表,建立中间表以提高查询效率.把需要经常联合查询的数据插入中间表中,然后对原来的联合查询改为对中间表的查询,以此提高查询效率<br>#3.增加冗余字段<br>#4.优化数据类型(优先选择最符合的最小的数据类型),使用tinmestamp存储时间(4字节),用decimal代替float和double存储精确浮点数,因为不会丢失精度<br>#5.使用非空约束:在设计字段时,如果业务允许,建议尽量使用非空约束,好处:<br>#1.进行比较和计算时,省去要对NULl值的字段判断是否为空的开销,提高存储效率<br>#2.非空字段也容易创建索引,可以节省空间(每个字段1bit)</p>
<p>#大表优化<br>#1.限定查询的范围:禁止不带任何限制数据范围条件的查询语句<br>#2.读&#x2F;写分离:主库负责写,从库负责读(主从复制)<br>#3.分库分表:当数据库中数据表过多的时候,可以采用垂直分库,将关联的数据表部署到同一个数据库上</p>
<h1 id="当数据表中的列过多-可以采用垂直分表的方式-将一张数据表拆分为多个数据表-把经常一起用的列归为同一个表"><a href="#当数据表中的列过多-可以采用垂直分表的方式-将一张数据表拆分为多个数据表-把经常一起用的列归为同一个表" class="headerlink" title="当数据表中的列过多,可以采用垂直分表的方式,将一张数据表拆分为多个数据表,把经常一起用的列归为同一个表"></a>当数据表中的列过多,可以采用垂直分表的方式,将一张数据表拆分为多个数据表,把经常一起用的列归为同一个表</h1><p>#水平分库:将大的数据表按照某个属性维度分拆为不同的小表(最好分库)<br>#常见的数据库分片的两种方案:<br>#1.客户端代理:分片逻辑在应用端,封装在jar包中,通过修改或者封装JDBC层来实现<br>#2.中间件代理:在应用和数据中间加了一个代理层.分片逻辑统一维护在中间件服务中</p>
<p>#事务的ACID原则:<br>#原子性:事务要么发生到结束,要么就回滚到开始的时候<br>#一致性:事务执行的前后,数据从一个合法性状态变换到另一个合法性状态(是具体业务的合法性,如存款肯定要大于0)<br>#隔离性:一个事务的执行不能被其他事务干扰,即一个事务内部的操作及使用的数据对并发的其他事务是隔离的,并发执行的各个事务之间不能互相干扰<br>#持久性:事务一旦被提交,它对数据库中数据的改变就是永久性的   持久性是通过事务日志来保证的,日志包括了重做日志和回滚日志.当我们对数据修改的时候,首先会将数据库的变化信息记录到重做日志中,然后再对数据库中对应的行进行修改.好处是即使数据库系统崩溃了,数据库重启后也可以找到没有更新到数据库系统中的重做日志,重写执行,从而使事务具有持久性<br>#总结:原子性是基础,隔离性是手段,一致性是约束条件,持久性是目的</p>
<p>#显示事务<br>#事务的完成过程:<br>#1.开启事务<br>#2.一系列的DML的操作<br>#3.事务结束的状态:提交的状态(COMMIT)、中止的状态(ROLLBACk)<br>#显示事务<br>#使用关键字:start transaction 或者 begin 开启<br>#start transaction后面可以跟:read only(只读操作,临时表除外)&#x2F;read write(可以进行DML 默认状态)&#x2F;with consistent snapshot<br>#可以设置保存点(savepoint),进行回滚的时候可以回滚到保存点然后再完成事务的一系列操作.一个事务可以有多个保存点   savepoint 保存点的名称(创建保存点)   release savepoint 保存点名称(删除保存点)</p>
<p>#隐式事务<br>show variables like ‘autocommit’; #查看自动提交事务是否开启  默认为ON<br>#如何关闭自动提交?<br>#方式一:<br>set autocommit&#x3D;FLASE;  #针对于DML操作是有效的,对DDL操作无效(即如果关闭了自动提交,DDL操作依然还是有效的)<br>#方式二:我们在autocommit为true的情况下,使用start transaction或者begin开启事务,那么DML操作就不会自动提交数据</p>
<p>#MySQL中completion_type参数的作用,实际上这个参数有3种可能:<br>#1.completion&#x3D;0,这是默认情况.当我们执行Commit的时候会提交事务,在执行下一个事务时,还需要使用start transction或者begin来开启<br>#2.completion&#x3D;1,这种情况下,当我们提交事务后,相当于执行了Commit and chain,也就是开启一个链式事务,即当我们提交事务之后会开启了一个相同隔离级别的事务<br>#3.completion&#x3D;2,这种情况下commit&#x3D;commit and release,也就是当我们提交后,会自动与服务器断开连接</p>
<p>#数据的并发问题<br>#1.脏写:对于两个事物SessionA,Session B,如果事务Session A修改了另一个未提交事务Session B修改过的数据,那就意味着发生了脏写(即修改后数据未发生变化)<br>#2.脏读:对于两个事务Session A,Session B,Session A读取了已经被Session B更新但还没有提交的字段.之后若Session B回滚,Session A读取的内容就是临时并且无效的<br>#3.不可重复读:对于两个事务Session A,Session B,Session A读取了一个字段,然后Session B更新了该字段.之后Session A再次读取同一个字段,值就不同了.那就意味着发生了不可重复读<br>#4.幻读:对于两个事务Session A,Session B,Session A从一个表中读取了一个字段,然后Session B在该表中插入了一些新的行.之后,如果Session A再次读取同一个表,就会多出几行</p>
<p>#SQL中的四种隔离级别<br>#按照严重性排序:脏写&gt;脏读&gt;不可重复读&gt;幻读<br>#隔离级别:read uncommitted:读未提交,不能避免脏读、不可重复读、幻读<br>         #read committed(大多数数据库系统的默认级别):读已提交,可以避免脏读,但不可重复读、幻读问题存在<br>                 #repeatable read:可重复读,可以避免脏读、不可重复读,但幻读存在(MySQL的默认隔离级别)<br>  #serializable:可串行化,确保事务可以从一个表中读取相同的行.在这个事务持续期间,禁止其他事务对该表执行插入、更新和删除操作.所以的并发问题可以避免,但是性能十分低下</p>
<p>#显示MySQL默认隔离级别<br>show variables like  ‘transaction_isolation’;<br>#设置事务的隔离级别<br>set [Global|Session] transaction isolation level 隔离级别(read committed)<br>#或者用<br>set [Global|Session] transaction_isolation &#x3D;’隔离级别’(read-committed)</p>
<p>#事务的日志<br>#事务的隔离性是通过锁机制来实现的<br>#而事务的原子性、一致性由事务的redo日志和undo日志来保证<br>#redo log称为重做日志(物理操作,比如页号),提供再写入操作,恢复提交事务修改的页操作,用来保证事务的持久性<br>#undo log称为回滚日志(逻辑操作,sql语句),回滚行记录到某个特定版本,用来保证事务的原子性、一致性</p>
<p>#InnoDB引擎的事务采用了WAL(Write-Ahead Logging),这种技术的思想就是先写日志在写磁盘,只有日志写入成功了,才算事务提交成功.当发生宕机也可以通过redo log来恢复,保证ACID中的D<br>#redo log分为两部分:1.重做日志的缓冲,保存在内存中,是容失的 2.重做日志文件,保存在硬盘中<br>show variables like ‘%innodb_log_buffer_size%’; </p>
<p>#刷盘操作:从重做日志缓冲到重做日志文件中的过程,保证数据持久的重要过程<br>#InnoDB给出InnoDB_flush_log_at_trx_commit参数,该参数控制commit提交事务的时候,任何将redo log buffer中的日志刷新到redo log file中,支持三种策略:<br>#设置为0:表示每次事务提交时不进行刷盘操作(系统默认每个1s进行一次重做日志的同步)[不能保证持久性]<br>#设置为1:表示每次事务提交时都将进行同步,刷盘操作(默认)[效率最差]<br>#设置为2:表示每次事务提交时都只把redo log buffer内容写入page cache,不进行同步.由os自己决定什么时候同步到磁盘文件[效率最高,不能保证持久性]<br>show variables  like ‘innodb_flush_log_at_trx_commit’;</p>
<p>#写入red log buffer过程<br>#补充概念:Mini—Transaction<br>#MySQL把对底层页面中的一次原子访问的过程称之为一个Mini-Transaction,简称mtr,比如向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction.一个所谓的mtr可以包含一组redo日志,每一条语句其实是由若干个mtr组成,每一个mtr又可以包含若干条redo日志   语句(多个mtr(多个redo))</p>
<p>#redo log flie<br>#1.相关参数:innodb_log_group_home_dir:指定redo log文件组所在的路径,默认为.&#x2F;,表示在数据库的数据目录下<br>#MySQL的默认数据目录下有2个名为ib_logfile0和ib_logfile1的文件<br>#innodb_log_file_in_group:指明redo log flie的个数,默认为2个,最大100个<br>#innodb_log_file_size:单个redo log文件设置的大小,默认为48M,最大值为512G<br>show variables like ‘innodb_log_group_home_dir’;</p>
<p>#undo log:事务原子性的保证.在事务中更新数据的前置操作其实是要先写入一个undo log<br>#此外,undo log会产生redo log,也就是undo log的产生会伴随这redo log的产生,这是因为und log也需要持久性的保护<br>show variables like ‘innodb_undo_logs’;</p>
<p>#并发问题的解决方案<br>#方案一:读操作利用多版本并发控制(MVCC),写操作进行加锁<br>#所谓MVCC,就是生成一个ReadView(保证了事务不可以读取到未提交的事务所做的更改)<br>#方案二:读、写操作都加锁<br>#小结:采用MVCC方式的话,读-写操作彼此并不冲突,性能更高<br>     #采用加锁的方式的话,读-写操作彼此需要排队执行,影响性能<br>#一般情况下我们当然愿意采用MVCC来解决读-写操作并发执行的问题,但是业务在某些特殊的情况下,要求必须加锁的方式执行</p>
<p>#从数据操作的类型划分:读锁和写锁<br>#读锁:也叫共享锁,英文用S表示,针对同一份数据,多个事务的读操作可以同时进行而不会相互影响<br>#写锁:也叫排他锁,英文用X表示,当前写操作没有完成前,它会阻断其他写锁和读锁.这样就能确保在给定的时间里,只有一个事务能执行写入,并防止其他用户读取正在写入的同一个资源<br>#注意:InnoDB引擎读锁和写锁可以加在表上,也可以加在行上,而mysiam只能加表锁<br>#只有读锁X和读锁X可以兼容<br>#MySQL8.0新特性中,在X锁中,即select …for update&#x2F;share添加nowait和skip locked语句,跳过锁等待或者跳过锁定<br>#nowait会立即报错返回  而skip locked也会立即返回,只是返回的结果中不包含被锁定的行 </p>
<p>#在Insert、Update、delete中都需要加写锁(X)<br>#Insert中,一般情况,新插入一条记录的操作并不加锁,通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问</p>
<p>#从数据操作的粒度划分:表级锁(粒度粗,开销最小)、页级锁、行锁(粒度细,高并发响应)<br>use ISM;<br>select * from book;<br>lock table book write;  #加写锁<br>lock  table book  read;  #加读锁<br>select * from book;<br>update book  set book_name&#x3D;’像我这样’  where book_id&#x3D;1<br>unlock tables;   #释放锁</p>
<p>#上面测试了锁的类型<br>锁类型 自己可读  自己可写 自己可操作其他表  他人可读 他人可写<br>读锁    是          否          否            是      否,等<br>写锁    是          是         否           否,等      否,等<br>#在InnoDB存储引擎中,一般不会为表添加表级的读锁和写锁,因为存在粒度更细的行锁</p>
<p>#在InnoDB中,添加行级锁: select … for  share 添加行级的读锁   select …for update 写锁<br>#添加表级锁,lock table 表名 read 添加表级的读锁    lock table 表名 write  写锁<br>#InnoDB支持多粒度锁,即行级锁和表级锁可以同时存在,而意向锁就是一种表锁<br>#意向锁要解决的问题:如果我们给某一行的数据加上了排他锁,数据库会自动给更大的一级空间,比如数据页或者数据表加上意向锁,来告诉其他人这个数据页或者数据表已经有人上过排他锁了,就不用在检查各个行中是否存在锁了<br>#意向锁是存储引擎自己维护的,用户无法手动操作意向锁,意向锁在保证并发性的前提下,实现了行锁和表锁共存且满足事务隔离性的要求</p>
<p>#意向锁不管是读和写都是兼容的,但是除了IS与S兼容外,意向锁会与共享锁&#x2F;排他锁互斥<br>#元数据锁–表锁</p>
<p>#InnoDB中的行锁<br>#行锁也称为记录锁,就是锁住某一行.需要的注意的是,MySQL服务器层并没有实现行锁机制,行锁只在存储引擎层实现<br>#优点:锁定力度小,发生锁冲突概率低,可以实现的并发度高<br>#缺点:对于锁的开销比较大,加锁会比较慢,容易出现死锁的情况<br>#1.记录锁:锁住一条记录<br>#2.间隙锁(gap):gap锁的提出仅仅是为了防止插入幻影记录而提出的.虽然有共享gap锁和独占gap锁这样的说法,但是他们起到的作用是相同的,并且加了gap锁,并不会限制其他事务对这条记录锁或者继续加gap锁<br>#例如有id&#x3D;3和8,在8这个行中加入了gap锁,则在(3,8)之间就不能插入数据了<br>#间隙锁是针对于两个或者两个以上的事务解决幻读问题而产生的<br>#如果两个事务都加了间隙锁,并且两个事务都进行了插入不成功的操作,则会发生死锁(表锁不会发生死锁！)<br>select * from book where book_id&#x3D;5 for update;  #对不存在的id加锁(X锁或者S锁)&#x3D;&#x3D;间隙锁<br>insert into book values (2,’wd’,’2’,50);<br>begin;<br>select * from book where book_id&#x3D;6 for update;<br>insert into book values (7,’wd’,’2’,51);<br>rollback;</p>
<p>#3.临键锁:即可以锁住某条记录,又可以阻止其他事务在该记录前边的间隙插入新记录.事务级别在可重复读的情况下使用的数据库锁,本质是一个记录锁和gap锁的合体<br>select * from book where book_id&lt;&#x3D;9 and book_id&gt;2 for update; #即锁住记录为9的数据,并且在2和9之间加间隙锁(即加了临键锁)</p>
<p>#4.插入意向锁:一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁(临键锁也包含gap锁),<br>#如果有的话,插入操作需要等待,直到拥有gap锁的那个事务提交.但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构,插入意向锁是一种 Gap锁,不是意向锁,在insert操作时产生<br>#插入意向锁之间互不排斥,所以即使多个事务在同一区间插入多条记录,只要记录本身不冲突,那么事务之间就不会出现冲突等待.插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</p>
<p>#页锁:页锁的开销介于表锁和行锁之间,会出现死锁.锁定粒度介于表锁和行锁之间,并发度一般</p>
<p>#从对待锁的态度划分:乐观锁、悲观锁(看待数据并发的思维方式,不是锁,而是锁的设计思想)<br>#1.悲观锁:共享资源每次只给一个线程使用,其他线程阻塞,用完后再把资源转让给其他线程(Java中synchronized、ReetrantLock等独占锁就是悲观锁思想的实现)<br>#select … for update 悲观锁<br>#注意select … for update语句执行过程中所有扫描的行都会被锁住,因此在MySQL中使用悲观锁必须确定使用了索引,而不是全表扫描,否则将会把整个表锁住(悲观锁的使用,很好的解决了秒杀问题出现超买的问题)<br>#2.乐观锁:不采用数据库自身的锁机制,而是通过程序来实现.在程序上,我们可以采用版本号机制和CAS机制实现.乐观锁适用于多读的应用类型,这样可以提高吞吐量<br>#@1.乐观锁的版本号控制<br>#在表中设计一个版本字段version,第一次读的时候,会获取version字段的取值,会执行update…set version&#x3D;version+1 where version&#x3D;version.如果此时已经有事务对这条事务进行了更改,修改就不会成功.这种方式类似于我们熟悉的SVN版本管理系统,当我们修改了代码进行提价时,首先会检查当前版本号与服务器上的版本号是否一致,如果一致就可以直接提交,如果不一致就需要更新服务器的最新代码,然后再进行提交<br>#@2.乐观锁的时间戳机制(和版本号控制差不多)</p>
<p>#按加锁的方式:隐式锁和显示锁<br>#隐式锁:即一个事务对新插入的记录可以不显示的加锁(生成一个锁结构),但是由于事务id的存在,相当于加了一个隐式锁,别的事务在对这条记录加S锁或者X锁时,由于隐式锁的存在,会先帮助当前事务生成一个锁结构,然后自己再生成一个锁结构后进入等待状态.是一种延迟加锁的机制,从而减少加锁的数量<br>#显示锁:通过特定的语句进行加锁</p>
<p>#其他锁之:全局锁<br>#全局锁就是对整个数据库实例加锁.当你需要让整个库处于只读状态的时候,可以使用这个命令,之后其他线程的以下语句会被阻塞:数据库更新语句、数据定义语句和更新类事务的提交语句.全局锁的典型使用场景是:做全库逻辑备份<br>#全局锁的命令:<br>Flush tables with read lock;</p>
<p>#其他锁之:死锁<br>#概念:两个事务都持有对方需要的锁,并且在等待对方释放,并且双方都不会释放自己的锁</p>
<p>#产生死锁的必要条件<br>#1.两个或者两个以上事务 2.每个事务都已经持有锁并且申请新的锁<br>#3.锁资源同时只能被同一个事务持有或者不兼容  4.事务之间因为有持有锁和申请锁导致彼此循环等待<br>#死锁的关键在于:两个或者两个以上的Session加锁的顺序不一致</p>
<p>#如何处理死锁<br>#方式1:等待,直到超时(innodb_lock_wait_timeout&#x3D;50s)<br>#查看超时时间<br>show variables like ‘innodb_lock_wait_timeout’;<br>#即当两个事务互相等待时,当一个事务等待时间超过设置的阈值时,将其回滚,另外事务继续进行<br>#缺点:对于在线服务来说,这个等待时间往往是无法接受的<br>#方式2:使用死锁检测进行死锁处理<br>#方式1检测死锁太过被动,innodb还提供了wait-for graph算法来主动进行死锁检测,每当加锁请求无法立即满足需要进行等待时,wait-for graph算法都会被触发.这是一种比较主动的死锁检测机制,要求数据库保存锁的信息链表和事务等待链表两部分信息<br>#死锁检测的原理是构建一个以事务为顶点、锁为边的有向图,判断有向图是否存在环,存在即有死锁<br>#缺点:每个新的被阻塞的线程,都要判断是不是由于自己的加入导致了死锁,这个操作时间复杂度为O(n)</p>
<p>#如何解决:方式一:关闭死锁检测,但是意味着可能会出现大量的超时,会导致业务有损<br>         #方式二:控制并发访问的数量.比如在中间件中实现对于相同行的更新,在进行引擎之前排队,这样在innodb内部就不会有大量的死锁检测工作 </p>
<p>#锁的内存结构<br>#结构解析<br>#1.锁所在的事务信息:无论是表锁还是行锁,都是事务执行过程中生成的,哪个事务生成了这个锁结构,这里就记录这个事务的信息,此锁的事务信息在内存结构中这是一个指针,通过指针可以找到内存中关于该事务的更多信息<br>#2.索引信息:对于行锁,需要记录一下加锁的记录是属性哪一个索引的.这里也是一个指针<br>#3.表锁&#x2F;行锁信息<br>#表锁结构和行锁结构在这个位置的内容是不同的<br>#表锁:记载着是对哪个表加的锁,还有其他的一些信息<br>#行锁:记录了三个重要的信息:Space ID:记录所在表空间   Page Number:记录所在的页号  n_bits:对于行锁来说,一条记录就对应着一个比特位,一个页面中包含很多记录,用不同的比特位来区分到底是哪一个记录加了锁<br>#n_bits的值一般都比页面中记录条数多一些.主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构<br>#type_mode分为三部分:lock_mode,lock_type,rec_lock_type<br>#lock_mode:锁模式(区分是X锁还是S锁):IS,IX,S,X,AUTO-INC锁<br>#lock_type:锁类型(表锁和行锁)<br>#rec_lock_type(具体锁的类型)next-key锁,gap锁,记录锁,临键锁等</p>
<p>#锁监控<br>#关于MySQL锁的监控,我们一般可以通过检查InnoDB_row_lock等状态变量来分析系统上的行锁的争夺情况<br>show status like ‘innodb_row_lock%’;<br>#其他监控方法:我们把MySQL事务和锁的信息记录在information_schema库中,在5.7之前涉及到的三张表分别是InnoDB_Trx、InnoDB_LOCKs和InnoDB_lock_waits<br>#后面用performance_schema.data_locks和performance_schema.data_lock_waits代替了InnoDB_LOCKs和InnoDB_lock_waits<br>use information_schema;<br>show tables;<br>select * from InnoDB_Trx;<br>select *from performance_schema.data_locks;<br>select * from performance_schema.data_lock_waits;</p>
<p>#多版本并发控制<br>#1.MVCC:通过数据行的多个版本管理来实现数据库的并发控制<br>#2.快照读与当前读<br>#2.1快照读:又叫一致性读,读取的是快照数据.不加锁的简单的Select都属于快照读,快照读是为了提高并发性的考虑,实现是基于MVCC,很多情况下,避免了加锁操作,降低了开销<br>#2.2当前读:当前读取的是最新的版本,读取时还要保证其他事务并发不能修改当前记录,会对读取的记录加锁</p>
<p>#隐藏字段、Undo Log版本链<br>#聚簇索引记录中都包含两个必要的隐藏列:1.trx_id:每次一个事务对某条聚簇索引记录进行改动时,都会把事务的事务id赋值给trx_id隐藏列<br>#2.roll_pointer:每次对某条聚簇索引记录进行改动时,都会把旧的版本写到undo日志中,然后这个隐藏列就相当于一个指针,可以通过它来找到该记录修改前的信息</p>
<p>#MVCC实现原理之ReadView<br>#什么是ReadView?就是事务A在使用MVCC机制进行快照读操作时产生的读视图,当事务启动时,会生成一个快照,InnoDB为每个事务构造了一个数组,用来记录并维护系统当前活跃事务的id(启动了但是还没有提交)<br>#ReadView中主要包含4个比较重要的内容:<br>#1.create_trx_id:创建这个ReadView的事务id(只有增删改才会为事务分配事务id,否则在一个只读的事务id默认为0)<br>#2.trx_ids:表示在生成ReadView时当前系统中活跃的读写事务的事务id列表<br>#3.up_limit_id:活跃的事务中最小的事务id<br>#4.low_limit_id:最大事务id中应该分配给下一个事务的id值(即最大事务id+1)</p>
<p>#MVCC整体操作流程<br>#1.首先获取事务自己的版本号,也就是事务ID<br>#2.获取ReadView<br>#3.查询得到的数据,然后与ReadView中的事务版本号进行比较<br>#4.如果不符合ReadView规则,就需要从Undo log中获取历史快照(某个版本的数据对当前事务不可见的话,那就顺着版本链找到下一个版本的数据,继续按照上边的步骤判断,以此类推.如果最后一个版本也不可见的话,那么就意味着该条记录找不见)<br>#5.最后返回符号规则的数据</p>
<p>#在不同隔离级别下,ReadView的生成情况:在读已提交隔离级别中,同样的查询语句都会重新获取一次ReadView,这时如果ReadView不同,就可能产生不可重复读或者幻读的情况<br>#在可重复读的隔离级别下,一个事务只有在第一次Select这个语句的时候会获取一次ReadView,而后面的Select操作都会复用这个ReadView,故不会出现不可重复读或者幻读的情况</p>
<p>#MVCC可以解决:<br>#1.读写之间阻塞的问题:通过MVCC可以让读写互相不阻塞,即读不阻塞写,写不阻塞读,提高并发处理能力<br>#2.降低了死锁的概率:MVCC采用了乐观锁的方式,读取数据时并不需要加锁,对于写操作,也只锁定必要的行<br>#3.解决了快照读的问题:当我们查询数据库在某个时间点的快照时,只能看到这个时间点之前事务提交更新的结果,而不能看到这个时间点之后事务提交的更新结果</p>
<p>#其他日志<br>#日志的类型:分为二进制日志、错误日志、通用查询日志和慢查询日志.MySQL 8又新增了两种支持的日志:中继日志和数据定义语句日志<br>#作用:1.慢查询日志:记录所有执行时间超过long_query_time的所有查询,方便优化<br>#2.通用查询日志:记录所有连接的起始时间和终止时间,以及连接发送给数据库器的所有指令(可以还原操作时的具体场景)<br>#3.错误日志:记录MySQL服务的启动、运行或停止MySQL服务时出现的问题<br>#4.二进制日志:记录所有更改数据的语句,可以用于主从服务器之间的数据同步,以及服务器遇到故障时数据的无损失恢复<br>#5.中继日志:用于主从服务器架构中,从服务器用来存放主服务器二进制日志内容的一个中间文件.从服务器通过读取中继日志的内容,来同步主服务器上的操作<br>#6.数据定义语句日志:记录数据定义语句执行的元数据操作<br>#即主服务器更改内容存放到二进制文件中,从服务器通过读取二进制文件,存放到中继日志中,然后读取中继日志进行主从复制</p>
<p>#除二进制日志外,其他日志都是文本文件.默认情况下,所有日志创建于MySQL数据目录中</p>
<p>#日志的弊端:<br>#1.日志功能会降低MySQL数据库的性能(花费很多时间记录日志)<br>#2.日志会占用大量的磁盘空间.对于用户非常大、操作非常频繁的数据库,日志文件需要的存储空间设置比数据库文件需要的存储空间还要大</p>
<p>#查看通用查询日志的参数情况(开启状态(默认为不开启)和文件位置)<br>show  variables like ‘%general%’;<br>show variables like ‘general_log%’;<br>#错误日志是默认开启的,并且不能关闭<br>#查看错误日志的相关参数<br>show variables like ‘log_err%’;</p>
<p>#二进制日志(bin log)<br>#也叫变更日志.它记录了数据库所有执行的DDL和DML等数据库更新事件的语句,但是不包含没有修改任何数据的语句(如数据查询语句select、show等),它以事件形式记录保持在二进制文件中<br>#主要应用场景:<br>#1.用于数据恢复,如果MySQL数据库意外停止,可以通过二进制日志文件来查看用户执行了哪些操作,对数据库服务器文件做了哪些修改,然后根据二进制文件中的记录来恢复数据库服务器<br>#2.用于数据复制,由于日志的延续性和时效性,主机把它的二进制日志传递给从机来达到主从数据一致性的目的</p>
<p>#MySQL数据库的数据备份、主备、主主、主从都离不开二进制文件,需要依靠二进制文件来同步数据,保证数据一致性<br>#查看二进制日志文件的默认参数(默认是开启的)<br>show variables like ‘log_bin%’;<br>#日志文件最好和数据库文件分开！</p>
<p>#查看当前二进制日志文件列表以及大小<br>show binary logs;<br>#查看binlog日志文件(全部文件内容)的内容信息<br>show binlog events;<br>#查看指定文件的内容信息(在这里为binlog.000043)<br>show binlog events in ‘binlog.000050’;<br>#生成一个存储将要恢复数据的信息<br>flush logs;<br>#查看binlog的默认格式(默认为ROW格式),除此之外,binlog还有2种格式,分别为Statement和Mixed<br>show variables like  ‘binlog_format’;<br>use ISM;<br>show tables;<br>select * from book;<br>insert into book VALUES(11,’我的’,’你的’,1111),(12,’我的’,’你的’,101),(12,’我的’,’你的’,11;<br>#可以使用binlog进行数据的恢复</p>
<p>#删除二进制日志<br>#MySQL的二进制文件可以配置自动删除,同时MySQL也提供了安全的手动删除二进制文件的方法<br>#1.Purge master  logs:删除指定日志文件<br>#语法如下:Purge{master|binary} logs to ‘指定日志文件名’<br>         #Purge{master|binary} logs before ‘指定日期’<br>#2.reset master:删除所有二进制日志文件<br>#使用了reset maser语句,清空所有的binlog日志,MySQL会重新创建二进制文件,新的日志文件扩展名将重新从000001开始编号,慎用!</p>
<p>#binlog与redolog对比<br>#1.redo log是物理日志,记录内容是’在某个数据页上做了什么修改’,属于InnoDB存储引擎层产生的<br>#2.而binlog是逻辑日志,记录内容是语句的原始逻辑,类似于’给ID&#x3D;2这一行的c字段加1’,属于MySQL Server层<br>#3.虽然它们都属于持久化的保证,但是侧重点不同:<br>#redo log让InnoDB存储引擎拥有了崩溃恢复能力<br>#binlog保证了MySQL集群架构的数据一致性</p>
<p>#两阶段提交<br>#在执行更新语句过程,以基本的事务为单位,redo log在事务执行过程中可以不断写入,而binlog只有在提交事务时才写入,所以redo log与binlog的写入时机不一样</p>
<p>#使用两阶段提交后(即将redo log分为2个阶段,为prepare阶段和commit阶段,而binlog在redo log阶段之前),这样写入binlog时发生异常也不会影响,因为MySQL根据redo log日志恢复数据时,发现redo log还处于prepare阶段,并且没有对应binlog日志.就会回滚该事务,从而有效的解决了主从数据不一致的情况</p>
<p>#另一个场景,redo log设置commit阶段发生异常,那会不会回滚事务呢?<br>#并不会回滚事务,当检测到redo log已经commit或者写入了binlog的时候,事务都会正常的提交</p>
<p>#中继日志<br>#中继日志只在主从服务器架构的从服务器上存在.为了保证数据的一致性,主服务器将内容写二进制文件,从服务器读取中继日志保证数据的一致性</p>
<p>#主从复制的作用:1.读写分离;2.数据备份;3.具有高可用性</p>
<p>#主从复制的原理:三个线程问题:<br>#1.二进制日志转储线程:是一个主库线程.当从库线程连接的时候,主库可以将二进制日志发送给从库,当主库读取事情的时候,会在二进制文件(Binlog)上加锁,读取完成之后,再将锁释放掉<br>#2.从库I&#x2F;O线程:会连接到主库,向主库发送请求更新Binlog.这时从库的I&#x2F;O线程就可以读到主库的二进制日志转储线程发送的Binlog更新部分,并且拷贝到本地的中继日志<br>#3.从库SQL线程会读取从库中的中继日志,并且执行日志中的事件,将从库中的数据与主库保持同步</p>
<p>#复制三步骤:<br>#步骤1:Master(主机)将写操作记录到二进制文件.这些记录叫做二进制日志事件<br>#步骤2:Slave(从机)将主机的二进制拷贝到它的中继日志中<br>#步骤3:从机重做中继日志中的事件,将改变应用到自己的数据库中.MySQL复制是异步的并且串行化的,而且重启后从接入点开始复制<br>#复制的问题:最大的问题就是延时</p>
<p>#复制的基本原则:1.每个从机只有一个主机  2.每个从机只能有唯一的服务器ID   3.每个主机可以有多个从机<a href="https://hexo.io/docs/one-command-deployment.html">https://hexo.io/docs/one-command-deployment.html</a>)</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据</tag>
      </tags>
  </entry>
</search>
