


<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>对于redis你知道多少 - 树欲静而风不止,子欲养而亲不待</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="选择有时候比努力更重要,1.Redis是单线程的!明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器
的内存和网络带宽,既然可以使用单线程来实现，就使用单线,"> 
    <meta name="author" content="枫叶"> 
    <link rel="alternative" href="atom.xml" title="树欲静而风不止,子欲养而亲不待" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="对于redis你知道多少 - 树欲静而风不止,子欲养而亲不待"/>
    <meta name="twitter:description" content="选择有时候比努力更重要,1.Redis是单线程的!明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器
的内存和网络带宽,既然可以使用单线程来实现，就使用单线,"/>
    
    
    
    
    <meta property="og:site_name" content="树欲静而风不止,子欲养而亲不待"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="对于redis你知道多少 - 树欲静而风不止,子欲养而亲不待"/>
    <meta property="og:description" content="选择有时候比努力更重要,1.Redis是单线程的!明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器
的内存和网络带宽,既然可以使用单线程来实现，就使用单线,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">
<link rel="stylesheet" href="/css/site.css">

		<!-- 代码块复制 -->
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard@latest/dist/clipboard.js"></script>
    <script>window.searchDbPath = "/search.xml";</script>


	

<!-- 点击效果 -->

<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/5MayRain/5MayRain.github.io@latest/js/fireworks.js"></script>



    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">树欲静而风不止,子欲养而亲不待</span>
    <div id="loader"></div>
    <div id="single">
    

<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">对于redis你知道多少</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
		
    </div>
	

    <div class="scrollbar"></div>


</div>

    <div class="section">
        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<!-- 帖子视图 -->


<!-- 帖子视图 -->

    <h1 class="title">对于redis你知道多少</h1>
    <div class="stuff">
        <span>九月 24, 2022</span>

        
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E6%95%B0%E6%8D%AE/" rel="tag">数据</a></li></ul>


    </div>


<!-- 更新时间 -->
<div class="updated">
    <div></div>
    <span>该文章更新于 2022.10.08</span>
</div>


<div class="article">
    <div class='main'>
        <h1 class="title">对于redis你知道多少</h1>
        <div class="stuff">
            <span>九月 24, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E6%95%B0%E6%8D%AE/" rel="tag">数据</a></li></ul>


        </div>
		
<span>
   本篇文章阅读数(刷新获取):<span id="busuanzi_value_page_pv"></span>
</span>

  
        <div class="content markdown">
            <h2 id="1-Redis是单线程的"><a href="#1-Redis是单线程的" class="headerlink" title="1.Redis是单线程的!"></a>1.Redis是单线程的!</h2><p>明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器</p>
<p>的内存和网络带宽,既然可以使用单线程来实现，就使用单线程了! 所以就使用了单线程了 !</p>
<p>Redis是C语言写的,官方提供的数据为 100000+的QPS,完全不比同样是使用key-vale的Memecache差！</p>
<h3 id="Redis为什么单线程还怎么快"><a href="#Redis为什么单线程还怎么快" class="headerlink" title="Redis为什么单线程还怎么快?"></a>Redis为什么单线程还怎么快?</h3><ol>
<li>误区1:<font color=yellow>高性能的服务器一定是多线程的</font></li>
</ol>
<p>2.误区2:<font color=yellow>多线程(CPU上下文会切换!)一定比单线程效率高!</font></p>
<h3 id="核心-redis是将所有的数据全部放在内存中的-所以说使用单线程去操作效率就是最高的"><a href="#核心-redis是将所有的数据全部放在内存中的-所以说使用单线程去操作效率就是最高的" class="headerlink" title="核心:redis是将所有的数据全部放在内存中的,所以说使用单线程去操作效率就是最高的,"></a>核心:redis是将所有的数据全部放在内存中的,所以说使用单线程去操作效率就是最高的,</h3><h4 id="多线程-CPU上下文会切换-耗时的操作-，对于内存系统来说-如果没有上下文切换效率就是最高的-多次读写都是在"><a href="#多线程-CPU上下文会切换-耗时的操作-，对于内存系统来说-如果没有上下文切换效率就是最高的-多次读写都是在" class="headerlink" title="多线程(CPU上下文会切换:耗时的操作)，对于内存系统来说,如果没有上下文切换效率就是最高的! 多次读写都是在"></a>多线程(CPU上下文会切换:耗时的操作)，对于内存系统来说,如果没有上下文切换效率就是最高的! 多次读写都是在</h4><h4 id="一个CPU上的-在内存情况下-这个就是最佳的方案"><a href="#一个CPU上的-在内存情况下-这个就是最佳的方案" class="headerlink" title="一个CPU上的,在内存情况下,这个就是最佳的方案!"></a>一个CPU上的,在内存情况下,这个就是最佳的方案!</h4><h2 id="2-五大基本数据类型"><a href="#2-五大基本数据类型" class="headerlink" title="2.五大基本数据类型"></a>2.五大基本数据类型</h2><h3 id="1-String字符串类型详解"><a href="#1-String字符串类型详解" class="headerlink" title="1.String字符串类型详解"></a>1.String字符串类型详解</h3><ul>
<li><p>get key vlaue <font color=yellow>设置键和值</font></p>
</li>
<li><p>exist key <font color=yellow>查看是否有这个键</font></p>
</li>
<li><p>expire 键 时间 <font color=yellow>让这个键在多少时间失效  (可以设置一个定时失效功能,比如验证码或者二维码等)</font></p>
</li>
<li><p>setex(set with expire) <font color=yellow>设置值并设置过期时间</font></p>
</li>
<li><p>setnx(set with noexit) <font color=yellow>设置一个不存在的键的值</font></p>
</li>
<li><p>ttl 键 <font color=yellow>查看这个键还有多少失效</font></p>
</li>
<li><p>keys *<font color=yellow>查看所有的键</font></p>
</li>
<li><p>append 键 +值  <font color=yellow>在这个键的末尾追加值(如果这个键没有的话就会自动创建)</font></p>
</li>
<li><p>incr 键 <font color=yellow>让这个键的值自增(incrby  键 数目 自增多少数目)</font></p>
</li>
<li><p>decr 键  <font color=yellow>让这个键的值自减</font></p>
</li>
<li><p>getrange 键 start and end <font color=yellow>取开始和结尾的值</font> </p>
</li>
<li><p>setrange 键  <font color=yellow>第几个值  要替换的结果  替换字符串</font></p>
</li>
<li><p>mset <font color=yellow>可以同时设置多个键和值</font></p>
</li>
<li><p>mget <font color=yellow>可以同时获取多的值</font></p>
</li>
</ul>
<h4 id="扩展-对象"><a href="#扩展-对象" class="headerlink" title="扩展:对象"></a>扩展:对象</h4><p>set user:1{name:zhangsan,age:3)  <font color=yellow>设置一个user:1 对象 值为  json字符串来保存一个对象!</font></p>
<p><font color=yellow>这里的key是一个巧妙的设计</font>: user:{id}:{filed}  ,如此设计在Redis中是完全OK的</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mest user:<span class="hljs-number">1</span>:name zhangsan  user:<span class="hljs-number">1</span> age <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>getset <font color=yellow>先get后set</font></p>
<p>String类似的使用场景:value除了是我们的字符串还可以是我们的数字！</p>
<p>String字符串类型可能会用的<font color=yellow>场景</font>:</p>
<ul>
<li><font color=yellow>计数器</font></li>
<li><font color=yellow>统计多单位的数量</font></li>
<li><font color=yellow>粉丝数</font></li>
<li><font color=yellow>对象缓存存储</font></li>
</ul>
<h3 id="2-List列表类型详讲"><a href="#2-List列表类型详讲" class="headerlink" title="2.List列表类型详讲"></a>2.List列表类型详讲</h3><ul>
<li>lpush list one <font color=yellow>(将一个值或者多个值,插入到列表头部(左))</font></li>
<li>rpush list right<font color=yellow>将一个值或者多个值,插入到列表尾部(右))</font></li>
<li>lrange list 0 -1 <font color=yellow>获取list中的值</font></li>
<li>lpop <font color=yellow>移除左边的值</font>  rpop <font color=yellow>移除右边的值</font></li>
<li>lindex list 下标(从0开始的)  <font color=yellow>获取索引下标对应的值</font></li>
<li>llen list <font color=yellow>返回列表的长度</font></li>
<li>lrem list (个数)  特定的值  <font color=yellow>移除list列表中特定的值</font></li>
<li>ltrim list  start end <font color=yellow>截取从start到end中值(索引为小标0开始)</font></li>
<li>rpoplpush <font color=yellow>将list中最后一个值移除到另外一个列表中(如果这个列表不存在则会创建)</font></li>
<li>lset list 下标 值  <font color=yellow>将列表中指定的下标值替换为给定的值（更新操作）如果list不存在则会报错,存在的话会进行更新操作</font></li>
<li>linsert  lsit  list中的某个具体的值  after或者before  要插入的值  <font color=yellow>在list中的某个具体的值中向前或者向后插入要插入的值</font></li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1.他实际上是一个链表,before Node after ,left ,right 都可以插入值<br>2.如果key不存在,创建新的链表<br>3.如果key存在,新增内容<br>4.如果移除了所有值,空链表,也代表不存在<br>5.在两边插入或者改动值,效率最高! 中间元素,相对来说效率会低一点</p>
<p><font color=yellow>消息排队！ 消息队列(Lpush Rpop) ，栈(LPush Lpop)</font></p>
<h3 id="3-Set集合类型详讲"><a href="#3-Set集合类型详讲" class="headerlink" title="3.Set集合类型详讲"></a>3.Set集合类型详讲</h3><ul>
<li>sadd  set  值  <font color=yellow>添加一个值到set集合中</font></li>
<li>smembers set <font color=yellow>展示所有set集合中的值</font></li>
<li>sismember  set  值  <font color=yellow>查看set集合中是否有这个值</font></li>
<li>scard set  <font color=yellow>查看set集合中有多少个元素</font></li>
<li>srem set 值  <font color=yellow>移除指定的值</font></li>
<li>srandmember set[个数]  <font color=yellow>随机抽取set集合中元素[可以指定个数]</font></li>
<li>spop set <font color=yellow>随机删除一些set集合中的元素</font></li>
<li>smove set1 set2 set1中的值  <font color=yellow>将set1集合中的值移动到set2中</font></li>
<li>sdiff set1 set2  <font color=yellow>显示set1中有set2中没有的元素(差集)</font></li>
<li>sinter set1 set2 <font color=yellow>显示set1和set2中公共的部分(交集)</font>【<font color=yellow>可以得到b站或者其他网站的共同关注的博主(2个账号)</font>】</li>
<li>sunion set1 set2 <font color=yellow>显示并集</font>(<font color=yellow>虎牙直播的一个用户所关注的全部放在一个set集合中,主播的粉丝数也放在一个集合中</font>)</li>
</ul>
<p>场景:<font color=yellow>共同关注</font>，<font color=yellow>共同爱好</font> ,<font color=yellow>二度好友</font>，<font color=yellow>推荐好友!</font>（六度分割理论） </p>
<h3 id="4-Hash（哈希）详讲（本质和String没有什么区别-这是hash是key-vlaue）"><a href="#4-Hash（哈希）详讲（本质和String没有什么区别-这是hash是key-vlaue）" class="headerlink" title="4.Hash（哈希）详讲（本质和String没有什么区别,这是hash是key-vlaue）"></a>4.Hash（哈希）详讲（本质和String没有什么区别,这是hash是key-vlaue）</h3><h4 id="相当于Map集合-key-map"><a href="#相当于Map集合-key-map" class="headerlink" title="相当于Map集合(key-map)"></a>相当于Map集合(key-map)</h4><ul>
<li>hset  hash  键 值   <font color=yellow>添加一个值</font></li>
<li>hget  hash  键     <font color=yellow>获取一个值</font></li>
<li>hmset hash 键 值  键1 值1  <font color=yellow>添加多个值</font></li>
<li>hmget hash  键  键1  <font color=yellow>获取多个值</font></li>
<li>hgetall <font color=yellow>获取一个hash中的所有值</font></li>
<li>hdel  <font color=yellow>删除一个hash中的key-vlaue</font></li>
<li>hlen <font color=yellow>返回hash中的长度</font></li>
<li>hexists  hash  键   <font color=yellow>查看hash中的键是否存在</font></li>
<li>hkeys  hash  <font color=yellow>获取hash中所有的键</font></li>
<li>hvals  hash<font color=yellow>获取hash中所有的值</font></li>
<li>hincrby  hash   键   数值   <font color=yellow>所对应的键自增数值</font></li>
<li>hdecrby hash  键   数值    <font color=yellow>所对应的键自减数值</font></li>
</ul>
<p>实际场景:<font color=yellow>hash变更的数据user name age,尤其是用户信息之类的,经常变动的信息！hash更适合于对象的存储,<br>String更加适合字符串存储</font></p>
<h3 id="5-Zset（有序集合）"><a href="#5-Zset（有序集合）" class="headerlink" title="5.Zset（有序集合）"></a>5.Zset（有序集合）</h3><ul>
<li><font color=yellow>在set的基础上,增加了一个值&#x3D;&#x3D;,set k1 v1  zset  k1  score v1  </font></li>
<li>zadd    zset    1（数字）  值      <font color=yellow>添加元素</font></li>
<li>zrange  zset 0  -1  <font color=yellow>取全部</font></li>
<li>zrangebyscore  zset  -inf  +inf（withscores）   <font color=yellow>将集合中的元素全部排序好取出(从小到大)（带成绩数字）</font></li>
<li>zrevrange zset  0 -1 <font color=yellow>将集合中的元素全部排序好取出(从大到小)</font></li>
<li>zrem  zset 值  <font color=yellow>移除zset中的值</font></li>
<li>zcard  zset <font color=yellow>查看zset集合中的个数</font></li>
<li>zcount zset  start end <font color=yellow>(获取start到end区间的指定数量是多少)</font></li>
</ul>
<p>案例思路:<font color=yellow>set排序</font> <font color=yellow>存储班级成绩表</font>,<font color=yellow>工作表排序!</font><br>普通消息, 1  重要消息  2 ,<font color=yellow>带权重进行判断</font><br><font color=yellow>排行榜应用实现</font>,<font color=yellow>取Top N测试!</font></p>
<h2 id="3-三种特殊数据类型"><a href="#3-三种特殊数据类型" class="headerlink" title="3.三种特殊数据类型"></a>3.三种特殊数据类型</h2><h3 id="1-geoadd-添加地理位置"><a href="#1-geoadd-添加地理位置" class="headerlink" title="1.geoadd  添加地理位置"></a>1.geoadd  添加地理位置</h3><ul>
<li>有效的经度从-180到180度</li>
<li>有效的纬度从-85到85</li>
<li><font color=yellow>规则:两级无法直接添加,我们一般会下载城市数据,直接通过java程序一次性导入！</font></li>
<li>参数  key 值 (纬度.经度.名称)</li>
<li>geoadd   chain:city   116.40 39.90 beijin  </li>
<li>geopos  chain:city beijin <font color=yellow>从值中获取具体的经纬度(获取当前定位:一定是一个坐标值)</font></li>
<li>geodist chain:city  beijing shanghai  <font color=yellow>得出beijing到shanghai的距离(默认单位为米) 可以加单位</font>                                                        单位：m 米  km 千米  mi 英里  ft 英尺</li>
<li>georadius <font color=yellow>以给定的经纬度为中心,找出某一半径内的元素</font></li>
<li><font color=yellow>我附件的人?(获取所有附件的人的地址,定位!) 通过半径来查询</font></li>
<li>georadius chain:city 110 30  500km (withdist)(withcoord)(count 数字) <font color=yellow>查看经度110 纬度30 方圆500千米之内的元素(集合中的)(带距离)  （带经纬度）(查询指定的数量)</font></li>
<li>georadiusbymember <font color=yellow>根据元素名找出半径内的元素</font></li>
<li>georadiusbymember chain:city  beijing  1000 km </li>
<li>geohash命令  <font color=yellow>返回一个或者多个位置元素的geohash表示(不常用)</font>  <font color=yellow>该命令将返回11个字符的geohash字符串</font></li>
<li>geohash chain:city beijing   <font color=yellow>将二维的经纬度转换为一维的字符串,如果两个字符串越接近,那么则距离越近</font></li>
<li><font color=yellow>geo底层的实现原理其实就是zset 我们可以使用zset命令来操作geo(进行删除或者别的)</font></li>
</ul>
<h3 id="2-Hyperloglog"><a href="#2-Hyperloglog" class="headerlink" title="2.Hyperloglog"></a>2.Hyperloglog</h3><h3 id="什么是基数"><a href="#什么是基数" class="headerlink" title="什么是基数?"></a>什么是基数?</h3><p>A{1,3,5,7,8,7}<br>B{1,3,5,7,8}  <font color=yellow>基数(不重复的元素),可以接受误差</font></p>
<p>简介</p>
<p>Redis 2.8.9版本就更新了Hyperloglog数据结构<br>Redis Hyperloglog 基数统计的算法<br>优点:<font color=yellow>占用的内存是固定</font>,2^64不同的元素的技术,只需要废12kb内存!如果要从内存的角度来比较的话Hyperloglog首选<br>网页的UV(<font color=yellow>一个人访问一个网站多次,但是还是算一个人</font>)<br>传统的方式,<font color=yellow>set保存用户的id，然后就可以统计set中的元素数量作为标准判断</font><br>这个方式如果保存大量的用户id,就会比较麻烦,我们的<font color=yellow>目的是为了计数</font>,而<font color=yellow>不是保存用户id</font><br>0.81%错误率   统计UV任务,可以忽略不计的<br>pfadd  myhyp   a b c d e f  添加元素<br>pfadd  myhyp1   a b c d e f   e  g<br>pfcount  myhyp  统计数目<br>pfmerge  myhyp2 myhyp myhyp1  <font color=yellow>合并(并集)到myhyp2 (重复的元素不算)</font></p>
<p><font color=yellow>如果允许容错,那么就一定可以使用Hyperloglog</font><br><font color=yellow>如果不允许容错,就使用set或者自己的数据类型即可</font></p>
<h3 id="3-Bitmaps"><a href="#3-Bitmaps" class="headerlink" title="3.Bitmaps"></a>3.Bitmaps</h3><h4 id="位存储"><a href="#位存储" class="headerlink" title="位存储"></a>位存储</h4><p><font color=yellow>统计用户信息</font>,<font color=yellow>活跃,不活跃！</font> <font color=yellow>登录，未登入 ！</font><font color=yellow>打卡  两个状态</font>  都可以使用Bitmaps！<br>Bitmaps位图,数据结构！<font color=yellow>都是操作二进制位来进行记录</font>,就<font color=yellow>只有0和1 两个状态</font><br>用bitmap来<font color=yellow>记录周一到周日的打卡情况</font><br>setbit sgin 1 0   setbit sgin 2  1   setbit sgin 3 0  …..<br>周一:0  周二:1  周三:0 …<br>查看某一天的打卡情况  getbit sgin 2  — 1   已经打卡<br><font color=yellow>bitcount sgin 统计打卡的天数</font></p>
<h2 id="4-事务"><a href="#4-事务" class="headerlink" title="4.事务"></a>4.事务</h2><p><font color=yellow>Redis单条命令是保证原子性的</font>,但是<font color=yellow>事务不保证原子性</font><br><font color=yellow>Redis事务本质:一组命令的集合</font>! <font color=yellow>一个事务中所有命令都会被序列化</font>,在事务执行过程中,会依照顺序执行<br>一次性,顺序性,排他性!执行一些列的命令!<br>—队列 set set set 执行—<br><font color=yellow>Redis事务没有隔离级别的概念!</font><br>所有的命令在事务中,并没有直接被执行！只有发起执行命令的时候才会执行<br>redis的事务:</p>
<ul>
<li>开始事务（multi）</li>
<li>命令入队（自动完成）</li>
<li>执行事务（exec）<br>放弃事务 discard</li>
</ul>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">multi   <span class="hljs-comment">#开启事务</span><br><span class="hljs-built_in">set</span> k1 v1 <br><span class="hljs-built_in">set</span> k2 v2 <br>get k2 <br><span class="hljs-built_in">set</span> k3 v3<br><span class="hljs-built_in">exec</span>    <span class="hljs-comment">#执行事务</span><br></code></pre></td></tr></table></figure>



<p>编译型异常(<font color=yellow>代码有问题!命令错误！</font>),<font color=yellow>事务中所有的命令都不会被执行</font></p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2 <br>QUEUED<br>127.0.0.1:6379&gt; getset k3   <span class="hljs-comment">#命令错误,事务中的所有的命令都不会被执行</span><br>(error) ERR wrong number of arguments <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;getset&#x27;</span> <span class="hljs-built_in">command</span>  <br>127.0.0.1:6379&gt; get k2<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>(error) EXECABORT Transaction discarded because of previous errors.<br>127.0.0.1:6379&gt; get k2<br><span class="hljs-string">&quot;v2&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>

<p>运行时异常(I&#x2F;0)，<font color=yellow>如果事务队列中存在语法性错误</font>,那么执行命令的时候,<font color=yellow>其他命令是可以正常执行的</font>,错误命令抛出异常</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; incr k1<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2<br>QUEUED<br>127.0.0.1:6379&gt; get k2<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>1) (error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range    <span class="hljs-comment">#这里是字符串不能做为自增的对象,运行时发生了异常</span><br>2) OK<br>3) <span class="hljs-string">&quot;v2&quot;</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></table></figure>



<h3 id="监控-Watch-面试常问"><a href="#监控-Watch-面试常问" class="headerlink" title="监控!Watch(面试常问)"></a>监控!Watch(面试常问)</h3><h3 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1.悲观锁:"></a>1.悲观锁:</h3><p>很悲观,认为什么时候都会出问题,无论做什么都会加锁!  </p>
<h3 id="2-乐观锁："><a href="#2-乐观锁：" class="headerlink" title="2.乐观锁："></a>2.乐观锁：</h3><p>redis大多数是基于<strong>数据版本(version)的记录</strong>机制实现的。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表添加一个version字段来实现。在读取数据时，将此版本号一同读出，之后更新时对此版本号加1。此时，将提交数据的版本号与数据库表对应记录的当前版本号进行对比，<strong>如果提交的数据版本号大于数据库当前版本号，则予以更新</strong>，否则认为是过期数据。</p>
<ul>
<li>很乐观，认为什么时候都不会出问题,无论做什么都不会加锁! 更新数据的时候去判断一下,在此期间是否有人修<br>改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<p><font color=yellow>单线程</font>修改值可以成功</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; watch money<br>OK<br>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; decrby money 20<br>QUEUED<br>127.0.0.1:6379&gt; incrby out 20<br>QUEUED<br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span><br>1) (<span class="hljs-built_in">integer</span>) 80<br>2) (<span class="hljs-built_in">integer</span>) 20<br><span class="hljs-comment">#监视成功</span><br></code></pre></td></tr></table></figure>

<p>Redis的视:watch</p>
<p><strong>watch,监视键值对，作用时如果事务提交exec时发现监视的监视对发生变化，事务将被取消。</strong></p>
<p><font color=yellow>测试多线程修改值,使用watch可以当做redis的乐观锁操作</font> : 修改值会失败</p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20220927164638199.png" alt="image-20220927164638199"></p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">Redis中对乐观锁的实现： 假设有一个age的key，我们开启两个session来对age进行赋值操作。<br>session1：<br>127.0.0.1:6379&gt; get age <br><span class="hljs-string">&quot;10&quot;</span> <br>127.0.0.1:6379&gt; watch age <span class="hljs-comment">#打开对age键的监控（监控其他操作是否对age键有修改操作） </span><br>OK<br>127.0.0.1:6379&gt; multi <span class="hljs-comment">#开启事务上下文 </span><br>OK<br><br>session2： <br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> age 20 <br>OK<br>127.0.0.1:6379&gt; get age <br><span class="hljs-string">&quot;20&quot;</span><br><br>再看session1： <br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> age 30 <span class="hljs-comment">#在session2中操作age后，我们在session1中继续操作age</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span> <span class="hljs-comment">#执行事务 返回nil 事务执行不成功。 </span><br>(nil) <br>127.0.0.1:6379&gt; get age <br><span class="hljs-string">&quot;20&quot;</span><br></code></pre></td></tr></table></figure>

<p>在这里我们发现事务不能执行成功，这就是因为session1中的<strong>数据版本已经小于数据库中的数据版本</strong>。这就是Redis的乐观锁。</p>
<p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/20201115115331630.png" alt="在这里插入图片描述"></p>
<h2 id="5-Jedis"><a href="#5-Jedis" class="headerlink" title="5.Jedis"></a>5.Jedis</h2><p><font color=yellow>我们要使用java来操作Redis</font><br>什么是Jedis: <font color=yellow>是Redis官方推荐的java连接开发工具! 使用java操作Redis中间件!</font> 如果你要使用java操作Redis<br>那么一定要对Jedis十分的熟悉</p>
<p>1.测试</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>           &lt;groupId&gt;redis.clients&lt;/groupId&gt;<br>           &lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>           &lt;version&gt;<span class="hljs-number">2.9</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>       &lt;/dependency&gt;<br>       &lt;dependency&gt;<br>           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>           &lt;artifactId&gt;fastjson&lt;/artifactId&gt;<br>           &lt;version&gt;<span class="hljs-number">1.2</span><span class="hljs-number">.76</span>&lt;/version&gt;<br>       &lt;/dependency&gt;<br> <span class="hljs-comment">///导入相关依赖</span><br></code></pre></td></tr></table></figure>

<p>2.编码测试:</p>
<ul>
<li>连接数据库</li>
<li>操作命令</li>
<li>断开连接</li>
</ul>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test_ping</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">6379</span>);<br>        System.out.println(jedis.ping());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果为PONG则说明ping通了</span><br></code></pre></td></tr></table></figure>



<h2 id="6-SpringBoot整合"><a href="#6-SpringBoot整合" class="headerlink" title="6.SpringBoot整合"></a>6.SpringBoot整合</h2><p>SpringBoot操作数据:spring-data  jpa jdbc  mongodb redis<br>SpringData也是和SpringBoot齐名的项目<br>说明︰在SpringBoot2.x之后，原来使用的<strong>jedis被替换为了lettuce?</strong><br>jedis :<font color=yellow>采用的直连</font>，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池!更像 BIO 模式<br>lettuce:<font color=yellow>采用netty</font>，实例可以再多个线程中进行共享，不存在线程不安全的情况!可以减少线程数据了,更像 NIO 模式</p>
<p><strong>源码分析:</strong></p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>   <span class="hljs-meta">@ConditionalOnMissingBean(</span><br><span class="hljs-meta">       name = &#123;&quot;redisTemplate&quot;&#125;</span><br><span class="hljs-meta">   )</span> <span class="hljs-comment">//当没有配置这个才会生效</span><br>   <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>   <span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>       <span class="hljs-comment">//默认的RedisTemplate没有过多的设置,redis对象都需要序列化!</span><br>       <span class="hljs-comment">//两个泛型都是Object,Object的类型,我们后使用需要强制转换&lt;String,Object&gt;</span><br>       RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>();<br>       template.setConnectionFactory(redisConnectionFactory);<br>       <span class="hljs-keyword">return</span> template;<br>   &#125;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">//由于String是redis中最常用的类型,所以单独提取出来一个</span><br>   <span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>   <span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title function_">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisTemplate</span>(redisConnectionFactory);<br>   &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>整合测试一下</p>
</blockquote>
<p>1.导入依赖</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>           &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>       &lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<p>2.配置连接</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">#配置主机<br>spring.redis.host=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>#配置端口号<br>spring.redis.port=<span class="hljs-number">6379</span>   <br></code></pre></td></tr></table></figure>

<p>3.测试</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.springboot_redis;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnection;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootRedisApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span>  RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//redisTemplate  操作不同的数据类型 api和我们的指令是一样的</span><br>        <span class="hljs-comment">//opsForValue  操作字符串 类似String</span><br>        <span class="hljs-comment">//opsForList   操作list  opsForHash</span><br>        redisTemplate.opsForList().leftPush(<span class="hljs-string">&quot;list&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>);<br>        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">&quot;*&quot;</span>));<br>        redisTemplate.opsForHyperLogLog();<br>        redisTemplate.opsForZSet();<br>        <span class="hljs-comment">//获取连接</span><br>        <span class="hljs-type">RedisConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> redisTemplate.getConnectionFactory().getConnection();<br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;张启松&quot;</span>);<br>        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可序列化</p>
<figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">RedisSerializer</span> <span class="hljs-variable">keySerializer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">RedisSerializer</span> <span class="hljs-variable">valueSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">RedisSerializer</span> <span class="hljs-variable">hashKeySerializer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">RedisSerializer</span> <span class="hljs-variable">hashValueSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20220927213010562.png" alt="image-20220927213010562"></p>
<p>默认的序列化是<font color=yellow>JDK序列化</font>的,所以要想自己想要的数据要自定义序列化类</p>
<p>如果没有对java对象序列化的话,引用的话会报错</p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20220928194027161.png" alt="image-20220928194027161"></p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20220928194017202.png" alt="image-20220928194017202"></p>
<p>对对象进行序列化操作,只需要进行 <font color=yellow>implements Serializable</font>即可</p>
<h4 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h4><figure class="highlight java"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Config;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br>    <span class="hljs-comment">//编写自己的redsiTemplate</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;String, Object&gt;();<br>        template.setConnectionFactory(factory);<br><br>        <span class="hljs-comment">// 序列化配置 解析任意对象</span><br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-comment">// json序列化利用ObjectMapper进行转义</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        <span class="hljs-comment">// 2.序列化String类型</span><br>        <span class="hljs-type">StringRedisSerializer</span> <span class="hljs-variable">stringRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br><br>        <span class="hljs-comment">// key采用String的序列化方式</span><br>        template.setKeySerializer(stringRedisSerializer);<br>        <span class="hljs-comment">// hash的key也采用String的序列化方式</span><br>        template.setHashKeySerializer(stringRedisSerializer);<br>        <span class="hljs-comment">// value序列化方式采用jackson</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">// hash的value序列化方式采用jackson</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        template.afterPropertiesSet();<br><br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-Redis-conf"><a href="#7-Redis-conf" class="headerlink" title="7.Redis.conf"></a>7.Redis.conf</h2><ul>
<li>INCLUDES 组合多个配置</li>
<li>GENERAL 通用配置</li>
<li>SNAPSHOTTING 快照,用于持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 <strong>.rdb .aof</strong></li>
<li>REPLICATION 主从复制</li>
<li>SECURITY  安全问题(可以设置redis的登入密码,默认是没有密码的)</li>
<li>LIMITS  限制连接客户端的最大数量以及内存上限后的处理等</li>
<li>APPEND ONLY MODE   aof配置</li>
</ul>
<blockquote>
<p>容量单位不区分大小写，G和GB有区别</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020051321485460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<blockquote>
<p>可以使用 include 组合多个配置问题</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214902552.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>网络配置</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214912813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>日志输出级别</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214923678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<blockquote>
<p>日志输出文件</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214933713.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>持久化规则</p>
</blockquote>
<p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p>
<p>持久化方式：</p>
<ul>
<li>RDB</li>
<li>AOF</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200513214944964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>RDB文件相关</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513214955679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200513215006207.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>主从复制</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513215016371.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Security模块中进行密码设置</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200513215026143.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>客户端连接相关</p>
</blockquote>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">maxclients 10000  最大客户端数量<br>maxmemory &lt;bytes&gt; 最大内存限制<br>maxmemory-policy noeviction <span class="hljs-comment"># 内存达到限制值的处理策略</span><br>123<br></code></pre></td></tr></table></figure>

<p>redis 中的<strong>默认</strong>的过期策略是 <strong>volatile-lru</strong> 。</p>
<p><strong>设置方式</strong></p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">config <span class="hljs-built_in">set</span> maxmemory-policy volatile-lru <br></code></pre></td></tr></table></figure>

<p><strong>maxmemory-policy 六种方式</strong></p>
<p><strong>1、volatile-lru：</strong>只对设置了过期时间的key进行LRU（默认值）</p>
<p><strong>2、allkeys-lru ：</strong> 删除lru算法的key</p>
<p><strong>3、volatile-random：</strong>随机删除即将过期key</p>
<p><strong>4、allkeys-random：</strong>随机删除</p>
<p><strong>5、volatile-ttl ：</strong> 删除即将过期的</p>
<p><strong>6、noeviction ：</strong> 永不过期，返回错误</p>
<p> <strong>APPEND ONLY 模式 aof配置</strong></p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">appendonly no	<span class="hljs-comment"># 默认不开启aof模式，默认使用rdb方式持久化，几乎在所有情况下rdb够用</span><br><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span> <span class="hljs-comment"># 持久化文件的名字</span><br><br><span class="hljs-comment"># appendfsync always	# 每次修改都会同步，消耗性能</span><br>appendfsync everysec	<span class="hljs-comment"># 每秒都同步一次 sync，可能会丢失这1s数据</span><br><span class="hljs-comment"># appendfsync no		# 不执行同步，这时候操作系统自己同步数据，速度最快</span><br></code></pre></td></tr></table></figure>

<h2 id="8-Redis持久化"><a href="#8-Redis持久化" class="headerlink" title="8.Redis持久化"></a>8.Redis持久化</h2><h4 id="RDB（Redis-Database）"><a href="#RDB（Redis-Database）" class="headerlink" title="RDB（Redis Database）"></a>RDB（Redis Database）</h4><p><img src="https://img-blog.csdnimg.cn/2020051321523151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在主从复制中，rdb就是备用的！在从机上面</p>
<p>面试和工作，持久化必须是重点</p>
<p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以redis提供了持久化功能</p>
<p>在指定时间间隔内将内存中的数据集写入磁盘，也就是Snapshot快照，它恢复时是将文件直接读到内存里</p>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将书局写入到一个临时文件中，待持久化过程都结束了。再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF更加高效，<strong>RDB的缺点是最后一次持久化后的数据可能丢失。</strong>我们默认的就是RDB，一般情况下不需要修改这个配置。</p>
<p><font color=yellow>RDB保存的文件是dump.rdb</font>都是在我们配置文件中的快照中进行配置的</p>
<p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/490e34c578bff1f061a953356ab55865.png" alt="image"></p>
<p>自己测试一次，60s内修改5次，就会触发rdb操作</p>
<p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/1b9128e01b714fbfdf56c11a5bd29699.png" alt="image"></p>
<p><strong>flushall默认产生一个dump.rdb文件</strong></p>
<h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><ul>
<li>save规则满足的情况下，会自动触发rdb规则</li>
<li>执行flushall命令也会触发rdb规则</li>
<li>退出redis，也会产生rdb</li>
</ul>
<p><strong>备份就自动生成dump.rdb</strong><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/c6c0d341d5904b5708753742517786f9.png" alt="image"></p>
<h4 id="如何恢复rdb文件"><a href="#如何恢复rdb文件" class="headerlink" title="如何恢复rdb文件"></a>如何恢复rdb文件</h4><ol>
<li><p>只需要将<strong>rdb文件放在redis的启动目录下</strong>就可以了，redis启动的时候会自动检查dump.rdb文件恢复</p>
</li>
<li><p>查看需要存在的位置</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; config get <span class="hljs-built_in">dir</span><br>1) <span class="hljs-string">&quot;dir&quot;</span><br>2) <span class="hljs-string">&quot;/usr/local/redis-6.0.6/bin&quot;</span>	<span class="hljs-comment">#如果在这个目录下存在dump.rdb文件，启动就会自动恢复其中的数据</span><br></code></pre></td></tr></table></figure>

<p>几乎他自己的默认配置就够用了，但是我们还是学习</p>
<p>有时候在生产环境，我们会将这个文件进行备份</p>
</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li>适合大规模的数据恢复！dump.rdb</li>
<li>如果对数据完整性不高！</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>需要一定的时间间隔进行操作，如果redis意外宕机了，那么最后一次修改的数据就没有了</li>
<li>fork进程的时候会占用一定的内存空间</li>
</ol>
<h4 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h4><p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/3eb0e5a9501dfa3228e646cb18d34e44.png" alt="img"></p>
<p>将我们的所有命令都记录下来，history，恢复的时候把这个文件全部再执行一遍</p>
<p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件，但是不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从签到后执行一次以完成数据的恢复工作</p>
<p><strong>AOF保存的是appendonly.aof文件</strong></p>
<p>默认是不开启的，我们需要手动进行配置，我们只需要将appendonly改为yes即可</p>
<p>重启redis就可以生效了</p>
<p><strong>如果这个aof文件有错位，这时候redis是启动不起来的</strong>，我们需要修复这个aof文件</p>
<p>redis给我们提供了<strong>redis-check-aof –fix appendonly.aof</strong>来进行appendonly.aof的修复</p>
<p>如果文件正常，重启就可以直接恢复了</p>
<p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/0d004c953c67eb5e72b536d4229866ff.png" alt="image"></p>
<h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><p><strong>优点：</strong></p>
<ol>
<li>每一次修改都同步，文件完整性更加好</li>
<li>每同步一次，可能会丢失一秒的数据</li>
<li>从不同步</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>相对于数据文件来说，aof远远大于rdb，修复速度也比rdb慢</li>
<li>AOF运行效率也要比rdb慢，redis默认的配置就是rdb持久化</li>
</ol>
<h4 id="重写规则说明"><a href="#重写规则说明" class="headerlink" title="重写规则说明"></a>重写规则说明</h4><p>如果aof文件大于64MB，太大了，！fork一个新的进程来将我们文件进行重写</p>
<p>aof默认就是文件的无限追加，文件会越来越大</p>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h4><p>Redis 提供了不同级别的持久化方式:</p>
<ul>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</li>
<li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</li>
<li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
<li>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
<li>最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始:</li>
</ul>
<h4 id="RDB的优点"><a href="#RDB的优点" class="headerlink" title="RDB的优点"></a><strong>RDB的优点</strong></h4><ul>
<li>RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集.</li>
<li>RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复.</li>
<li>RDB在保存RDB文件时<strong>父进程唯一需要做的就是fork出一个子进程</strong>,接下来的工作全部由子进程来做，<strong>父进程不需要再做其他IO操作</strong>，所以RDB持久化方式可以最大化redis的性能.</li>
<li>与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些.</li>
</ul>
<h4 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h4><ul>
<li>如果你希望在redis意外停止工作（例如电源中断）的情况下<strong>丢失的数据最少</strong>的话，那么<strong>RDB不适合</strong>你.虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据.</li>
<li>RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度.</li>
</ul>
<h4 id="AOF-优点"><a href="#AOF-优点" class="headerlink" title="AOF 优点"></a><strong>AOF 优点</strong></h4><ul>
<li>使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),<strong>一旦出现故障，你最多丢失1秒的数据.</strong></li>
<li>AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也<strong>可使用redis-check-aof工具修复这些问题</strong>.</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li>
</ul>
<h4 id="AOF-缺点"><a href="#AOF-缺点" class="headerlink" title="AOF 缺点"></a><strong>AOF 缺点</strong></h4><ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h4 id="RDB和AOF对比"><a href="#RDB和AOF对比" class="headerlink" title="RDB和AOF对比"></a><strong>RDB和AOF对比</strong></h4><table>
<thead>
<tr>
<th>比较</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
</tbody></table>
<h2 id="9-Redis发布订阅"><a href="#9-Redis发布订阅" class="headerlink" title="9.Redis发布订阅"></a>9.Redis发布订阅</h2><p><strong>消息队列</strong></p>
<p><strong>通信，通过队列实现</strong>: 发送者 订阅者</p>
<p>Redis 发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。微信，微博</p>
<p>Redis客户端可以订阅任意数量的频道</p>
<p>订阅&#x2F;发布消息图：</p>
<p>第一个：消息发送者，第二个：频道 第三个：消息订阅者！</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/dd6b8ef093cf55e0aa316e0a4f94a200.png" alt="image-20201105104248223"></p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513215523258.png" alt="在这里插入图片描述"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="https://img-blog.csdnimg.cn/2020051321553483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>命令：</strong></p>
<p><font color=yellow>psubcribe pattern [pattern]</font> ：订阅一个或多个符合给定模式的频道</p>
<p><font color=yellow>pubsub subcommand [argument [argument]]</font>：查看订阅与发布系统状态</p>
<p><font color=yellow>publish channel message</font>：将信息发送到指定的频道</p>
<p><font color=yellow>punsubscribe [pattern [pattern]]</font>： 退订所有给定模式的频道</p>
<p><font color=yellow>subscribe channel [channel]</font>：订阅一个或多个频道的信息</p>
<p><font color=yellow>unsubscribe [channel [channel]]</font>： 退订给定的频道</p>
<p><strong>代码实现</strong>:</p>
<h3 id="1-订阅端"><a href="#1-订阅端" class="headerlink" title="1.订阅端"></a>1.订阅端</h3><figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; SUBSCRIBE sunzhongwei 	<span class="hljs-comment"># 订阅一个sunzhongwei频道</span><br>Reading messages... (press Ctrl-C to quit)<br>1) <span class="hljs-string">&quot;subscribe&quot;</span><br>2) <span class="hljs-string">&quot;sunzhongwei&quot;</span><br>3) (<span class="hljs-built_in">integer</span>) 1<br><span class="hljs-comment"># 等待读取推送的信息</span><br>1) <span class="hljs-string">&quot;message&quot;</span>	<span class="hljs-comment">#消息</span><br>2) <span class="hljs-string">&quot;sunzhongwei&quot;</span>	<span class="hljs-comment"># 哪个频道的消息</span><br>3) <span class="hljs-string">&quot;hello,sunzhongwei&quot;</span>	<span class="hljs-comment"># 具体内容</span><br>1) <span class="hljs-string">&quot;message&quot;</span><br>2) <span class="hljs-string">&quot;sunzhongwei&quot;</span><br>3) <span class="hljs-string">&quot;hello,Redis&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="2-发送端"><a href="#2-发送端" class="headerlink" title="2.发送端"></a>2.发送端</h3><figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; PUBLISH sunzhongwei <span class="hljs-string">&quot;hello,sunzhongwei&quot;</span>	<span class="hljs-comment"># 发布者发布消息到指定的频道</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; PUBLISH sunzhongwei <span class="hljs-string">&quot;hello,Redis&quot;</span><br>(<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure>

<h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h3><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h&#x2F;redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p>
<p><img src="https://img-blog.csdnimg.cn/2020051321554964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p>
<h3 id="4-使用场景："><a href="#4-使用场景：" class="headerlink" title="4.使用场景："></a>4.使用场景：</h3><ul>
<li><h4 id="实时消息系统"><a href="#实时消息系统" class="headerlink" title="实时消息系统"></a>实时消息系统</h4></li>
<li><h4 id="实时聊天（频道当做聊天室）"><a href="#实时聊天（频道当做聊天室）" class="headerlink" title="实时聊天（频道当做聊天室）"></a>实时聊天（频道当做聊天室）</h4></li>
<li><h4 id="订阅关注系统"><a href="#订阅关注系统" class="headerlink" title="订阅关注系统"></a>订阅关注系统</h4></li>
</ul>
<h2 id="10-Redis主从复制"><a href="#10-Redis主从复制" class="headerlink" title="10. Redis主从复制"></a>10. Redis主从复制</h2><p> <strong>概念</strong>：</p>
<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(masterleader)，后者称为从节点(slave&#x2F;follower);数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p>
<p><strong>主从复制的作用主要包括:</strong><br>1、数据冗余∶主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。<br>2、故障恢复∶当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。<br>3、负载均衡︰在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载﹔尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。<br>4、高可用（集群）基石︰除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的(宕机，最少3个），原因如下:<br>1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大;<br>2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。<br>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。对于这种场景，我们可以使如下这种架构︰</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d8f97ed2519b086a298024d5c7675343.png" alt="image-20201105111148557"></p>
<p>主从复制，读写分离！80%情况下都是在进行读操作！减缓服务器压力，架构经常使用！一主二从！</p>
<p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中，不可能单机使用redis！</p>
<h4 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置:"></a>1.环境配置:</h4><p><strong>只配置从库，不用配置主库</strong>(因为默认为主节点)</p>
<p> <strong>主从复制信息</strong></p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">info replication <span class="hljs-comment"># 查看当前库的信息</span><br><br>127.0.0.1:6379&gt; info replication<br><span class="hljs-comment"># Replication</span><br>role:master		<span class="hljs-comment">#	角色：master</span><br>connected_slaves:0	<span class="hljs-comment">#显示从机数量</span><br>master_replid:85e0dc3072e2b2d876b7ff4a0cb53f961d7fd5e6<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:0<br>second_repl_offset:-1<br>repl_backlog_active:0<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:0<br>repl_backlog_histlen:0<br></code></pre></td></tr></table></figure>

<h4 id="2-一主二从"><a href="#2-一主二从" class="headerlink" title="2. 一主二从:"></a>2. 一主二从:</h4><p><font color=red>默认情况下，每台Redis服务器都是主节点</font>，我们一般情况下只用配置从机就好了</p>
<p>认老大，一主（79）二从（80,81）</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash">slaveof host port <span class="hljs-comment"># 设置这个主机的主人</span><br><br>127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379	<span class="hljs-comment"># 认定这个主机下的6379端口为主</span><br>OK<br>127.0.0.1:6380&gt; info replication<br><span class="hljs-comment"># Replication</span><br>role:slave<br>master_host:127.0.0.1	<span class="hljs-comment"># 可以看到主机的信息</span><br>master_port:6379<br>master_link_status:up<br>master_last_io_seconds_ago:8<br>master_sync_in_progress:0<br>slave_repl_offset:14<br>slave_priority:100<br>slave_read_only:1<br>connected_slaves:0<br>master_replid:acec4d2172706ac4d75dc58669cda8a2d7a8bfbd<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:14<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:14<br><br><br><span class="hljs-comment"># 在主机中查看</span><br>[root@iZbp17e1mp4a0cgbw1358xZ bin]<span class="hljs-comment"># redis-cli -p 6379</span><br>127.0.0.1:6379&gt; info replication<br><span class="hljs-comment"># Replication</span><br>role:master<br>connected_slaves:1<br>slave0:ip=127.0.0.1,port=6380,state=online,offset=126,lag=1<br>master_replid:acec4d2172706ac4d75dc58669cda8a2d7a8bfbd<br>master_replid2:0000000000000000000000000000000000000000<br>master_repl_offset:126<br>second_repl_offset:-1<br>repl_backlog_active:1<br>repl_backlog_size:1048576<br>repl_backlog_first_byte_offset:1<br>repl_backlog_histlen:126<br></code></pre></td></tr></table></figure>

<p>如果两个都配置完了，就会有两个从机的</p>
<p>真实的主从配置应该在配置文件中配置，<strong>这样的话是永久的，使用命令是暂时的</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200513215654634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="3-细节："><a href="#3-细节：" class="headerlink" title="3.细节："></a>3.细节：</h4><p><strong>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存</strong></p>
<p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，如果主机回来，从机依旧可以直接获取到主机写的信息</p>
<p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机!<strong>只要变为从机，立马就会从主机中获取值</strong></p>
<h4 id="4-使用规则："><a href="#4-使用规则：" class="headerlink" title="4.使用规则："></a>4.使用规则：</h4><ol>
<li><p>从机只能读，不能写，主机可读可写但是多用于写。</p>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"> 127.0.0.1:6381&gt; <span class="hljs-built_in">set</span> name sakura <span class="hljs-comment"># 从机6381写入失败</span><br>(error) READONLY You can<span class="hljs-string">&#x27;t write against a read only replica.</span><br><span class="hljs-string"></span><br><span class="hljs-string">127.0.0.1:6380&gt; set name sakura # 从机6380写入失败</span><br><span class="hljs-string">(error) READONLY You can&#x27;</span>t write against a <span class="hljs-built_in">read</span> only replica.<br><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name sakura<br>OK<br>127.0.0.1:6379&gt; get name<br><span class="hljs-string">&quot;sakura&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p>
</li>
<li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p>
</li>
<li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p>
<ul>
<li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li>
<li>使用哨兵模式（自动选举）</li>
</ul>
</li>
</ol>
<blockquote>
<p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p>
</blockquote>
<p>如果主机断开了连接，我们可以使用<font color=yellow>SLAVEOF no one</font>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！</p>
<h4 id="5-复制原理"><a href="#5-复制原理" class="headerlink" title="5.复制原理:"></a>5.复制原理:</h4><p><strong>Slave启动成功连接到master后会发送一个sync命令(同步命令)</strong><br>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<font color=yellow>master将传送整个数据文件到slave，并完成一次完全同步。</font></p>
<p><font color=yellow>全量复制︰而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</font></p>
<p><font color=yellow>增量复制：Master继续将新的所有收集到的修改命令依次传给slave，完成同步。</font></p>
<p>但是只要是重新连接master，一次完全同步(全量复制）将被自动执行。我们的数据一定可以在从机中看到</p>
<h4 id="6-层层链路："><a href="#6-层层链路：" class="headerlink" title="6. 层层链路："></a>6. 层层链路：</h4><p>上一个M连接下一个S，这时候也可以完成我们的主从复制</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1d90bc1c207338cae0e414051f4bfe8e.png" alt="image-20201105122218386"></p>
<p><strong>如果没有老大，能不能选择一个老大出来呢，手动</strong></p>
<p><font color=red>谋朝篡位:</font></p>
<p><font color=yellow>salveof no one</font>,如果主机断开了连接，可以使用这个命令来让自己成为主节点，其他的结点就可以手动连接到最新的这个主节点</p>
<p>如果这个时候老大修复了，那就只能重新连接（即变为主机的从机依然还是主机）</p>
<h2 id="11-Redis哨兵模式（自动选取老大的模式）"><a href="#11-Redis哨兵模式（自动选取老大的模式）" class="headerlink" title="11.Redis哨兵模式（自动选取老大的模式）"></a>11.Redis哨兵模式（自动选取老大的模式）</h2><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务器不可用。这不是一种推荐方式，更多时候，我们优先考虑哨兵模式，<strong>Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题。</strong>**</p>
<p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将库转换为主库。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，<strong>哨兵是一个独立的进程</strong>，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong><img src="https://img-blog.csdnimg.cn/img_convert/c1ba98cbc27441ca87553f823873fac2.png" alt="image-20201105125043998"></p>
<p><strong>哨兵有两个作用</strong></p>
<ol>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让他们切换主机</li>
</ol>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。<img src="https://img-blog.csdnimg.cn/img_convert/3cad6f6728ec2c403ae6d074bbc51823.png" alt="image-20201105125638471"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>我们目前的状态是一主二从</p>
<ol>
<li>配置哨兵配置文件<font color=yellow>sentinel.conf</font>（自己新建的文件，名字必须是这个）</li>
</ol>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sentinel monitor 被监控的名称 host port 1</span><br>sentinel monitor myredis 127.0.0.1 6379 1<br><span class="hljs-comment"># 1是有多少哨兵认为挂了，master才是真的挂了</span><br></code></pre></td></tr></table></figure>

<p>后面的这个数字1代表主机挂了，slave投票看让谁来接替成为主机，票数最多的就会成为主机</p>
<ol>
<li>启动哨兵</li>
</ol>
<figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-sentinel ../etc/sentinal.conf<br><br>[root@iZbp17e1mp4a0cgbw1358xZ bin]<span class="hljs-comment"># redis-sentinel ../etc/sentinal.conf </span><br>20615:X 05 Nov 2020 13:05:15.181 <span class="hljs-comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br>20615:X 05 Nov 2020 13:05:15.181 <span class="hljs-comment"># Redis version=6.0.6, bits=64, commit=00000000, modified=0, pid=20615, just started</span><br>20615:X 05 Nov 2020 13:05:15.181 <span class="hljs-comment"># Configuration loaded</span><br>                _._                                                  <br>           _.-``__ <span class="hljs-string">&#x27;&#x27;</span>-._                                             <br>      _.-``    `.  `_.  <span class="hljs-string">&#x27;&#x27;</span>-._           Redis 6.0.6 (00000000/0) 64 bit<br>  .-`` .-```.  ```\/    _.,_ <span class="hljs-string">&#x27;&#x27;</span>-._                                   <br> (    <span class="hljs-string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span><br><span class="hljs-string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="hljs-string">&#x27;|     Port: 26379</span><br><span class="hljs-string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 20615<br>  `-._    `-._  `-./  _.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br> |`-._`-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>_.-<span class="hljs-string">&#x27;|                                  </span><br><span class="hljs-string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="hljs-string">&#x27;    |           http://redis.io        </span><br><span class="hljs-string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br> |`-._`-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>_.-<span class="hljs-string">&#x27;|                                  </span><br><span class="hljs-string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="hljs-string">&#x27;    |                                  </span><br><span class="hljs-string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                   <br>      `-._    `-.__.-<span class="hljs-string">&#x27;    _.-&#x27;</span>                                       <br>          `-._        _.-<span class="hljs-string">&#x27;                                           </span><br><span class="hljs-string">              `-.__.-&#x27;</span>                                               <br><br>20615:X 05 Nov 2020 13:05:15.182 <span class="hljs-comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br>20615:X 05 Nov 2020 13:05:15.185 <span class="hljs-comment"># Sentinel ID is ee900e749cf585634b3bc2860471d28dcd1ec109</span><br>20615:X 05 Nov 2020 13:05:15.185 <span class="hljs-comment"># +monitor master myredis 127.0.0.1 6379 quorum 1</span><br>20615:X 05 Nov 2020 13:05:15.186 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379<br>20615:X 05 Nov 2020 13:05:15.188 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379<br></code></pre></td></tr></table></figure>

<p>如果master结点断开了，这个时候就会从从机中随机选择一个服务器,这里面有一个<strong>投票算法</strong></p>
<p><strong>哨兵日志</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/09a06ab2d386b69dc6e093379c3dfbbe.png" alt="image-20201105130939012"></p>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式:"></a>哨兵模式:</h4><p>如果<strong>主机此时回来了，只能归并到新的主机下，当做从机</strong>，这就是哨兵模式的规则！</p>
<p><strong>优点：</strong></p>
<ol>
<li>哨兵模式，基于主从复制模式，所有主从配置的优点它都有</li>
<li>主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动，更加健壮</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置是非常麻烦的，里面有很</li>
</ol>
<h4 id="哨兵模式全部配置："><a href="#哨兵模式全部配置：" class="headerlink" title="哨兵模式全部配置："></a>哨兵模式全部配置：</h4><figure class="highlight bash"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Example sentinel.conf</span><br> <br><span class="hljs-comment"># 哨兵sentinel实例运行的端口 默认26379   如果有多集群哨兵的话,就需要区分</span><br>port 26379<br> <br><span class="hljs-comment"># 哨兵sentinel的工作目录</span><br><span class="hljs-built_in">dir</span> /tmp<br> <br><span class="hljs-comment"># 哨兵sentinel监控的redis主节点的 ip port </span><br><span class="hljs-comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span><br><span class="hljs-comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span><br><span class="hljs-comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br>sentinel monitor mymaster 127.0.0.1 6379 1<br> <br><span class="hljs-comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="hljs-comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="hljs-comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<br> <br> <br><span class="hljs-comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="hljs-comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel down-after-milliseconds mymaster 30000<br> <br><span class="hljs-comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span><br>这个数字越小，完成failover所需的时间就越长，<br>但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。<br>可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。<br><span class="hljs-comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br>sentinel parallel-syncs mymaster 1<br> <br> <br><span class="hljs-comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span><br><span class="hljs-comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="hljs-comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="hljs-comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span><br><span class="hljs-comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="hljs-comment"># 默认三分钟</span><br><span class="hljs-comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel failover-timeout mymaster 180000<br> <br><span class="hljs-comment"># SCRIPTS EXECUTION</span><br> <br><span class="hljs-comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="hljs-comment">#对于脚本的运行结果有以下规则：</span><br><span class="hljs-comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="hljs-comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="hljs-comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="hljs-comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br> <br><span class="hljs-comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span><br><span class="hljs-comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span><br><span class="hljs-comment">#一个是事件的类型，</span><br><span class="hljs-comment">#一个是事件的描述。</span><br><span class="hljs-comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="hljs-comment">#通知脚本</span><br><span class="hljs-comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br>  sentinel notification-script mymaster /var/redis/notify.sh<br> <br><span class="hljs-comment"># 客户端重新配置主节点参数脚本</span><br><span class="hljs-comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="hljs-comment"># 以下参数将会在调用脚本时传给脚本:</span><br><span class="hljs-comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="hljs-comment"># 目前&lt;state&gt;总是“failover”,</span><br><span class="hljs-comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span><br><span class="hljs-comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="hljs-comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="hljs-comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh<br></code></pre></td></tr></table></figure>

<h2 id="12-Redis缓存穿透与雪崩（面试高频，工作常用）"><a href="#12-Redis缓存穿透与雪崩（面试高频，工作常用）" class="headerlink" title="12.Redis缓存穿透与雪崩（面试高频，工作常用）"></a>12.Redis缓存穿透与雪崩（面试高频，工作常用）</h2><p>服务的高可用问题</p>
<p>不会详细分析解决方案的底层（专题）</p>
<p><img src="C:/Users/ASUS/Pictures/Saved%20Pictures/%E8%B6%B3%E7%90%83%E9%9E%8B%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E9%97%A8%E6%88%B7-%E5%81%B6%E5%81%B6%E8%B6%B3%E7%90%83%E8%A3%85%E5%A4%87%E7%BD%91_files/0a4034ed3249cfd5dcf1b4801c603ac3.png" alt="imag"></p>
<h4 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h4><p><strong>概念：</strong><br>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀!)，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><h4 id="1-布隆过滤器"><a href="#1-布隆过滤器" class="headerlink" title="1.布隆过滤器"></a><strong>1.布隆过滤器</strong></h4><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力﹔</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/711f719d7387385ef19084f732aa266e.png" alt="image-20201105132801112"></p>
<p><img src="https://img-blog.csdnimg.cn/20200513215824722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="2-缓存空对象"><a href="#2-缓存空对象" class="headerlink" title="2.缓存空对象"></a><strong>2.缓存空对象</strong></h4><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源;</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/14c9e14245bae4a3e49226c416376c8c.png" alt="image-20201105132900180"></p>
<p>但是这种方法会存在两个问题:<br>1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键;<br>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h4 id="缓存击穿（查的太多，量大，缓存过期）"><a href="#缓存击穿（查的太多，量大，缓存过期）" class="headerlink" title="缓存击穿（查的太多，量大，缓存过期）"></a>缓存击穿（查的太多，量大，缓存过期）</h4><p>微博服务器宕机（60 60.1 0.1）</p>
<p><strong>概述：</strong><br>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。<br>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a><strong>解决方案:</strong></h4><h4 id="1-设置热点数据永不过期"><a href="#1-设置热点数据永不过期" class="headerlink" title="1.设置热点数据永不过期"></a>1.设置热点数据永不过期</h4><p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题</p>
<h4 id="2-加互斥锁"><a href="#2-加互斥锁" class="headerlink" title="2.加互斥锁"></a>2.加互斥锁</h4><p><strong>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务</strong>，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁考验很大</p>
<p>在访问key之前，采用<strong>SETNX（set if not exists）</strong>来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p><strong>概念:</strong><br>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis宕机<br>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，<strong>这批商品的缓存就都过期了。而对这批商品的访问查询</strong>，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于<strong>是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200513215850428.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MzIyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</strong></p>
<h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><h4 id="1-Redis高可用"><a href="#1-Redis高可用" class="headerlink" title="1.Redis高可用"></a>1.Redis高可用</h4><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。(异地多活）</p>
<h4 id="2-限流降级（在SpringCloud中有）"><a href="#2-限流降级（在SpringCloud中有）" class="headerlink" title="2.限流降级（在SpringCloud中有）"></a>2.限流降级（在SpringCloud中有）</h4><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<h4 id="3-数据预热"><a href="#3-数据预热" class="headerlink" title="3.数据预热"></a>3.数据预热</h4><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。机只能有唯一的服务器ID   3.每个主机可以有多个从机</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="true"
        data-ae="true"
        data-ci="756f76ca3f305808772c"
        data-cs="b29b8b4a65d590d87e4691f151225b485581592a"
        data-r="myfaithisc.github.io"
        data-o="myfaithisc"
        data-a="myfaithisc"
        data-d="true"
    >查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84"><span class="toc-number">1.</span> <span class="toc-text">1.Redis是单线程的!</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%80%8E%E4%B9%88%E5%BF%AB"><span class="toc-number">1.1.</span> <span class="toc-text">Redis为什么单线程还怎么快?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-redis%E6%98%AF%E5%B0%86%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84-%E6%89%80%E4%BB%A5%E8%AF%B4%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%8E%BB%E6%93%8D%E4%BD%9C%E6%95%88%E7%8E%87%E5%B0%B1%E6%98%AF%E6%9C%80%E9%AB%98%E7%9A%84"><span class="toc-number">1.2.</span> <span class="toc-text">核心:redis是将所有的数据全部放在内存中的,所以说使用单线程去操作效率就是最高的,</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BC%9A%E5%88%87%E6%8D%A2-%E8%80%97%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C-%EF%BC%8C%E5%AF%B9%E4%BA%8E%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E6%9D%A5%E8%AF%B4-%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%95%88%E7%8E%87%E5%B0%B1%E6%98%AF%E6%9C%80%E9%AB%98%E7%9A%84-%E5%A4%9A%E6%AC%A1%E8%AF%BB%E5%86%99%E9%83%BD%E6%98%AF%E5%9C%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">多线程(CPU上下文会切换:耗时的操作)，对于内存系统来说,如果没有上下文切换效率就是最高的! 多次读写都是在</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AACPU%E4%B8%8A%E7%9A%84-%E5%9C%A8%E5%86%85%E5%AD%98%E6%83%85%E5%86%B5%E4%B8%8B-%E8%BF%99%E4%B8%AA%E5%B0%B1%E6%98%AF%E6%9C%80%E4%BD%B3%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.2.</span> <span class="toc-text">一个CPU上的,在内存情况下,这个就是最佳的方案!</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">2.五大基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-String%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.1.</span> <span class="toc-text">1.String字符串类型详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.1.</span> <span class="toc-text">扩展:对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-List%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%AE%B2"><span class="toc-number">2.2.</span> <span class="toc-text">2.List列表类型详讲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.2.1.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Set%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%AE%B2"><span class="toc-number">2.3.</span> <span class="toc-text">3.Set集合类型详讲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89%E8%AF%A6%E8%AE%B2%EF%BC%88%E6%9C%AC%E8%B4%A8%E5%92%8CString%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E8%BF%99%E6%98%AFhash%E6%98%AFkey-vlaue%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">4.Hash（哈希）详讲（本质和String没有什么区别,这是hash是key-vlaue）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%BD%93%E4%BA%8EMap%E9%9B%86%E5%90%88-key-map"><span class="toc-number">2.4.1.</span> <span class="toc-text">相当于Map集合(key-map)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Zset%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">5.Zset（有序集合）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">3.三种特殊数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-geoadd-%E6%B7%BB%E5%8A%A0%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">1.geoadd  添加地理位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Hyperloglog"><span class="toc-number">3.2.</span> <span class="toc-text">2.Hyperloglog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">什么是基数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Bitmaps"><span class="toc-number">3.4.</span> <span class="toc-text">3.Bitmaps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E5%AD%98%E5%82%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">位存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">4.事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7-Watch-%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE"><span class="toc-number">4.1.</span> <span class="toc-text">监控!Watch(面试常问)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">4.2.</span> <span class="toc-text">1.悲观锁:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9A"><span class="toc-number">4.3.</span> <span class="toc-text">2.乐观锁：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Jedis"><span class="toc-number">5.</span> <span class="toc-text">5.Jedis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-SpringBoot%E6%95%B4%E5%90%88"><span class="toc-number">6.</span> <span class="toc-text">6.SpringBoot整合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89RedisTemplate"><span class="toc-number">6.0.1.</span> <span class="toc-text">自定义RedisTemplate</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Redis-conf"><span class="toc-number">7.</span> <span class="toc-text">7.Redis.conf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">8.Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%EF%BC%88Redis-Database%EF%BC%89"><span class="toc-number">8.0.1.</span> <span class="toc-text">RDB（Redis Database）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">8.0.2.</span> <span class="toc-text">触发机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8Drdb%E6%96%87%E4%BB%B6"><span class="toc-number">8.0.3.</span> <span class="toc-text">如何恢复rdb文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%EF%BC%88Append-Only-File%EF%BC%89"><span class="toc-number">8.0.4.</span> <span class="toc-text">AOF（Append Only File）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">8.0.5.</span> <span class="toc-text">优点和缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"><span class="toc-number">8.0.6.</span> <span class="toc-text">重写规则说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">扩展：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">8.1.1.</span> <span class="toc-text">Redis 持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">8.1.2.</span> <span class="toc-text">RDB的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">8.1.3.</span> <span class="toc-text">RDB的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E4%BC%98%E7%82%B9"><span class="toc-number">8.1.4.</span> <span class="toc-text">AOF 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E7%BC%BA%E7%82%B9"><span class="toc-number">8.1.5.</span> <span class="toc-text">AOF 缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E5%92%8CAOF%E5%AF%B9%E6%AF%94"><span class="toc-number">8.1.6.</span> <span class="toc-text">RDB和AOF对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">9.</span> <span class="toc-text">9.Redis发布订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A2%E9%98%85%E7%AB%AF"><span class="toc-number">9.1.</span> <span class="toc-text">1.订阅端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%91%E9%80%81%E7%AB%AF"><span class="toc-number">9.2.</span> <span class="toc-text">2.发送端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8E%9F%E7%90%86"><span class="toc-number">9.3.</span> <span class="toc-text">3.原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">9.4.</span> <span class="toc-text">4.使用场景：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.4.1.</span> <span class="toc-text">实时消息系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%EF%BC%88%E9%A2%91%E9%81%93%E5%BD%93%E5%81%9A%E8%81%8A%E5%A4%A9%E5%AE%A4%EF%BC%89"><span class="toc-number">9.4.2.</span> <span class="toc-text">实时聊天（频道当做聊天室）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E5%85%B3%E6%B3%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.4.3.</span> <span class="toc-text">订阅关注系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">10. Redis主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">10.0.1.</span> <span class="toc-text">1.环境配置:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-number">10.0.2.</span> <span class="toc-text">2. 一主二从:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%86%E8%8A%82%EF%BC%9A"><span class="toc-number">10.0.3.</span> <span class="toc-text">3.细节：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">10.0.4.</span> <span class="toc-text">4.使用规则：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">10.0.5.</span> <span class="toc-text">5.复制原理:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%B1%82%E5%B1%82%E9%93%BE%E8%B7%AF%EF%BC%9A"><span class="toc-number">10.0.6.</span> <span class="toc-text">6. 层层链路：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%87%AA%E5%8A%A8%E9%80%89%E5%8F%96%E8%80%81%E5%A4%A7%E7%9A%84%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">11.Redis哨兵模式（自动选取老大的模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">11.0.1.</span> <span class="toc-text">概述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%EF%BC%9A"><span class="toc-number">11.0.2.</span> <span class="toc-text">测试：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.0.3.</span> <span class="toc-text">哨兵模式:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%85%A8%E9%83%A8%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">11.0.4.</span> <span class="toc-text">哨兵模式全部配置：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9%EF%BC%88%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%EF%BC%8C%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">12.Redis缓存穿透与雪崩（面试高频，工作常用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%88%E6%9F%A5%E4%B8%8D%E5%88%B0%EF%BC%89"><span class="toc-number">12.0.1.</span> <span class="toc-text">缓存穿透（查不到）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">12.0.2.</span> <span class="toc-text">解决方案：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">12.0.3.</span> <span class="toc-text">1.布隆过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.0.4.</span> <span class="toc-text">2.缓存空对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%88%E6%9F%A5%E7%9A%84%E5%A4%AA%E5%A4%9A%EF%BC%8C%E9%87%8F%E5%A4%A7%EF%BC%8C%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%EF%BC%89"><span class="toc-number">12.0.5.</span> <span class="toc-text">缓存击穿（查的太多，量大，缓存过期）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">12.0.6.</span> <span class="toc-text">解决方案:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E6%B0%B8%E4%B8%8D%E8%BF%87%E6%9C%9F"><span class="toc-number">12.0.7.</span> <span class="toc-text">1.设置热点数据永不过期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8A%A0%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">12.0.8.</span> <span class="toc-text">2.加互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">12.0.9.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A-1"><span class="toc-number">12.0.10.</span> <span class="toc-text">解决方案：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Redis%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">12.0.11.</span> <span class="toc-text">1.Redis高可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%99%90%E6%B5%81%E9%99%8D%E7%BA%A7%EF%BC%88%E5%9C%A8SpringCloud%E4%B8%AD%E6%9C%89%EF%BC%89"><span class="toc-number">12.0.12.</span> <span class="toc-text">2.限流降级（在SpringCloud中有）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E9%A2%84%E7%83%AD"><span class="toc-number">12.0.13.</span> <span class="toc-text">3.数据预热</span></a></li></ol></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>
<script src="/js/codeCopy.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
