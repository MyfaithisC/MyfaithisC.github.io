


<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>对于MySQL你知道多少 - 树欲静而风不止,子欲养而亲不待</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="选择有时候比努力更重要,关于数据库的那些事情1.关于索引的事情@1.索引的创建第一种:在create table 的时候加上约束（隐式创建）隐式的方式创建索引.在声明有主键约束、唯一性约束、外键约束的字段上,会自动的添加相,"> 
    <meta name="author" content="枫叶"> 
    <link rel="alternative" href="atom.xml" title="树欲静而风不止,子欲养而亲不待" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="对于MySQL你知道多少 - 树欲静而风不止,子欲养而亲不待"/>
    <meta name="twitter:description" content="选择有时候比努力更重要,关于数据库的那些事情1.关于索引的事情@1.索引的创建第一种:在create table 的时候加上约束（隐式创建）隐式的方式创建索引.在声明有主键约束、唯一性约束、外键约束的字段上,会自动的添加相,"/>
    
    
    
    
    <meta property="og:site_name" content="树欲静而风不止,子欲养而亲不待"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="对于MySQL你知道多少 - 树欲静而风不止,子欲养而亲不待"/>
    <meta property="og:description" content="选择有时候比努力更重要,关于数据库的那些事情1.关于索引的事情@1.索引的创建第一种:在create table 的时候加上约束（隐式创建）隐式的方式创建索引.在声明有主键约束、唯一性约束、外键约束的字段上,会自动的添加相,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">
<link rel="stylesheet" href="/css/site.css">

		<!-- 代码块复制 -->
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard@latest/dist/clipboard.js"></script>
    <script>window.searchDbPath = "/search.xml";</script>


	

<!-- 点击效果 -->

<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/5MayRain/5MayRain.github.io@latest/js/fireworks.js"></script>



    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">树欲静而风不止,子欲养而亲不待</span>
    <div id="loader"></div>
    <div id="single">
    

<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">对于MySQL你知道多少</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
		
    </div>
	

    <div class="scrollbar"></div>


</div>

    <div class="section">
        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<!-- 帖子视图 -->


<!-- 帖子视图 -->

    <h1 class="title">对于MySQL你知道多少</h1>
    <div class="stuff">
        <span>九月 19, 2022</span>

        
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E6%95%B0%E6%8D%AE/" rel="tag">数据</a></li></ul>


    </div>


<!-- 更新时间 -->
<div class="updated">
    <div></div>
    <span>该文章更新于 2022.10.04</span>
</div>


<div class="article">
    <div class='main'>
        <h1 class="title">对于MySQL你知道多少</h1>
        <div class="stuff">
            <span>九月 19, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E6%95%B0%E6%8D%AE/" rel="tag">数据</a></li></ul>


        </div>
		
<span>
   本篇文章阅读数(刷新获取):<span id="busuanzi_value_page_pv"></span>
</span>

  
        <div class="content markdown">
            <h2 id="关于数据库的那些事情"><a href="#关于数据库的那些事情" class="headerlink" title="关于数据库的那些事情"></a>关于数据库的那些事情</h2><h2 id="1-关于索引的事情"><a href="#1-关于索引的事情" class="headerlink" title="1.关于索引的事情"></a>1.关于索引的事情</h2><h3 id="1-索引的创建"><a href="#1-索引的创建" class="headerlink" title="@1.索引的创建"></a>@1.索引的创建</h3><h3 id="第一种-在create-table-的时候加上约束（隐式创建）"><a href="#第一种-在create-table-的时候加上约束（隐式创建）" class="headerlink" title="第一种:在create table 的时候加上约束（隐式创建）"></a>第一种:在create table 的时候加上约束（隐式创建）</h3><p><strong>隐式的方式创建索引.在声明有主键约束、唯一性约束、外键约束的字段上,会自动的添加相关的索引</strong> </p>
<ul>
<li><p><strong>约束</strong>：全称完整性约束，它是关系数据库中的对象，用来存放插入到一个表中一列数据的规则，用来确保数据的准确性和一致性。</p>
</li>
<li><p><strong>索引</strong>：数据库中用的最频繁的操作是数据查询，索引就是为了加速表中数据行的检索而创建的一种分散的数据结构。可以把索引类比成书的目录，有目录的肯定比没有目录的书，更方便查找。</p>
</li>
</ul>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t_movie(<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    movie_rate <span class="hljs-keyword">unique</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>),   <br>    movie_name <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>), <br>    movie_url <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>),<br>) engine<span class="hljs-operator">=</span>Innodb charset utf8;<br></code></pre></td></tr></table></figure>



<h3 id="第二种-在creat-table的时候直接加上索引-显示创建"><a href="#第二种-在creat-table的时候直接加上索引-显示创建" class="headerlink" title="第二种:在creat table的时候直接加上索引(显示创建)"></a>第二种:在creat table的时候直接加上索引(显示创建)</h3><p><font color=Tan>语法:  索引类型 索引名(字段名)</font></p>
<p><font color=red>注意:  1.字段名中可以有多个,即组成联合索引。     2. 在声明了唯一性索引的字段,可以添加Null值</font></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span>  <span class="hljs-keyword">table</span> book(<br>book_id  <span class="hljs-type">int</span> auto_increment,<br>book_name  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>info  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>price  <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><span class="hljs-keyword">primary</span> key key_index(book id);<br>index  idx_name(book_name,price),<br><span class="hljs-keyword">unique</span> index  info(info)  <br>);<br></code></pre></td></tr></table></figure>



<h3 id="第三种-改变表的结构-索引从无到有的结构"><a href="#第三种-改变表的结构-索引从无到有的结构" class="headerlink" title="第三种:改变表的结构(索引从无到有的结构)"></a>第三种:改变表的结构(索引从无到有的结构)</h3><p><font color=Gold>方式1</font>： <font color=Tan>alter table  表名  drop  索引类型  索引名</font> </p>
<p><strong>索引的分类:</strong></p>
<ul>
<li>普通索引    index</li>
<li>唯一索引    uniqe</li>
<li>主键索引    primary </li>
<li>组合索引</li>
<li>全文索引</li>
<li>空间索引</li>
</ul>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span>  book <span class="hljs-keyword">add</span>  index book_index(book_id);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> book <span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span> index book_uniqueIndex(info);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> book <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key  book_key(price);<br></code></pre></td></tr></table></figure>

<p><font color=Gold>方式2</font>： <font color=Tan>create  index 索引名  on 表名(字段名)</font></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test(<br>book_id  <span class="hljs-type">int</span>,<br>book_name  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>info  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>price  <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br><span class="hljs-keyword">create</span>  index  book_index  <span class="hljs-keyword">on</span> test(book_name);<br></code></pre></td></tr></table></figure>





<h3 id="2-查看索引的命令行"><a href="#2-查看索引的命令行" class="headerlink" title="@2.查看索引的命令行"></a>@2.查看索引的命令行</h3><p><font color=Gold>方式一:</font></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> book;<br></code></pre></td></tr></table></figure>

<p><font color=Gold>方式二:</font></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> book;<br></code></pre></td></tr></table></figure>



<h3 id="3-删除主键索引"><a href="#3-删除主键索引" class="headerlink" title="@3.删除主键索引"></a>@3.删除主键索引</h3><p><font color=Gold>方式一</font>：<font color=Tan>语法: alter table  表名  drop  索引类型  索引名</font> </p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span>  <span class="hljs-keyword">table</span> book <span class="hljs-keyword">drop</span> index book_index;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> book <span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key;<br></code></pre></td></tr></table></figure>

<p><font color=red>注意:  删除索引  添加了auto_increment约束字段的唯一索引不能删除</font></p>
<p><font color=Gold>方式二</font> :  <font color=Tan>语法: drop 索引类型  索引名 on  表名</font></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">drop</span> index book_uniqueIndex <span class="hljs-keyword">on</span> book;<br></code></pre></td></tr></table></figure>

<p><font color=red>注意:  删除表中列时,如果要删除的列为索引的组成部分,<br>则该列也会从索引中删除.如果组成索引的所有列都被删除,则整个索引将被删除</font></p>
<h3 id="4-Mysql8-0新特性"><a href="#4-Mysql8-0新特性" class="headerlink" title="@4.Mysql8.0新特性"></a>@4.Mysql8.0新特性</h3><h4 id="1-支持降序索引-在8-0版本之前创建的仍然是升序索引-使用时进行反向扫描-这大大降低了数据库的效率"><a href="#1-支持降序索引-在8-0版本之前创建的仍然是升序索引-使用时进行反向扫描-这大大降低了数据库的效率" class="headerlink" title="1.支持降序索引  (在8.0版本之前创建的仍然是升序索引,使用时进行反向扫描,这大大降低了数据库的效率)"></a>1.支持降序索引  (在8.0版本之前创建的仍然是升序索引,使用时进行反向扫描,这大大降低了数据库的效率)</h4><p>支持了降序索引,无论是升序还是降序都不会对性能影响太大</p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span>  test1(<br>a <span class="hljs-type">int</span>,<br>b <span class="hljs-type">int</span>,<br>index  test_index(a  <span class="hljs-keyword">asc</span>,b <span class="hljs-keyword">desc</span>)<br>);<br></code></pre></td></tr></table></figure>

<h4 id="2-支持隐藏索引-通过先将索引设置为隐藏索引-再考虑要不要删除索引的方式就是软删除-还可以用于验证某个索引-删除之后的查询性能影响-就可以暂时先隐藏该索引"><a href="#2-支持隐藏索引-通过先将索引设置为隐藏索引-再考虑要不要删除索引的方式就是软删除-还可以用于验证某个索引-删除之后的查询性能影响-就可以暂时先隐藏该索引" class="headerlink" title="2.支持隐藏索引  通过先将索引设置为隐藏索引,再考虑要不要删除索引的方式就是软删除,还可以用于验证某个索引 删除之后的查询性能影响,就可以暂时先隐藏该索引"></a>2.支持隐藏索引  通过先将索引设置为隐藏索引,再考虑要不要删除索引的方式就是软删除,还可以用于验证某个索引 删除之后的查询性能影响,就可以暂时先隐藏该索引</h4><p><font color=Red>注意: 主键不能被设置为隐藏索引.当表中没有显式主键时,表中第一个唯一非空索引会成为隐式主键,也不能设为隐藏索引。当索引被隐藏后它的内容仍然是和正常索引一样实时更新的(即也是会影响DML的)</font></p>
<p><font color=IndianRed>那怎么创建隐式索引呢?</font></p>
<p><font color=Gold>方式一</font>：<strong>如果想要设置为隐藏索引,只要在创建的时候在索引后面加一个invisible即可</strong></p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test(<br>book_id  <span class="hljs-type">int</span>,<br>book_name  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>info  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>price  <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>index   book_index(book_id)  invisible <br>); <br></code></pre></td></tr></table></figure>

<p><font color=Gold>方式二</font>：<strong>如果想要修改索引的可见性,可以对表的结构进行修改</strong></p>
<p><font color=Tan>语法: alter table  表名  alter index 索引名  invislble[不可见]&#x2F;visible[可见]</font> </p>
<figure class="highlight sql"><button class="btn-copy" data-clipboard-snippet="" title="复制"><img src="//img.mrzgh.top/Blog/Website/icon/copy.svg" /></button><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1  <span class="hljs-keyword">alter</span> index  test_index  invisible; <br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test1 <span class="hljs-keyword">alter</span> index  test_index visible;<br></code></pre></td></tr></table></figure>

<p><font color=red>注意:  当索引被隐藏时,它的内容仍然是和正常索引一样实时更新的.如果一个索引需要长期被隐藏,那么可以将其删除,因为索引的存在会影响插入、更新和删除的性能</font></p>
<h3 id="5-哪些情况适合创建索引"><a href="#5-哪些情况适合创建索引" class="headerlink" title="@5.哪些情况适合创建索引"></a>@5.哪些情况适合创建索引</h3><ul>
<li>字段的数值有唯一性的限制</li>
<li>业务上具有唯一特性的字段,即使是组合字段,也必须建成唯一索引</li>
<li>频繁作为where查询条件的字段</li>
<li>经常用group by和order by的列</li>
<li>update、delete的where条件列</li>
<li>distinct字段需要创建索引</li>
</ul>
<p><strong>在以上情况创建索引的同时要注意的事项:</strong></p>
<p>1.多表join连接操作时,创建索引注意事项: 连接表的数量尽量不要超过<font color=red>3张</font>,每增加一张表就相当于增加了一次嵌套的循环,数量级增长会非常快.对用于连接的字段创建索引,并且该字段在多表中类型要一致。</p>
<p>2.不要以为唯一索引影响了insert速度,这个速度损耗可以忽略,但是提高查找速度是明显的。</p>
<p>3.对数据按照某个条件进行查询后再进行update或者delete的操作,如果对where字段创建了索引,就能大幅提高效率.原理是因为我们需要先根据where条件列检索出来这条记录,然后再对它进行更新或者删除.如果进行更新的时候,更新的字段是非索引字段,提升的效率会更加明显,这是因为非索引字段更新不需要对索引进行维护</p>
<p>4.使用列的类型小(该类型表示的数据范围的大小)的创建索引</p>
<ul>
<li>数据类型小,在查询时进行的比较操作越快</li>
<li>数据类型小,索引占用的存储空间就越少,在一个数据页内就可以放下更多的记录,从而减少磁盘I&#x2F;O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul>
<p> 5.使用字符串前缀创建索引,字符串越长,索引占用的存储空间越大.取前缀这样既节约了空间,又减少了字符串的比较时间</p>
<p> 6.区分度高(散列性高)的列适合作为索引：</p>
<p>列的基数指的是某一列中不重复数据的个数,比方说某个列包含值2,5,8,2,5,8  基数为3,也就是说,在记录数一定的情况下,列的基数越大,该列中值越分散,列的基数越小,该列的值就越集中,可以使用公式select count(distinct left(列名,索引长度))&#x2F;count(*) from 表名计算区分度,越接近1越好,一般超过33%就算是比较高效的索引了,<font color=red>扩展:联合索引把区分度高(散列性高)的列放在前面</font></p>
<p>#怎么计算不同的长度的选择性呢?<br>select count(distinct left(address,10))&#x2F;count(<em>);  #截取前10个字符的选择度<br>#即根据select count(distinct left(列名,索引长度))&#x2F;count(</em>)的区分度来确定;</p>
<p>#10.使用最频繁的列放在联合索引的最左侧<br>#11.在多个字段都要创建索引的情况下,联合索引优于单值索引<br>#限制索引的数目<br>#索引的数目不是越多越好,建议单张表索引数目不超过6个,原因是:<br>#1.每个索引都需要占用磁盘块空间,索引越多,需要的磁盘空间就越大<br>#2.索引会影响insert、delete、update等语句的性能,因为表中的数据更改的同时,索引也会进行调整和更新,会造成负担<br>#3.会增加mysql优化器生成执行计划时间,降低查询性能</p>
<p>#哪些情况不适合创建索引<br>#1.在where中使用不到的字段,不要设置索引<br>#2.数据量小的表最好不要使用索引<br>#3.有大量重复数据的列上不要建立索引<br>#结论:当数据重复度大,高于10%的时候,也就不需要对这个字段使用索引<br>#4.避免对经常更新的表创建过多的索引<br>#5.不建议用无序的值作为索引<br>#如身份证、UUID(在索引比较时需要转为ASCLL,并且插入的时候可能会造成页分裂)、MD5、HASH、无序字符串等<br>#6.删除不再使用或者很少使用的索引<br>#7.不要定义冗余或者重复的索引</p>
<p>#哪些情况会使索引失效<br>#1.以%开头的Like查询<br>#2.创建了组合索引,没有满足‘最左匹配原则’<br>#3.查询条件中使用了or,并且or的前后条件中有一个列没有索引<br>#4.在索引列上的操作,如函数upper()、or、！&#x3D; (&lt; &gt;),not in,is no null,计算和类型转型(自动或手动)等<br>#创建的联合索引中,务必把范围涉及到的字段写在最后<br>#如  select  * from  user  where name&#x3D;123;(name类型为varchar)<br>#select  * from  user  where  id+1&#x3D;90001;<br>#select * from  where subsring(name,1,3)&#x3D;’abc’;</p>
<p>#查看系统参数<br>#show [global|session] status like ‘参数’;<br>#一些常用的性能参数如下:<br>#Connections:连接MySQL服务器的次数<br>#Uptime: MySQL服务器的上线时间<br>#Slow_queries:慢查询的次数<br>#innodb_rows_%:查看进行了增删改查的对应的行数<br>#Innodb_rows_read: select查询返回的行数<br>#Innodb_rows_inserted:执行INSERT操作插入的行数.<br>#Innodb_rows_updated:执行UPDATE操作更新的行数.<br>#Innodb_rows_deleted:执行DELETE操作删除的行数.<br>#Com_select:查询操作的次数。<br>#Com_insert:插入操作的次数。对于批量插入的INSERT操作，只累加一次<br>#Com_update:更新操作的次数。<br>#Com_delete:删除操作的次数。<br>#如查看mysql服务器连接的次数<br>show status like ‘Connections’;<br>show status like  ‘Innodb_rows_inserted’;<br>show status like ‘uptime’;<br>show status like ‘slow_queries’;<br>show status like ‘innodb_rows_%’;<br>show status like ‘com_select’;</p>
<p>#统计SQL的查询成本:last_query_cost  通常是我们评价一个查询的执行效率的一个常用指标,查询得到的值为数据来自多少个数据页<br>#sql查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论:<br>#1.位置决定效率.如果页就在数据库缓冲池中,那么效率是最高的,否则还需要从内存或者磁盘中进行读取,当然针对单个页的读取来说,如果页存在于内存中,会比在磁盘中读取效率高很多.<br>#2.批量决定效率.如果我们从磁盘中对单一页进行随机读.那么效率是很低的(差不多10ms)，而采用顺序读取的方式，批量对页进行读取,平均一页的读取效率就会提升很多,甚至要快于单个页面在内存中的随机读取。<br>#所以说,遇到I&#x2F;o并不用担心,方法找对了,效率还是很高的.我们首先要考虑数据存放的位置,如果是经常使用的数据就要尽量放到缓冲池中,其次我们可以充分利用磁盘的吞吐能力,一次性批量读取数据,这样单个页的读取效率也就得到了提升.</p>
<p>#定位执行慢的SQL:慢查询日志<br>#MySQL的慢查询日志,用来记录在MySQL中响应时间超过阈值的语句,具体运行时间超过long_query_time值的SQL,则会被记录到慢查询日志中,long_query_time的默认值为10s<br>#默认情况下数据库没有开启慢查询日志,需要我们手动来设置.如果不是调优需要的话,一般不建议启动该参数,因为开启了会对性能多多少少带了一定的影响<br>#查看慢查询日志参数<br>show variables like ‘%slow_query_log’;<br>#开启慢查询日志参数<br>set  global slow_query_log&#x3D;on;<br>#关闭慢查询日志参数<br>set global slow_query_log&#x3D;off;<br>#可以用来查询慢查询日志文件的位置<br>show variables like ‘%slow_query_log%’;<br>#查看慢查询long_query_time的阈值<br>show variables like  ‘%long_query_time%’;<br>#对long_query_time进行修改  注意long_query_time既为全局 又为会话的变量 所以2个都要改<br>set long_query_time&#x3D;1;<br>set global long_query_time&#x3D;1;<br>#补充说明:控制慢查询日志的还有一个系统变量:min_examined_row_limit 意思为扫描过的最少记录数(默认为0) 这个变量和查询执行时间,共同组成了判别了一个查询是否是慢查询的条件.如果查询扫描过的记录数大于等于这个变量的值,并且查询执行时间超过long_query_time 那么这个查询就被记录到慢查询日志中<br>show variables like ‘profiling’;<br>use ism;<br>select * from  user where id&#x3D;2;<br>show profiles;<br>show profile;</p>
<p>#explain讲解<br>#1.id值小结:<br>#id如果相同,可以认为是一组,从上往下顺序执行<br>#在所有组中,id值越大,优先级越高,越先执行<br>#关注点:id号每个号码,表示一趟独立的查询,一个sql的查询趟数越少越好<br>#2.select_type:select关键字对应的那个查询的类型,确定小查询在整个大查询中的角色<br>#查询语句中不包含’union’或者子查询的查询都算是’simple’类型<br>#对于包含’union’或者’union_all’或者子查询的大查询来说,它是由几个小查询组成的,其中最左边的查询的select_type值为’primary’<br>#对于包含’union’或者’union_all’或者子查询的大查询来说,它是由几个小查询组成的,其中除了最左边的查询,其他的查询为’union’<br>#mysql选择使用临时表来完成’union’查询的去重工作,针对该临时表的查询为’union result’<br>#3.type:代表某个表的执行查询时的访问方法,是一个较为重要的一个指标<br>#4.key_len:实际使用到的索引长度(即:字节数),帮你检测是否充分利用上了索引,’值越大越好’,针对的主要是联合索引</p>
<p>#关联查询优化<br>#结论:对于内连接来说,查询优化器可以决定谁作为驱动表,谁作为被驱动表出现的.如果表的连接条件中只能有一个字段有索引,则有索引的字段所在的表会被作为被驱动表.在两个表的连接条件都存在索引的情况下,会选择小表作为驱动表,’小表驱动大表’,本质就是减少外层循环的数据数量</p>
<p>#子查询优化<br>#子查询可以进行select语句的嵌套查询,即一个select查询的结果作为另一个select语句的条件.子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作.但是子查询的执行效率不高,原因:1.执行子查询时,mysql需要为内层查询语句的查询结果建立一个临时表,然后外层查询语句从临时表中查询记录.查询完毕后,再撤销这些临时表.这样会消耗过多的CPU和IO资源,产生大量的慢查询。2.子查询的结果集存储的临时表,不论是内存临时表还是磁盘临时表都不会存在索引,所以查询性能会受到一定的影响。3.对于返回结果集比较大的子查询,其对查询性能的影响也就越大<br>#在MySQL中,可以使用连接(JOIN)查询来替代子查询.连接查询不需要建立临时表,其速度比子查询要快,如果查询中使用到了索引的话,性能就会更好</p>
<p>#排序优化<br>问题:在WHERE条件字段上加字段上加索引,但是为什么在ORDER BY字段上还要加索引呢?<br>回答:在MySQL中,支持两种排序方式,分别是FileSort和Index排序<br>#1.index排序中,索引可以保证数据的有序性,不需要再进行排序,效率更高<br>#2.FileSort排序则一般在内存中进行排序,占用CPU较多.如果待排序结果较大,会产生临时文件I&#x2F;O到磁盘进行排序的情况,效率较低<br>优化建议:<br>#1.SQL中,可以在WHERE子句和ORDER By子句中使用索引,目的是在WHERE子句中避免全表扫描,在ORDER BY子句避免使用FileSort排序<br>#2.尽量使用Index完成ORDER BY排序.如果WHERE和ORDER By后面是相同的列就使用单索引列;如果不同就使用联合索引<br>#3.无法使用Index时,需要对FlieSort方式进行调优<br>#WHERE和ORDER BY是可以进行联合索引的,具体要看优化器的选择</p>
<p>#使用ORDER BY排序时,字段的升序和降序要一致,否则用不了索引!<br>#结论:当[范围条件]和[group by或者order by]的字段出现二选一时,优先观察条件字段的过滤数量,如果过滤的数据足够多,而需要排序的数据并不多时,优先把索引放在范围字段上.反之,一样.</p>
<p>#filesort算法:双路排序和单路排序<br>#排序的字段如果不在索引列上,则filesort会有两种算法:双路排序(慢,mysql4.1之前)和单路排序(快,mysql4.1之后)<br>#对filesort进行调优:查询的字段字节尽量小一点,太大了会超过默认的1024字节,会使用双路算法,否则会使用单路算法 </p>
<p>#GROUP BY优化<br>#1.group by使用索引的原则几乎跟order by一致,group by即使没有过滤条件用到索引,也可以直接使用索引<br>#2.group by先排序再分组,遵循索引键的最佳左前缀法则<br>#3.当无法使用索引列,增大max_length_for_sort_data和sort_buffer_size参数的设置<br>#4.where效率高于having,能使用where就不要用having了<br>#5.减少使用order by、group by、distict这些语句比较耗费CPU</p>
<p>#分页查询优化<br>问题:select * from student limit 2000000,10;  怎么进行优化处理?<br>优化思路一:在索引上完成排序分页操作,最后根据主键关联回原表查询所需要的其他列内容<br>select * from student t,(select id from student order by id limit 2000000,10) a where t.id&#x3D;a.id;<br>先将学生的id值进行排序(这里指的主键是不递增的,乱序的),然后查询<br>优化思路二: 该方案适合用于主键自增的表,可以把limit查询转换为某个位置的查询<br>select * from student where id&gt;2000000 limit 10;</p>
<p>#优先考虑覆盖索引<br>#什么是覆盖索引?<br>#1.一个索引包含了满足查询结果的数据就叫做覆盖索引<br>#2.索引列+主键  包含select到from之间查询的列</p>
<p>#覆盖索引的利弊<br>#好处:<br>#1.避免InnoDB表进行索引的二次查询(回表) 避免了对主键的二次查询,减少了IO操作<br>#2.可以把随时IO变成顺序IO加快查询效率  把随机读取的IO变为顺序IO<br>#由于覆盖索引可以减少树的搜索次数,显著提升查询性能,所以使用覆盖索引是一个常用的性能优化手段<br>#弊端:<br>#索引字段的维护  </p>
<p>#索引条件下推(ICP)<br>#常用于联合索引中,如第一个索引可以正常使用,第二个索引会失效,此时会索引条件下推,先过滤都两个索引的数据再回表操作 如:<br>create index  max_index on student(name,fist,send);<br>select * from student  whrer name&#x3D;’孙中伟’ and fist&#x3D;’%张’ and s&#x3D;’我’;<br>#此时就会用到ICP<br>#ICP的使用条件:<br>#1.ICP可以用于InnoDB和MyISAM表,包括分区表InnoDB和MyISAM表<br>#2.对于InnoDB表,ICP仅用于二级声音<br>#3.当使用覆盖索引时,不支持ICP<br>#4.相关子查询的条件不能使用ICP</p>
<p>#其他的优化策略<br>#EXISTS和IN的区分<br>select * from  A where cc in(select cc from B);<br>select * from A where exists(select cc from B where B.cc&#x3D;A.cc)<br>#基于小表驱动大表,A表小就用exists,B表小就用in<br>#COUNT(<em>)与COUNT(具体字段)效率<br>问题:在mysql中统计数据表的行数,可以用三种方式:SELECT COUNT(</em>)、SELECT COUNT(1)和SELECT COUNT(具体字段),使用这三者之间的查询效率是怎样的?<br>#环节1:COUNT(<em>)和COUNT(1)都是对所有结果进行COUNT,COUNT(</em>)和COUNT(1)本质没有区别(可能执行时间可能略有差别,不过你还是可以把它俩的执行效率看成是相等的)<br>#环节2:如果是MyISAM存储引擎,统计数据表的行数只需要O(1)的复杂度  </p>
<h1 id="如果是InnoDB-则是O-n-的复杂度"><a href="#如果是InnoDB-则是O-n-的复杂度" class="headerlink" title="如果是InnoDB,则是O(n)的复杂度"></a>如果是InnoDB,则是O(n)的复杂度</h1><p>#环节3:在InnoDB引擎中,如果采用COUNT(具体字段)来统计数据行数,要尽量采用二级索引.因为聚簇索引包含的信息多</p>
<p>#关于SELECT(<em>)<br>#在表查询中,建议明确字段.原因是:<br>#1.MySQL在解析的过程中,会通过查询数据字典将</em>按序转换为所有列名,这会大大的耗费资源和时间<br>#2.无法使用覆盖索引</p>
<p>#LIMIT 1 对优化的影响<br>#1.针对的是会扫描全表的SQL语句,如果你可以确定结果集只有一条,那么加上LIMIT 1的时候,当找到一条结果的时候就不会继续扫描,这样会加快查询速度<br>#2.如果数据表已经对字段建立了唯一索引,那么可以通过索引进行查询,不会全表扫描的话,就不需要加上LIMIT 1了</p>
<p>select UUID() from dual;</p>
<p>#第一范式:字段具有原子性<br>#第二范式:不具有部分依赖,都为完全依赖<br>#第三范式:非主属性字段之间不能存在依赖关系</p>
<p>#反范式化:遵循业务优先的原则,首先满足业务需求,再尽量减少冗余<br>#BCNF范式(巴斯范式):在3NF的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</p>
<p>#ER模型(实体关系模型)<br>#ER模型中有三要素,分别是实体、属性和关系</p>
<p>#优化数据库结构<br>#1.拆分表:将一张表拆分为几张小表,冷热数据分离(热数据为操作频繁的数据,冷数据为操作频率低的数据)<br>#2.增加中间表:对于需要经常联合查询的表,建立中间表以提高查询效率.把需要经常联合查询的数据插入中间表中,然后对原来的联合查询改为对中间表的查询,以此提高查询效率<br>#3.增加冗余字段<br>#4.优化数据类型(优先选择最符合的最小的数据类型),使用tinmestamp存储时间(4字节),用decimal代替float和double存储精确浮点数,因为不会丢失精度<br>#5.使用非空约束:在设计字段时,如果业务允许,建议尽量使用非空约束,好处:<br>#1.进行比较和计算时,省去要对NULl值的字段判断是否为空的开销,提高存储效率<br>#2.非空字段也容易创建索引,可以节省空间(每个字段1bit)</p>
<p>#大表优化<br>#1.限定查询的范围:禁止不带任何限制数据范围条件的查询语句<br>#2.读&#x2F;写分离:主库负责写,从库负责读(主从复制)<br>#3.分库分表:当数据库中数据表过多的时候,可以采用垂直分库,将关联的数据表部署到同一个数据库上</p>
<h1 id="当数据表中的列过多-可以采用垂直分表的方式-将一张数据表拆分为多个数据表-把经常一起用的列归为同一个表"><a href="#当数据表中的列过多-可以采用垂直分表的方式-将一张数据表拆分为多个数据表-把经常一起用的列归为同一个表" class="headerlink" title="当数据表中的列过多,可以采用垂直分表的方式,将一张数据表拆分为多个数据表,把经常一起用的列归为同一个表"></a>当数据表中的列过多,可以采用垂直分表的方式,将一张数据表拆分为多个数据表,把经常一起用的列归为同一个表</h1><p>#水平分库:将大的数据表按照某个属性维度分拆为不同的小表(最好分库)<br>#常见的数据库分片的两种方案:<br>#1.客户端代理:分片逻辑在应用端,封装在jar包中,通过修改或者封装JDBC层来实现<br>#2.中间件代理:在应用和数据中间加了一个代理层.分片逻辑统一维护在中间件服务中</p>
<p>#事务的ACID原则:<br>#原子性:事务要么发生到结束,要么就回滚到开始的时候<br>#一致性:事务执行的前后,数据从一个合法性状态变换到另一个合法性状态(是具体业务的合法性,如存款肯定要大于0)<br>#隔离性:一个事务的执行不能被其他事务干扰,即一个事务内部的操作及使用的数据对并发的其他事务是隔离的,并发执行的各个事务之间不能互相干扰<br>#持久性:事务一旦被提交,它对数据库中数据的改变就是永久性的   持久性是通过事务日志来保证的,日志包括了重做日志和回滚日志.当我们对数据修改的时候,首先会将数据库的变化信息记录到重做日志中,然后再对数据库中对应的行进行修改.好处是即使数据库系统崩溃了,数据库重启后也可以找到没有更新到数据库系统中的重做日志,重写执行,从而使事务具有持久性<br>#总结:原子性是基础,隔离性是手段,一致性是约束条件,持久性是目的</p>
<p>#显示事务<br>#事务的完成过程:<br>#1.开启事务<br>#2.一系列的DML的操作<br>#3.事务结束的状态:提交的状态(COMMIT)、中止的状态(ROLLBACk)<br>#显示事务<br>#使用关键字:start transaction 或者 begin 开启<br>#start transaction后面可以跟:read only(只读操作,临时表除外)&#x2F;read write(可以进行DML 默认状态)&#x2F;with consistent snapshot<br>#可以设置保存点(savepoint),进行回滚的时候可以回滚到保存点然后再完成事务的一系列操作.一个事务可以有多个保存点   savepoint 保存点的名称(创建保存点)   release savepoint 保存点名称(删除保存点)</p>
<p>#隐式事务<br>show variables like ‘autocommit’; #查看自动提交事务是否开启  默认为ON<br>#如何关闭自动提交?<br>#方式一:<br>set autocommit&#x3D;FLASE;  #针对于DML操作是有效的,对DDL操作无效(即如果关闭了自动提交,DDL操作依然还是有效的)<br>#方式二:我们在autocommit为true的情况下,使用start transaction或者begin开启事务,那么DML操作就不会自动提交数据</p>
<p>#MySQL中completion_type参数的作用,实际上这个参数有3种可能:<br>#1.completion&#x3D;0,这是默认情况.当我们执行Commit的时候会提交事务,在执行下一个事务时,还需要使用start transction或者begin来开启<br>#2.completion&#x3D;1,这种情况下,当我们提交事务后,相当于执行了Commit and chain,也就是开启一个链式事务,即当我们提交事务之后会开启了一个相同隔离级别的事务<br>#3.completion&#x3D;2,这种情况下commit&#x3D;commit and release,也就是当我们提交后,会自动与服务器断开连接</p>
<p>#数据的并发问题<br>#1.脏写:对于两个事物SessionA,Session B,如果事务Session A修改了另一个未提交事务Session B修改过的数据,那就意味着发生了脏写(即修改后数据未发生变化)<br>#2.脏读:对于两个事务Session A,Session B,Session A读取了已经被Session B更新但还没有提交的字段.之后若Session B回滚,Session A读取的内容就是临时并且无效的<br>#3.不可重复读:对于两个事务Session A,Session B,Session A读取了一个字段,然后Session B更新了该字段.之后Session A再次读取同一个字段,值就不同了.那就意味着发生了不可重复读<br>#4.幻读:对于两个事务Session A,Session B,Session A从一个表中读取了一个字段,然后Session B在该表中插入了一些新的行.之后,如果Session A再次读取同一个表,就会多出几行</p>
<p>#SQL中的四种隔离级别<br>#按照严重性排序:脏写&gt;脏读&gt;不可重复读&gt;幻读<br>#隔离级别:read uncommitted:读未提交,不能避免脏读、不可重复读、幻读<br>         #read committed(大多数数据库系统的默认级别):读已提交,可以避免脏读,但不可重复读、幻读问题存在<br>                 #repeatable read:可重复读,可以避免脏读、不可重复读,但幻读存在(MySQL的默认隔离级别)<br>  #serializable:可串行化,确保事务可以从一个表中读取相同的行.在这个事务持续期间,禁止其他事务对该表执行插入、更新和删除操作.所以的并发问题可以避免,但是性能十分低下</p>
<p>#显示MySQL默认隔离级别<br>show variables like  ‘transaction_isolation’;<br>#设置事务的隔离级别<br>set [Global|Session] transaction isolation level 隔离级别(read committed)<br>#或者用<br>set [Global|Session] transaction_isolation &#x3D;’隔离级别’(read-committed)</p>
<p>#事务的日志<br>#事务的隔离性是通过锁机制来实现的<br>#而事务的原子性、一致性由事务的redo日志和undo日志来保证<br>#redo log称为重做日志(物理操作,比如页号),提供再写入操作,恢复提交事务修改的页操作,用来保证事务的持久性<br>#undo log称为回滚日志(逻辑操作,sql语句),回滚行记录到某个特定版本,用来保证事务的原子性、一致性</p>
<p>#InnoDB引擎的事务采用了WAL(Write-Ahead Logging),这种技术的思想就是先写日志在写磁盘,只有日志写入成功了,才算事务提交成功.当发生宕机也可以通过redo log来恢复,保证ACID中的D<br>#redo log分为两部分:1.重做日志的缓冲,保存在内存中,是容失的 2.重做日志文件,保存在硬盘中<br>show variables like ‘%innodb_log_buffer_size%’; </p>
<p>#刷盘操作:从重做日志缓冲到重做日志文件中的过程,保证数据持久的重要过程<br>#InnoDB给出InnoDB_flush_log_at_trx_commit参数,该参数控制commit提交事务的时候,任何将redo log buffer中的日志刷新到redo log file中,支持三种策略:<br>#设置为0:表示每次事务提交时不进行刷盘操作(系统默认每个1s进行一次重做日志的同步)[不能保证持久性]<br>#设置为1:表示每次事务提交时都将进行同步,刷盘操作(默认)[效率最差]<br>#设置为2:表示每次事务提交时都只把redo log buffer内容写入page cache,不进行同步.由os自己决定什么时候同步到磁盘文件[效率最高,不能保证持久性]<br>show variables  like ‘innodb_flush_log_at_trx_commit’;</p>
<p>#写入red log buffer过程<br>#补充概念:Mini—Transaction<br>#MySQL把对底层页面中的一次原子访问的过程称之为一个Mini-Transaction,简称mtr,比如向某个索引对应的B+树中插入一条记录的过程就是一个Mini-Transaction.一个所谓的mtr可以包含一组redo日志,每一条语句其实是由若干个mtr组成,每一个mtr又可以包含若干条redo日志   语句(多个mtr(多个redo))</p>
<p>#redo log flie<br>#1.相关参数:innodb_log_group_home_dir:指定redo log文件组所在的路径,默认为.&#x2F;,表示在数据库的数据目录下<br>#MySQL的默认数据目录下有2个名为ib_logfile0和ib_logfile1的文件<br>#innodb_log_file_in_group:指明redo log flie的个数,默认为2个,最大100个<br>#innodb_log_file_size:单个redo log文件设置的大小,默认为48M,最大值为512G<br>show variables like ‘innodb_log_group_home_dir’;</p>
<p>#undo log:事务原子性的保证.在事务中更新数据的前置操作其实是要先写入一个undo log<br>#此外,undo log会产生redo log,也就是undo log的产生会伴随这redo log的产生,这是因为und log也需要持久性的保护<br>show variables like ‘innodb_undo_logs’;</p>
<p>#并发问题的解决方案<br>#方案一:读操作利用多版本并发控制(MVCC),写操作进行加锁<br>#所谓MVCC,就是生成一个ReadView(保证了事务不可以读取到未提交的事务所做的更改)<br>#方案二:读、写操作都加锁<br>#小结:采用MVCC方式的话,读-写操作彼此并不冲突,性能更高<br>     #采用加锁的方式的话,读-写操作彼此需要排队执行,影响性能<br>#一般情况下我们当然愿意采用MVCC来解决读-写操作并发执行的问题,但是业务在某些特殊的情况下,要求必须加锁的方式执行</p>
<p>#从数据操作的类型划分:读锁和写锁<br>#读锁:也叫共享锁,英文用S表示,针对同一份数据,多个事务的读操作可以同时进行而不会相互影响<br>#写锁:也叫排他锁,英文用X表示,当前写操作没有完成前,它会阻断其他写锁和读锁.这样就能确保在给定的时间里,只有一个事务能执行写入,并防止其他用户读取正在写入的同一个资源<br>#注意:InnoDB引擎读锁和写锁可以加在表上,也可以加在行上,而mysiam只能加表锁<br>#只有读锁X和读锁X可以兼容<br>#MySQL8.0新特性中,在X锁中,即select …for update&#x2F;share添加nowait和skip locked语句,跳过锁等待或者跳过锁定<br>#nowait会立即报错返回  而skip locked也会立即返回,只是返回的结果中不包含被锁定的行 </p>
<p>#在Insert、Update、delete中都需要加写锁(X)<br>#Insert中,一般情况,新插入一条记录的操作并不加锁,通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问</p>
<p>#从数据操作的粒度划分:表级锁(粒度粗,开销最小)、页级锁、行锁(粒度细,高并发响应)<br>use ISM;<br>select * from book;<br>lock table book write;  #加写锁<br>lock  table book  read;  #加读锁<br>select * from book;<br>update book  set book_name&#x3D;’像我这样’  where book_id&#x3D;1<br>unlock tables;   #释放锁</p>
<p>#上面测试了锁的类型<br>锁类型 自己可读  自己可写 自己可操作其他表  他人可读 他人可写<br>读锁    是          否          否            是      否,等<br>写锁    是          是         否           否,等      否,等<br>#在InnoDB存储引擎中,一般不会为表添加表级的读锁和写锁,因为存在粒度更细的行锁</p>
<p>#在InnoDB中,添加行级锁: select … for  share 添加行级的读锁   select …for update 写锁<br>#添加表级锁,lock table 表名 read 添加表级的读锁    lock table 表名 write  写锁<br>#InnoDB支持多粒度锁,即行级锁和表级锁可以同时存在,而意向锁就是一种表锁<br>#意向锁要解决的问题:如果我们给某一行的数据加上了排他锁,数据库会自动给更大的一级空间,比如数据页或者数据表加上意向锁,来告诉其他人这个数据页或者数据表已经有人上过排他锁了,就不用在检查各个行中是否存在锁了<br>#意向锁是存储引擎自己维护的,用户无法手动操作意向锁,意向锁在保证并发性的前提下,实现了行锁和表锁共存且满足事务隔离性的要求</p>
<p>#意向锁不管是读和写都是兼容的,但是除了IS与S兼容外,意向锁会与共享锁&#x2F;排他锁互斥<br>#元数据锁–表锁</p>
<p>#InnoDB中的行锁<br>#行锁也称为记录锁,就是锁住某一行.需要的注意的是,MySQL服务器层并没有实现行锁机制,行锁只在存储引擎层实现<br>#优点:锁定力度小,发生锁冲突概率低,可以实现的并发度高<br>#缺点:对于锁的开销比较大,加锁会比较慢,容易出现死锁的情况<br>#1.记录锁:锁住一条记录<br>#2.间隙锁(gap):gap锁的提出仅仅是为了防止插入幻影记录而提出的.虽然有共享gap锁和独占gap锁这样的说法,但是他们起到的作用是相同的,并且加了gap锁,并不会限制其他事务对这条记录锁或者继续加gap锁<br>#例如有id&#x3D;3和8,在8这个行中加入了gap锁,则在(3,8)之间就不能插入数据了<br>#间隙锁是针对于两个或者两个以上的事务解决幻读问题而产生的<br>#如果两个事务都加了间隙锁,并且两个事务都进行了插入不成功的操作,则会发生死锁(表锁不会发生死锁！)<br>select * from book where book_id&#x3D;5 for update;  #对不存在的id加锁(X锁或者S锁)&#x3D;&#x3D;间隙锁<br>insert into book values (2,’wd’,’2’,50);<br>begin;<br>select * from book where book_id&#x3D;6 for update;<br>insert into book values (7,’wd’,’2’,51);<br>rollback;</p>
<p>#3.临键锁:即可以锁住某条记录,又可以阻止其他事务在该记录前边的间隙插入新记录.事务级别在可重复读的情况下使用的数据库锁,本质是一个记录锁和gap锁的合体<br>select * from book where book_id&lt;&#x3D;9 and book_id&gt;2 for update; #即锁住记录为9的数据,并且在2和9之间加间隙锁(即加了临键锁)</p>
<p>#4.插入意向锁:一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁(临键锁也包含gap锁),<br>#如果有的话,插入操作需要等待,直到拥有gap锁的那个事务提交.但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构,插入意向锁是一种 Gap锁,不是意向锁,在insert操作时产生<br>#插入意向锁之间互不排斥,所以即使多个事务在同一区间插入多条记录,只要记录本身不冲突,那么事务之间就不会出现冲突等待.插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</p>
<p>#页锁:页锁的开销介于表锁和行锁之间,会出现死锁.锁定粒度介于表锁和行锁之间,并发度一般</p>
<p>#从对待锁的态度划分:乐观锁、悲观锁(看待数据并发的思维方式,不是锁,而是锁的设计思想)<br>#1.悲观锁:共享资源每次只给一个线程使用,其他线程阻塞,用完后再把资源转让给其他线程(Java中synchronized、ReetrantLock等独占锁就是悲观锁思想的实现)<br>#select … for update 悲观锁<br>#注意select … for update语句执行过程中所有扫描的行都会被锁住,因此在MySQL中使用悲观锁必须确定使用了索引,而不是全表扫描,否则将会把整个表锁住(悲观锁的使用,很好的解决了秒杀问题出现超买的问题)<br>#2.乐观锁:不采用数据库自身的锁机制,而是通过程序来实现.在程序上,我们可以采用版本号机制和CAS机制实现.乐观锁适用于多读的应用类型,这样可以提高吞吐量<br>#@1.乐观锁的版本号控制<br>#在表中设计一个版本字段version,第一次读的时候,会获取version字段的取值,会执行update…set version&#x3D;version+1 where version&#x3D;version.如果此时已经有事务对这条事务进行了更改,修改就不会成功.这种方式类似于我们熟悉的SVN版本管理系统,当我们修改了代码进行提价时,首先会检查当前版本号与服务器上的版本号是否一致,如果一致就可以直接提交,如果不一致就需要更新服务器的最新代码,然后再进行提交<br>#@2.乐观锁的时间戳机制(和版本号控制差不多)</p>
<p>#按加锁的方式:隐式锁和显示锁<br>#隐式锁:即一个事务对新插入的记录可以不显示的加锁(生成一个锁结构),但是由于事务id的存在,相当于加了一个隐式锁,别的事务在对这条记录加S锁或者X锁时,由于隐式锁的存在,会先帮助当前事务生成一个锁结构,然后自己再生成一个锁结构后进入等待状态.是一种延迟加锁的机制,从而减少加锁的数量<br>#显示锁:通过特定的语句进行加锁</p>
<p>#其他锁之:全局锁<br>#全局锁就是对整个数据库实例加锁.当你需要让整个库处于只读状态的时候,可以使用这个命令,之后其他线程的以下语句会被阻塞:数据库更新语句、数据定义语句和更新类事务的提交语句.全局锁的典型使用场景是:做全库逻辑备份<br>#全局锁的命令:<br>Flush tables with read lock;</p>
<p>#其他锁之:死锁<br>#概念:两个事务都持有对方需要的锁,并且在等待对方释放,并且双方都不会释放自己的锁</p>
<p>#产生死锁的必要条件<br>#1.两个或者两个以上事务 2.每个事务都已经持有锁并且申请新的锁<br>#3.锁资源同时只能被同一个事务持有或者不兼容  4.事务之间因为有持有锁和申请锁导致彼此循环等待<br>#死锁的关键在于:两个或者两个以上的Session加锁的顺序不一致</p>
<p>#如何处理死锁<br>#方式1:等待,直到超时(innodb_lock_wait_timeout&#x3D;50s)<br>#查看超时时间<br>show variables like ‘innodb_lock_wait_timeout’;<br>#即当两个事务互相等待时,当一个事务等待时间超过设置的阈值时,将其回滚,另外事务继续进行<br>#缺点:对于在线服务来说,这个等待时间往往是无法接受的<br>#方式2:使用死锁检测进行死锁处理<br>#方式1检测死锁太过被动,innodb还提供了wait-for graph算法来主动进行死锁检测,每当加锁请求无法立即满足需要进行等待时,wait-for graph算法都会被触发.这是一种比较主动的死锁检测机制,要求数据库保存锁的信息链表和事务等待链表两部分信息<br>#死锁检测的原理是构建一个以事务为顶点、锁为边的有向图,判断有向图是否存在环,存在即有死锁<br>#缺点:每个新的被阻塞的线程,都要判断是不是由于自己的加入导致了死锁,这个操作时间复杂度为O(n)</p>
<p>#如何解决:方式一:关闭死锁检测,但是意味着可能会出现大量的超时,会导致业务有损<br>         #方式二:控制并发访问的数量.比如在中间件中实现对于相同行的更新,在进行引擎之前排队,这样在innodb内部就不会有大量的死锁检测工作 </p>
<p>#锁的内存结构<br>#结构解析<br>#1.锁所在的事务信息:无论是表锁还是行锁,都是事务执行过程中生成的,哪个事务生成了这个锁结构,这里就记录这个事务的信息,此锁的事务信息在内存结构中这是一个指针,通过指针可以找到内存中关于该事务的更多信息<br>#2.索引信息:对于行锁,需要记录一下加锁的记录是属性哪一个索引的.这里也是一个指针<br>#3.表锁&#x2F;行锁信息<br>#表锁结构和行锁结构在这个位置的内容是不同的<br>#表锁:记载着是对哪个表加的锁,还有其他的一些信息<br>#行锁:记录了三个重要的信息:Space ID:记录所在表空间   Page Number:记录所在的页号  n_bits:对于行锁来说,一条记录就对应着一个比特位,一个页面中包含很多记录,用不同的比特位来区分到底是哪一个记录加了锁<br>#n_bits的值一般都比页面中记录条数多一些.主要是为了之后在页面中插入了新记录后也不至于重新分配锁结构<br>#type_mode分为三部分:lock_mode,lock_type,rec_lock_type<br>#lock_mode:锁模式(区分是X锁还是S锁):IS,IX,S,X,AUTO-INC锁<br>#lock_type:锁类型(表锁和行锁)<br>#rec_lock_type(具体锁的类型)next-key锁,gap锁,记录锁,临键锁等</p>
<p>#锁监控<br>#关于MySQL锁的监控,我们一般可以通过检查InnoDB_row_lock等状态变量来分析系统上的行锁的争夺情况<br>show status like ‘innodb_row_lock%’;<br>#其他监控方法:我们把MySQL事务和锁的信息记录在information_schema库中,在5.7之前涉及到的三张表分别是InnoDB_Trx、InnoDB_LOCKs和InnoDB_lock_waits<br>#后面用performance_schema.data_locks和performance_schema.data_lock_waits代替了InnoDB_LOCKs和InnoDB_lock_waits<br>use information_schema;<br>show tables;<br>select * from InnoDB_Trx;<br>select *from performance_schema.data_locks;<br>select * from performance_schema.data_lock_waits;</p>
<p>#多版本并发控制<br>#1.MVCC:通过数据行的多个版本管理来实现数据库的并发控制<br>#2.快照读与当前读<br>#2.1快照读:又叫一致性读,读取的是快照数据.不加锁的简单的Select都属于快照读,快照读是为了提高并发性的考虑,实现是基于MVCC,很多情况下,避免了加锁操作,降低了开销<br>#2.2当前读:当前读取的是最新的版本,读取时还要保证其他事务并发不能修改当前记录,会对读取的记录加锁</p>
<p>#隐藏字段、Undo Log版本链<br>#聚簇索引记录中都包含两个必要的隐藏列:1.trx_id:每次一个事务对某条聚簇索引记录进行改动时,都会把事务的事务id赋值给trx_id隐藏列<br>#2.roll_pointer:每次对某条聚簇索引记录进行改动时,都会把旧的版本写到undo日志中,然后这个隐藏列就相当于一个指针,可以通过它来找到该记录修改前的信息</p>
<p>#MVCC实现原理之ReadView<br>#什么是ReadView?就是事务A在使用MVCC机制进行快照读操作时产生的读视图,当事务启动时,会生成一个快照,InnoDB为每个事务构造了一个数组,用来记录并维护系统当前活跃事务的id(启动了但是还没有提交)<br>#ReadView中主要包含4个比较重要的内容:<br>#1.create_trx_id:创建这个ReadView的事务id(只有增删改才会为事务分配事务id,否则在一个只读的事务id默认为0)<br>#2.trx_ids:表示在生成ReadView时当前系统中活跃的读写事务的事务id列表<br>#3.up_limit_id:活跃的事务中最小的事务id<br>#4.low_limit_id:最大事务id中应该分配给下一个事务的id值(即最大事务id+1)</p>
<p>#MVCC整体操作流程<br>#1.首先获取事务自己的版本号,也就是事务ID<br>#2.获取ReadView<br>#3.查询得到的数据,然后与ReadView中的事务版本号进行比较<br>#4.如果不符合ReadView规则,就需要从Undo log中获取历史快照(某个版本的数据对当前事务不可见的话,那就顺着版本链找到下一个版本的数据,继续按照上边的步骤判断,以此类推.如果最后一个版本也不可见的话,那么就意味着该条记录找不见)<br>#5.最后返回符号规则的数据</p>
<p>#在不同隔离级别下,ReadView的生成情况:在读已提交隔离级别中,同样的查询语句都会重新获取一次ReadView,这时如果ReadView不同,就可能产生不可重复读或者幻读的情况<br>#在可重复读的隔离级别下,一个事务只有在第一次Select这个语句的时候会获取一次ReadView,而后面的Select操作都会复用这个ReadView,故不会出现不可重复读或者幻读的情况</p>
<p>#MVCC可以解决:<br>#1.读写之间阻塞的问题:通过MVCC可以让读写互相不阻塞,即读不阻塞写,写不阻塞读,提高并发处理能力<br>#2.降低了死锁的概率:MVCC采用了乐观锁的方式,读取数据时并不需要加锁,对于写操作,也只锁定必要的行<br>#3.解决了快照读的问题:当我们查询数据库在某个时间点的快照时,只能看到这个时间点之前事务提交更新的结果,而不能看到这个时间点之后事务提交的更新结果</p>
<p>#其他日志<br>#日志的类型:分为二进制日志、错误日志、通用查询日志和慢查询日志.MySQL 8又新增了两种支持的日志:中继日志和数据定义语句日志<br>#作用:1.慢查询日志:记录所有执行时间超过long_query_time的所有查询,方便优化<br>#2.通用查询日志:记录所有连接的起始时间和终止时间,以及连接发送给数据库器的所有指令(可以还原操作时的具体场景)<br>#3.错误日志:记录MySQL服务的启动、运行或停止MySQL服务时出现的问题<br>#4.二进制日志:记录所有更改数据的语句,可以用于主从服务器之间的数据同步,以及服务器遇到故障时数据的无损失恢复<br>#5.中继日志:用于主从服务器架构中,从服务器用来存放主服务器二进制日志内容的一个中间文件.从服务器通过读取中继日志的内容,来同步主服务器上的操作<br>#6.数据定义语句日志:记录数据定义语句执行的元数据操作<br>#即主服务器更改内容存放到二进制文件中,从服务器通过读取二进制文件,存放到中继日志中,然后读取中继日志进行主从复制</p>
<p>#除二进制日志外,其他日志都是文本文件.默认情况下,所有日志创建于MySQL数据目录中</p>
<p>#日志的弊端:<br>#1.日志功能会降低MySQL数据库的性能(花费很多时间记录日志)<br>#2.日志会占用大量的磁盘空间.对于用户非常大、操作非常频繁的数据库,日志文件需要的存储空间设置比数据库文件需要的存储空间还要大</p>
<p>#查看通用查询日志的参数情况(开启状态(默认为不开启)和文件位置)<br>show  variables like ‘%general%’;<br>show variables like ‘general_log%’;<br>#错误日志是默认开启的,并且不能关闭<br>#查看错误日志的相关参数<br>show variables like ‘log_err%’;</p>
<p>#二进制日志(bin log)<br>#也叫变更日志.它记录了数据库所有执行的DDL和DML等数据库更新事件的语句,但是不包含没有修改任何数据的语句(如数据查询语句select、show等),它以事件形式记录保持在二进制文件中<br>#主要应用场景:<br>#1.用于数据恢复,如果MySQL数据库意外停止,可以通过二进制日志文件来查看用户执行了哪些操作,对数据库服务器文件做了哪些修改,然后根据二进制文件中的记录来恢复数据库服务器<br>#2.用于数据复制,由于日志的延续性和时效性,主机把它的二进制日志传递给从机来达到主从数据一致性的目的</p>
<p>#MySQL数据库的数据备份、主备、主主、主从都离不开二进制文件,需要依靠二进制文件来同步数据,保证数据一致性<br>#查看二进制日志文件的默认参数(默认是开启的)<br>show variables like ‘log_bin%’;<br>#日志文件最好和数据库文件分开！</p>
<p>#查看当前二进制日志文件列表以及大小<br>show binary logs;<br>#查看binlog日志文件(全部文件内容)的内容信息<br>show binlog events;<br>#查看指定文件的内容信息(在这里为binlog.000043)<br>show binlog events in ‘binlog.000050’;<br>#生成一个存储将要恢复数据的信息<br>flush logs;<br>#查看binlog的默认格式(默认为ROW格式),除此之外,binlog还有2种格式,分别为Statement和Mixed<br>show variables like  ‘binlog_format’;<br>use ISM;<br>show tables;<br>select * from book;<br>insert into book VALUES(11,’我的’,’你的’,1111),(12,’我的’,’你的’,101),(12,’我的’,’你的’,11;<br>#可以使用binlog进行数据的恢复</p>
<p>#删除二进制日志<br>#MySQL的二进制文件可以配置自动删除,同时MySQL也提供了安全的手动删除二进制文件的方法<br>#1.Purge master  logs:删除指定日志文件<br>#语法如下:Purge{master|binary} logs to ‘指定日志文件名’<br>         #Purge{master|binary} logs before ‘指定日期’<br>#2.reset master:删除所有二进制日志文件<br>#使用了reset maser语句,清空所有的binlog日志,MySQL会重新创建二进制文件,新的日志文件扩展名将重新从000001开始编号,慎用!</p>
<p>#binlog与redolog对比<br>#1.redo log是物理日志,记录内容是’在某个数据页上做了什么修改’,属于InnoDB存储引擎层产生的<br>#2.而binlog是逻辑日志,记录内容是语句的原始逻辑,类似于’给ID&#x3D;2这一行的c字段加1’,属于MySQL Server层<br>#3.虽然它们都属于持久化的保证,但是侧重点不同:<br>#redo log让InnoDB存储引擎拥有了崩溃恢复能力<br>#binlog保证了MySQL集群架构的数据一致性</p>
<p>#两阶段提交<br>#在执行更新语句过程,以基本的事务为单位,redo log在事务执行过程中可以不断写入,而binlog只有在提交事务时才写入,所以redo log与binlog的写入时机不一样</p>
<p>#使用两阶段提交后(即将redo log分为2个阶段,为prepare阶段和commit阶段,而binlog在redo log阶段之前),这样写入binlog时发生异常也不会影响,因为MySQL根据redo log日志恢复数据时,发现redo log还处于prepare阶段,并且没有对应binlog日志.就会回滚该事务,从而有效的解决了主从数据不一致的情况</p>
<p>#另一个场景,redo log设置commit阶段发生异常,那会不会回滚事务呢?<br>#并不会回滚事务,当检测到redo log已经commit或者写入了binlog的时候,事务都会正常的提交</p>
<p>#中继日志<br>#中继日志只在主从服务器架构的从服务器上存在.为了保证数据的一致性,主服务器将内容写二进制文件,从服务器读取中继日志保证数据的一致性</p>
<p>#主从复制的作用:1.读写分离;2.数据备份;3.具有高可用性</p>
<p>#主从复制的原理:三个线程问题:<br>#1.二进制日志转储线程:是一个主库线程.当从库线程连接的时候,主库可以将二进制日志发送给从库,当主库读取事情的时候,会在二进制文件(Binlog)上加锁,读取完成之后,再将锁释放掉<br>#2.从库I&#x2F;O线程:会连接到主库,向主库发送请求更新Binlog.这时从库的I&#x2F;O线程就可以读到主库的二进制日志转储线程发送的Binlog更新部分,并且拷贝到本地的中继日志<br>#3.从库SQL线程会读取从库中的中继日志,并且执行日志中的事件,将从库中的数据与主库保持同步</p>
<p>#复制三步骤:<br>#步骤1:Master(主机)将写操作记录到二进制文件.这些记录叫做二进制日志事件<br>#步骤2:Slave(从机)将主机的二进制拷贝到它的中继日志中<br>#步骤3:从机重做中继日志中的事件,将改变应用到自己的数据库中.MySQL复制是异步的并且串行化的,而且重启后从接入点开始复制<br>#复制的问题:最大的问题就是延时</p>
<p>#复制的基本原则:1.每个从机只有一个主机  2.每个从机只能有唯一的服务器ID   3.每个主机可以有多个从机<a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">https://hexo.io/docs/one-command-deployment.html</a>)</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="true"
        data-ae="true"
        data-ci="756f76ca3f305808772c"
        data-cs="b29b8b4a65d590d87e4691f151225b485581592a"
        data-r="myfaithisc.github.io"
        data-o="myfaithisc"
        data-a="myfaithisc"
        data-d="true"
    >查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="toc-number">1.</span> <span class="toc-text">关于数据库的那些事情</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BA%8B%E6%83%85"><span class="toc-number">2.</span> <span class="toc-text">1.关于索引的事情</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.</span> <span class="toc-text">@1.索引的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D-%E5%9C%A8create-table-%E7%9A%84%E6%97%B6%E5%80%99%E5%8A%A0%E4%B8%8A%E7%BA%A6%E6%9D%9F%EF%BC%88%E9%9A%90%E5%BC%8F%E5%88%9B%E5%BB%BA%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">第一种:在create table 的时候加上约束（隐式创建）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D-%E5%9C%A8creat-table%E7%9A%84%E6%97%B6%E5%80%99%E7%9B%B4%E6%8E%A5%E5%8A%A0%E4%B8%8A%E7%B4%A2%E5%BC%95-%E6%98%BE%E7%A4%BA%E5%88%9B%E5%BB%BA"><span class="toc-number">2.3.</span> <span class="toc-text">第二种:在creat table的时候直接加上索引(显示创建)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D-%E6%94%B9%E5%8F%98%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84-%E7%B4%A2%E5%BC%95%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">第三种:改变表的结构(索引从无到有的结构)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-number">2.5.</span> <span class="toc-text">@2.查看索引的命令行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">2.6.</span> <span class="toc-text">@3.删除主键索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Mysql8-0%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.7.</span> <span class="toc-text">@4.Mysql8.0新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95-%E5%9C%A88-0%E7%89%88%E6%9C%AC%E4%B9%8B%E5%89%8D%E5%88%9B%E5%BB%BA%E7%9A%84%E4%BB%8D%E7%84%B6%E6%98%AF%E5%8D%87%E5%BA%8F%E7%B4%A2%E5%BC%95-%E4%BD%BF%E7%94%A8%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%8F%8D%E5%90%91%E6%89%AB%E6%8F%8F-%E8%BF%99%E5%A4%A7%E5%A4%A7%E9%99%8D%E4%BD%8E%E4%BA%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%88%E7%8E%87"><span class="toc-number">2.7.1.</span> <span class="toc-text">1.支持降序索引  (在8.0版本之前创建的仍然是升序索引,使用时进行反向扫描,这大大降低了数据库的效率)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%94%AF%E6%8C%81%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95-%E9%80%9A%E8%BF%87%E5%85%88%E5%B0%86%E7%B4%A2%E5%BC%95%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95-%E5%86%8D%E8%80%83%E8%99%91%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E5%BC%8F%E5%B0%B1%E6%98%AF%E8%BD%AF%E5%88%A0%E9%99%A4-%E8%BF%98%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E9%AA%8C%E8%AF%81%E6%9F%90%E4%B8%AA%E7%B4%A2%E5%BC%95-%E5%88%A0%E9%99%A4%E4%B9%8B%E5%90%8E%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D-%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%9A%82%E6%97%B6%E5%85%88%E9%9A%90%E8%97%8F%E8%AF%A5%E7%B4%A2%E5%BC%95"><span class="toc-number">2.7.2.</span> <span class="toc-text">2.支持隐藏索引  通过先将索引设置为隐藏索引,再考虑要不要删除索引的方式就是软删除,还可以用于验证某个索引 删除之后的查询性能影响,就可以暂时先隐藏该索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">2.8.</span> <span class="toc-text">@5.哪些情况适合创建索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%98%AFInnoDB-%E5%88%99%E6%98%AFO-n-%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number"></span> <span class="toc-text">如果是InnoDB,则是O(n)的复杂度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BD%93%E6%95%B0%E6%8D%AE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%88%97%E8%BF%87%E5%A4%9A-%E5%8F%AF%E4%BB%A5%E9%87%87%E7%94%A8%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%E7%9A%84%E6%96%B9%E5%BC%8F-%E5%B0%86%E4%B8%80%E5%BC%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%8B%86%E5%88%86%E4%B8%BA%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%A1%A8-%E6%8A%8A%E7%BB%8F%E5%B8%B8%E4%B8%80%E8%B5%B7%E7%94%A8%E7%9A%84%E5%88%97%E5%BD%92%E4%B8%BA%E5%90%8C%E4%B8%80%E4%B8%AA%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">当数据表中的列过多,可以采用垂直分表的方式,将一张数据表拆分为多个数据表,把经常一起用的列归为同一个表</span></a>
        </div>
    
</div>


    </div>
</div>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>
<script src="/js/codeCopy.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
